[
  {
    "filename": "setup.py",
    "path": "setup.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"The Qiskit setup file.\"\n\nimport os\nfrom setuptools import setup\nfrom setuptools_rust import Binding, RustExtension\n\n# Most of this configuration is managed by `pyproject.toml`.  This only includes the extra bits to\n# configure `setuptools-rust`, because we do a little dynamic trick with the debug setting, and we\n# also want an explicit `setup.py` file to exist so we can manually call\n#\n#   python setup.py build_rust --inplace --release\n#\n# to make optimized Rust components even for editable releases, which would otherwise be quite\n# unergonomic to do otherwise.\n\n\n# If RUST_DEBUG is set, force compiling in debug mode. Else, use the default behavior of whether\n# it's an editable installation.\nrust_debug = True if os.getenv(\"RUST_DEBUG\") == \"1\" else None\n\n# If QISKIT_NO_CACHE_GATES is set then don't enable any features while building\n#\n# TODO: before final release we should reverse this by default once the default transpiler pass\n# is all in rust (default to no caching and make caching an opt-in feature). This is opt-out\n# right now to avoid the runtime overhead until we are leveraging the rust gates infrastructure.\nif os.getenv(\"QISKIT_NO_CACHE_GATES\") == \"1\":\n    features = []\nelse:\n    features = [\"cache_pygates\"]\n\n\nsetup(\n    rust_extensions=[\n        RustExtension(\n            \"qiskit._accelerate\",\n            \"crates/pyext/Cargo.toml\",\n            binding=Binding.PyO3,\n            debug=rust_debug,\n            features=features,\n        )\n    ],\n    options={\"bdist_wheel\": {\"py_limited_api\": \"cp39\"}},\n)\n",
    "line_count": 56
  },
  {
    "filename": "conf.py",
    "path": "docs/conf.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\nfrom __future__ import annotations\n\n# pylint: disable=invalid-name,missing-function-docstring\n\n\"\"\"Sphinx documentation builder.\"\"\"\n\nimport datetime\nimport doctest\nimport importlib\nimport inspect\nimport os\nimport re\nfrom pathlib import Path\n\n\nproject = \"Qiskit\"\nproject_copyright = f\"2017-{datetime.date.today().year}, Qiskit Development Team\"\nauthor = \"Qiskit Development Team\"\n\n# The short X.Y version\nversion = \"2.1\"\n# The full version, including alpha/beta/rc tags\nrelease = \"2.1.0\"\n\nlanguage = \"en\"\n\nrst_prolog = f\".. |version| replace:: {version}\"\n\nextensions = [\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.doctest\",\n    # This is used by qiskit/documentation to generate links to github.com.\n    \"sphinx.ext.linkcode\",\n    \"matplotlib.sphinxext.plot_directive\",\n    \"reno.sphinxext\",\n    \"sphinxcontrib.katex\",\n    \"breathe\",\n]\n\nbreathe_projects = {\"qiskit\": \"xml/\"}\nbreathe_default_project = \"qiskit\"\n\ntemplates_path = [\"_templates\"]\n\n# Number figures, tables and code-blocks if they have a caption.\nnumfig = True\n# Available keys are 'figure', 'table', 'code-block' and 'section'.  '%s' is the number.\nnumfig_format = {\"table\": \"Table %s\"}\n\n# Relative to source directory, affects general discovery, and html_static_path and html_extra_path.\nexclude_patterns = [\"_build\", \"**.ipynb_checkpoints\"]\n\n\n# This adds the module name to e.g. function API docs. We use the default of True because our\n# module pages sometimes have functions from submodules on the page, and we want to make clear\n# that you must include the submodule to import it. We should strongly consider reorganizing our\n# code to avoid this, i.e. re-exporting the submodule members from the top-level module. Once fixed\n# and verified by only having a single `.. currentmodule::` in the file, we can turn this back to\n# False.\nadd_module_names = True\n\n# A list of prefixes that are ignored for sorting the Python module index\n# (e.g., if this is set to ['foo.'], then foo.bar is shown under B, not F).\nmodindex_common_prefix = [\"qiskit.\"]\n\n# ----------------------------------------------------------------------------------\n# Intersphinx\n# ----------------------------------------------------------------------------------\n\nintersphinx_mapping = {\n    \"rustworkx\": (\"https://www.rustworkx.org/\", None),\n    \"qiskit-ibm-runtime\": (\"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/\", None),\n    \"qiskit-aer\": (\"https://qiskit.github.io/qiskit-aer/\", None),\n    \"numpy\": (\"https://numpy.org/doc/stable/\", None),\n    \"matplotlib\": (\"https://matplotlib.org/stable/\", None),\n    \"python\": (\"https://docs.python.org/3/\", None),\n}\n\n# ----------------------------------------------------------------------------------\n# HTML theme\n# ----------------------------------------------------------------------------------\n\nhtml_theme = \"alabaster\"\nhtml_last_updated_fmt = \"%Y/%m/%d\"\n\n# ----------------------------------------------------------------------------------\n# Autodoc\n# ----------------------------------------------------------------------------------\n\n# Note that setting autodoc defaults here may not have as much of an effect as you may expect; any\n# documentation created by autosummary uses a template file (in autosummary in the templates path),\n# which likely overrides the autodoc defaults.\n\n# These options impact when using `.. autoclass::` manually.\n# They do not impact the `.. autosummary::` templates.\nautodoc_default_options = {\n    \"show-inheritance\": True,\n}\n\n# Move type hints from signatures to the parameter descriptions (except in overload cases, where\n# that's not possible).\nautodoc_typehints = \"description\"\nautoclass_content = \"both\"\n# Some type hints are too long to be understandable. So, we set up aliases to be used instead.\nautodoc_type_aliases = {\n    \"EstimatorPubLike\": \"EstimatorPubLike\",\n    \"SamplerPubLike\": \"SamplerPubLike\",\n}\n\nautosummary_generate = True\nautosummary_generate_overwrite = False\n\n# We only use Google-style docstrings, and allowing Napoleon to parse Numpy-style docstrings both\n# slows down the build (a little) and can sometimes result in _regular_ section headings in\n# module-level documentation being converted into surprising things.\nnapoleon_google_docstring = True\nnapoleon_numpy_docstring = False\n\n# Autosummary generates stub filenames based on the import name.\n# Sometimes, two distinct interfaces only differ in capitalization; this\n# creates a problem on case-insensitive OS/filesystems like macOS. So,\n# we manually avoid the clash by renaming one of the files.\nautosummary_filename_map = {\n    \"qiskit.circuit.library.iqp\": \"qiskit.circuit.library.iqp_function\",\n}\n\n\n# ----------------------------------------------------------------------------------\n# Doctest\n# ----------------------------------------------------------------------------------\n\ndoctest_default_flags = (\n    doctest.ELLIPSIS\n    | doctest.NORMALIZE_WHITESPACE\n    | doctest.IGNORE_EXCEPTION_DETAIL\n    | doctest.DONT_ACCEPT_TRUE_FOR_1\n)\n\n# Leaving this string empty disables testing of doctest blocks from docstrings.\n# Doctest blocks are structures like this one:\n# >> code\n# output\ndoctest_test_doctest_blocks = \"\"\n\n\n# ----------------------------------------------------------------------------------\n# Plot directive\n# ----------------------------------------------------------------------------------\n\nplot_html_show_formats = False\n\n\n# ----------------------------------------------------------------------------------\n# Source code links\n# ----------------------------------------------------------------------------------\n\nREPO_ROOT = Path(__file__).resolve().parents[1]\n\n\ndef linkcode_resolve(domain, info):\n    if domain != \"py\":\n        return None\n\n    module_name = info[\"module\"]\n    if \"qiskit\" not in module_name:\n        return None\n\n    try:\n        module = importlib.import_module(module_name)\n    except ModuleNotFoundError:\n        return None\n\n    obj = module\n    for part in info[\"fullname\"].split(\".\"):\n        try:\n            obj = getattr(obj, part)\n        except AttributeError:\n            return None\n\n    # Unwrap decorators. This requires they used `functools.wrap()`.\n    while hasattr(obj, \"__wrapped__\"):\n        obj = getattr(obj, \"__wrapped__\")\n\n    try:\n        full_file_name = inspect.getsourcefile(obj)\n    except TypeError:\n        return None\n    if full_file_name is None:\n        return None\n    try:\n        relative_file_name = Path(full_file_name).resolve().relative_to(REPO_ROOT)\n        file_name = re.sub(r\"\\.tox\\/.+\\/site-packages\\/\", \"\", relative_file_name.as_posix())\n    except ValueError:\n        return None\n\n    try:\n        source, lineno = inspect.getsourcelines(obj)\n    except (OSError, TypeError):\n        linespec = \"\"\n    else:\n        ending_lineno = lineno + len(source) - 1\n        linespec = f\"#L{lineno}-L{ending_lineno}\"\n\n    github_branch = os.environ.get(\"QISKIT_DOCS_GITHUB_BRANCH_NAME\", \"main\")\n    return f\"https://github.com/Qiskit/qiskit/tree/{github_branch}/{file_name}{linespec}\"\n",
    "line_count": 221
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n# pylint: disable=wrong-import-position,wrong-import-order\n\n\"\"\"Main Qiskit public functionality.\"\"\"\n\nimport importlib.metadata\nimport importlib.util\nimport os\nimport sys\nimport warnings\n\ntry:\n    importlib.metadata.version(\"qiskit-terra\")\nexcept importlib.metadata.PackageNotFoundError:\n    # All good!\n    pass\nelse:\n    # 'qiskit.tools' is present in all 0.x series of Qiskit and not in Qiskit 1.0+.  If a dev has an\n    # editable install and switches from 0.x branches to 1.0+ branches, they might have an empty\n    # `qiskit/tools` folder in their path, which will appear as a \"namespace package\" with no valid\n    # location.  We catch that case as \"not actually having Qiskit 0.x\" as a convenience to devs.\n    _has_tools = getattr(importlib.util.find_spec(\"qiskit.tools\"), \"has_location\", False)\n    _suppress_error = os.environ.get(\"QISKIT_SUPPRESS_1_0_IMPORT_ERROR\", False) == \"1\"\n    if not _suppress_error and _has_tools:\n        raise ImportError(\n            \"Qiskit is installed in an invalid environment that has both Qiskit >=1.0\"\n            \" and an earlier version.\"\n            \" You should create a new virtual environment, and ensure that you do not mix\"\n            \" dependencies between Qiskit <1.0 and >=1.0.\"\n            \" Any packages that depend on 'qiskit-terra' are not compatible with Qiskit 1.0 and\"\n            \" will need to be updated.\"\n            \" Qiskit unfortunately cannot enforce this requirement during environment resolution.\"\n            \" See https://qisk.it/packaging-1-0 for more detail.\"\n        )\n\nfrom . import _accelerate\nimport qiskit._numpy_compat\n\n# Globally define compiled submodules. The normal import mechanism will not find compiled submodules\n# in _accelerate because it relies on file paths, but PyO3 generates only one shared library file.\n# We manually define them on import so people can directly import qiskit._accelerate.* submodules\n# and not have to rely on attribute access.  No action needed for top-level extension packages.\nsys.modules[\"qiskit._accelerate.circuit\"] = _accelerate.circuit\nsys.modules[\"qiskit._accelerate.circuit.classical\"] = _accelerate.circuit.classical\nsys.modules[\"qiskit._accelerate.circuit.classical.expr\"] = _accelerate.circuit.classical.expr\nsys.modules[\"qiskit._accelerate.circuit.classical.types\"] = _accelerate.circuit.classical.types\nsys.modules[\"qiskit._accelerate.circuit_library\"] = _accelerate.circuit_library\nsys.modules[\"qiskit._accelerate.basis_translator\"] = _accelerate.basis_translator\nsys.modules[\"qiskit._accelerate.converters\"] = _accelerate.converters\nsys.modules[\"qiskit._accelerate.dense_layout\"] = _accelerate.dense_layout\nsys.modules[\"qiskit._accelerate.equivalence\"] = _accelerate.equivalence\nsys.modules[\"qiskit._accelerate.error_map\"] = _accelerate.error_map\nsys.modules[\"qiskit._accelerate.gates_in_basis\"] = _accelerate.gates_in_basis\nsys.modules[\"qiskit._accelerate.isometry\"] = _accelerate.isometry\nsys.modules[\"qiskit._accelerate.uc_gate\"] = _accelerate.uc_gate\nsys.modules[\"qiskit._accelerate.euler_one_qubit_decomposer\"] = (\n    _accelerate.euler_one_qubit_decomposer\n)\nsys.modules[\"qiskit._accelerate.nlayout\"] = _accelerate.nlayout\nsys.modules[\"qiskit._accelerate.optimize_1q_gates\"] = _accelerate.optimize_1q_gates\nsys.modules[\"qiskit._accelerate.pauli_expval\"] = _accelerate.pauli_expval\nsys.modules[\"qiskit._accelerate.qasm2\"] = _accelerate.qasm2\nsys.modules[\"qiskit._accelerate.qasm3\"] = _accelerate.qasm3\nsys.modules[\"qiskit._accelerate.remove_diagonal_gates_before_measure\"] = (\n    _accelerate.remove_diagonal_gates_before_measure\n)\nsys.modules[\"qiskit._accelerate.results\"] = _accelerate.results\nsys.modules[\"qiskit._accelerate.sabre\"] = _accelerate.sabre\nsys.modules[\"qiskit._accelerate.sampled_exp_val\"] = _accelerate.sampled_exp_val\nsys.modules[\"qiskit._accelerate.sparse_observable\"] = _accelerate.sparse_observable\nsys.modules[\"qiskit._accelerate.sparse_pauli_op\"] = _accelerate.sparse_pauli_op\nsys.modules[\"qiskit._accelerate.star_prerouting\"] = _accelerate.star_prerouting\nsys.modules[\"qiskit._accelerate.elide_permutations\"] = _accelerate.elide_permutations\nsys.modules[\"qiskit._accelerate.target\"] = _accelerate.target\nsys.modules[\"qiskit._accelerate.two_qubit_decompose\"] = _accelerate.two_qubit_decompose\nsys.modules[\"qiskit._accelerate.unitary_synthesis\"] = _accelerate.unitary_synthesis\nsys.modules[\"qiskit._accelerate.vf2_layout\"] = _accelerate.vf2_layout\nsys.modules[\"qiskit._accelerate.synthesis.permutation\"] = _accelerate.synthesis.permutation\nsys.modules[\"qiskit._accelerate.synthesis.linear\"] = _accelerate.synthesis.linear\nsys.modules[\"qiskit._accelerate.synthesis.clifford\"] = _accelerate.synthesis.clifford\nsys.modules[\"qiskit._accelerate.barrier_before_final_measurement\"] = (\n    _accelerate.barrier_before_final_measurement\n)\nsys.modules[\"qiskit._accelerate.commutation_checker\"] = _accelerate.commutation_checker\nsys.modules[\"qiskit._accelerate.commutation_analysis\"] = _accelerate.commutation_analysis\nsys.modules[\"qiskit._accelerate.commutation_cancellation\"] = _accelerate.commutation_cancellation\nsys.modules[\"qiskit._accelerate.consolidate_blocks\"] = _accelerate.consolidate_blocks\nsys.modules[\"qiskit._accelerate.synthesis.linear_phase\"] = _accelerate.synthesis.linear_phase\nsys.modules[\"qiskit._accelerate.synthesis.evolution\"] = _accelerate.synthesis.evolution\nsys.modules[\"qiskit._accelerate.synthesis.multi_controlled\"] = (\n    _accelerate.synthesis.multi_controlled\n)\nsys.modules[\"qiskit._accelerate.synthesis.qft\"] = _accelerate.synthesis.qft\nsys.modules[\"qiskit._accelerate.split_2q_unitaries\"] = _accelerate.split_2q_unitaries\nsys.modules[\"qiskit._accelerate.gate_direction\"] = _accelerate.gate_direction\nsys.modules[\"qiskit._accelerate.inverse_cancellation\"] = _accelerate.inverse_cancellation\nsys.modules[\"qiskit._accelerate.check_map\"] = _accelerate.check_map\nsys.modules[\"qiskit._accelerate.filter_op_nodes\"] = _accelerate.filter_op_nodes\nsys.modules[\"qiskit._accelerate.twirling\"] = _accelerate.twirling\nsys.modules[\"qiskit._accelerate.high_level_synthesis\"] = _accelerate.high_level_synthesis\nsys.modules[\"qiskit._accelerate.remove_identity_equiv\"] = _accelerate.remove_identity_equiv\nsys.modules[\"qiskit._accelerate.circuit_duration\"] = _accelerate.circuit_duration\nsys.modules[\"qiskit._accelerate.cos_sin_decomp\"] = _accelerate.cos_sin_decomp\n\nfrom qiskit.exceptions import QiskitError, MissingOptionalLibraryError\n\n# The main qiskit operators\nfrom qiskit.circuit import ClassicalRegister\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit import AncillaRegister\nfrom qiskit.circuit import QuantumCircuit\n\n# user config\nfrom qiskit import user_config as _user_config\n\nimport qiskit.circuit.measure\nimport qiskit.circuit.reset\n\n_config = _user_config.get_config()\n\nfrom qiskit.compiler import transpile\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom .version import __version__\n\n\n__all__ = [\n    \"AncillaRegister\",\n    \"ClassicalRegister\",\n    \"MissingOptionalLibraryError\",\n    \"QiskitError\",\n    \"QuantumCircuit\",\n    \"QuantumRegister\",\n    \"transpile\",\n    \"generate_preset_pass_manager\",\n]\n",
    "line_count": 147
  },
  {
    "filename": "_numpy_compat.py",
    "path": "qiskit/_numpy_compat.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compatibility helpers for the Numpy 1.x to 2.0 transition.\"\"\"\n\nimport re\nimport typing\nimport warnings\n\nimport numpy as np\n\n# This version pattern is taken from the pypa packaging project:\n# https://github.com/pypa/packaging/blob/21.3/packaging/version.py#L223-L254 which is dual licensed\n# Apache 2.0 and BSD see the source for the original authors and other details.\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION = np.lib.NumpyVersion(np.__version__)\nVERSION_PARTS: typing.Tuple[int, ...]\n\"\"\"The numeric parts of the Numpy release version, e.g. ``(2, 0, 0)``.  Does not include pre- or\npost-release markers (e.g. ``rc1``).\"\"\"\nif match := re.fullmatch(_VERSION_PATTERN, np.__version__, flags=re.VERBOSE | re.IGNORECASE):\n    # Assuming Numpy won't ever introduce epochs, and we don't care about pre/post markers.\n    VERSION_PARTS = tuple(int(x) for x in match[\"release\"].split(\".\"))\nelse:\n    # Just guess a version.  We know all existing Numpys have good version strings, so the only way\n    # this should trigger is from a new or a dev version.\n    warnings.warn(\n        f\"Unrecognized version string for Numpy: '{np.__version__}'.  Assuming Numpy 2.0.\",\n        RuntimeWarning,\n    )\n    VERSION_PARTS = (2, 0, 0)\n\nCOPY_ONLY_IF_NEEDED = None if VERSION_PARTS >= (2, 0, 0) else False\n\"\"\"The sentinel value given to ``np.array`` and ``np.ndarray.astype`` (etc) to indicate that a copy\nshould be made only if required.\"\"\"\n",
    "line_count": 74
  },
  {
    "filename": "exceptions.py",
    "path": "qiskit/exceptions.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\n===============================================\nTop-level exceptions (:mod:`qiskit.exceptions`)\n===============================================\n\nExceptions\n==========\n\nAll Qiskit-related exceptions raised by Qiskit are subclasses of the base:\n\n.. autoexception:: QiskitError\n\n.. note::\n\n    Errors that are just general programming errors, such as incorrect typing, may still raise\n    standard Python errors such as ``TypeError``.  :exc:`QiskitError` is generally for errors raised\n    in usage that is particular to Qiskit.\n\nMany of the Qiskit subpackages define their own more granular error, to help in catching only the\nsubset of errors you care about.  For example, :mod:`qiskit.circuit` almost exclusively uses\n:exc:`.CircuitError`, while both :exc:`.QASM2ExportError` and :exc:`.QASM2ParseError` derive from\n:exc:`.QASM2Error` in :mod:`qiskit.qasm2`, which is in turn a type of :exc:`.QiskitError`.\n\nQiskit has several optional features that depend on other packages that are not required for a\nminimal install.  You can read more about those, and ways to check for their presence, in\n:mod:`qiskit.utils.optionals`.  Trying to use a feature that requires an optional extra will raise a\nparticular error, which subclasses both :exc:`QiskitError` and the Python built-in ``ImportError``.\n\n.. autoexception:: MissingOptionalLibraryError\n\nTwo more uncommon errors relate to failures in reading user-configuration files, or specifying a\nfilename that cannot be used:\n\n.. autoexception:: QiskitUserConfigError\n.. autoexception:: InvalidFileError\n\n\nWarnings\n========\n\nSome particular features of Qiskit may raise custom warnings.  In general, Qiskit will use built-in\nPython warnings (such as :exc:`DeprecationWarning`) when appropriate, but warnings related to\nQiskit-specific functionality will be subtypes of :exc:`QiskitWarning`.\n\n.. autoexception:: QiskitWarning\n\nRelated to :exc:`MissingOptionalLibraryError`, in some cases an optional dependency might be found,\nbut fail to import for some other reason.  In this case, Qiskit will continue as if the dependency\nis not present, but will raise :exc:`OptionalDependencyImportWarning` to let you know about it.\n\n.. autoexception:: OptionalDependencyImportWarning\n\nWhen experimental features are being used, Qiskit will raise :exc:`ExperimentalWarning`.\n\n.. warning::\n\n    Qiskit experimental features can break at any minor release and their API might change without\n    previous notification. Their use is not recommended in production.\n\n.. autoexception:: ExperimentalWarning\n\nFiltering warnings\n------------------\n\nPython has built-in mechanisms to filter warnings, described in the documentation of the\n:mod:`warnings` module.  You can use these subclasses in your warning filters from within Python to\nsilence warnings you are not interested in.  For example, if you are knowingly using experimental\nfeatures and are comfortable that they make break in later versions, you can silence\n:exc:`ExperimentalWarning` like this::\n\n    import warnings\n    from qiskit.exceptions import ExperimentalWarning\n\n    warnings.filterwarnings(\"ignore\", category=ExperimentalWarning)\n\"\"\"\n\nfrom typing import Optional\n\n\nclass QiskitError(Exception):\n    \"\"\"Base class for errors raised by Qiskit.\"\"\"\n\n    def __init__(self, *message):\n        \"\"\"Set the error message.\"\"\"\n        super().__init__(\" \".join(message))\n        self.message = \" \".join(message)\n\n    def __str__(self):\n        \"\"\"Return the message.\"\"\"\n        return repr(self.message)\n\n\nclass QiskitUserConfigError(QiskitError):\n    \"\"\"Raised when an error is encountered reading a user config file.\"\"\"\n\n    message = \"User config invalid\"\n\n\nclass MissingOptionalLibraryError(QiskitError, ImportError):\n    \"\"\"Raised when an optional library is missing.\"\"\"\n\n    def __init__(\n        self, libname: str, name: str, pip_install: Optional[str] = None, msg: Optional[str] = None\n    ) -> None:\n        \"\"\"Set the error message.\n        Args:\n            libname: Name of missing library\n            name: Name of class, function, module that uses this library\n            pip_install: pip install command, if any\n            msg: Descriptive message, if any\n        \"\"\"\n        message = [f\"The '{libname}' library is required to use '{name}'.\"]\n        if pip_install:\n            message.append(f\"You can install it with '{pip_install}'.\")\n        if msg:\n            message.append(f\" {msg}.\")\n\n        super().__init__(\" \".join(message))\n        self.message = \" \".join(message)\n\n    def __str__(self) -> str:\n        \"\"\"Return the message.\"\"\"\n        return repr(self.message)\n\n\nclass InvalidFileError(QiskitError):\n    \"\"\"Raised when the file provided is not valid for the specific task.\"\"\"\n\n\nclass QiskitWarning(UserWarning):\n    \"\"\"Common subclass of warnings for Qiskit-specific warnings being raised.\"\"\"\n\n\nclass OptionalDependencyImportWarning(QiskitWarning):\n    \"\"\"Raised when an optional library raises errors during its import.\"\"\"\n\n    # Not a subclass of `ImportWarning` because those are hidden by default.\n\n\nclass ExperimentalWarning(QiskitWarning):\n    \"\"\"Raised when an experimental feature is being used.\"\"\"\n",
    "line_count": 154
  },
  {
    "filename": "user_config.py",
    "path": "qiskit/user_config.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Utils for reading a user preference config files.\"\"\"\n\nimport configparser\nimport os\nfrom warnings import warn\n\nfrom qiskit import exceptions\n\nDEFAULT_FILENAME = os.path.join(os.path.expanduser(\"~\"), \".qiskit\", \"settings.conf\")\n\n\nclass UserConfig:\n    \"\"\"Class representing a user config file\n\n    The config file format should look like:\n\n    [default]\n    circuit_drawer = mpl\n    circuit_mpl_style = default\n    circuit_mpl_style_path = ~/.qiskit:<default location>\n    circuit_reverse_bits = True\n    circuit_idle_wires = False\n    transpile_optimization_level = 1\n    parallel = False\n    num_processes = 4\n    sabre_all_threads = true\n\n    \"\"\"\n\n    def __init__(self, filename=None):\n        \"\"\"Create a UserConfig\n\n        Args:\n            filename (str): The path to the user config file. If one isn't\n                specified, ~/.qiskit/settings.conf is used.\n        \"\"\"\n        if filename is None:\n            self.filename = DEFAULT_FILENAME\n        else:\n            self.filename = filename\n        self.settings = {}\n        self.config_parser = configparser.ConfigParser()\n\n    def read_config_file(self):\n        \"\"\"Read config file and parse the contents into the settings attr.\"\"\"\n        if not os.path.isfile(self.filename):\n            return\n        self.config_parser.read(self.filename)\n        if \"default\" in self.config_parser.sections():\n            # Parse circuit_drawer\n            circuit_drawer = self.config_parser.get(\"default\", \"circuit_drawer\", fallback=None)\n            if circuit_drawer:\n                if circuit_drawer not in [\"text\", \"mpl\", \"latex\", \"latex_source\", \"auto\"]:\n                    raise exceptions.QiskitUserConfigError(\n                        f\"{circuit_drawer} is not a valid circuit drawer backend. Must be \"\n                        \"either 'text', 'mpl', 'latex', 'latex_source', or \"\n                        \"'auto'.\"\n                    )\n                self.settings[\"circuit_drawer\"] = circuit_drawer\n\n            # Parse state_drawer\n            state_drawer = self.config_parser.get(\"default\", \"state_drawer\", fallback=None)\n            if state_drawer:\n                valid_state_drawers = [\n                    \"repr\",\n                    \"text\",\n                    \"latex\",\n                    \"latex_source\",\n                    \"qsphere\",\n                    \"hinton\",\n                    \"bloch\",\n                ]\n                if state_drawer not in valid_state_drawers:\n                    valid_choices_string = \"', '\".join(c for c in valid_state_drawers)\n                    raise exceptions.QiskitUserConfigError(\n                        f\"'{state_drawer}' is not a valid state drawer backend. \"\n                        f\"Choose from: '{valid_choices_string}'\"\n                    )\n                self.settings[\"state_drawer\"] = state_drawer\n\n            # Parse circuit_mpl_style\n            circuit_mpl_style = self.config_parser.get(\n                \"default\", \"circuit_mpl_style\", fallback=None\n            )\n            if circuit_mpl_style:\n                if not isinstance(circuit_mpl_style, str):\n                    warn(\n                        f\"{circuit_mpl_style} is not a valid mpl circuit style. Must be \"\n                        \"a text string. Will not load style.\",\n                        UserWarning,\n                        2,\n                    )\n                self.settings[\"circuit_mpl_style\"] = circuit_mpl_style\n\n            # Parse circuit_mpl_style_path\n            circuit_mpl_style_path = self.config_parser.get(\n                \"default\", \"circuit_mpl_style_path\", fallback=None\n            )\n            if circuit_mpl_style_path:\n                cpath_list = circuit_mpl_style_path.split(\":\")\n                for path in cpath_list:\n                    if not os.path.exists(os.path.expanduser(path)):\n                        warn(\n                            f\"{path} is not a valid circuit mpl style path.\"\n                            \" Correct the path in ~/.qiskit/settings.conf.\",\n                            UserWarning,\n                            2,\n                        )\n                self.settings[\"circuit_mpl_style_path\"] = cpath_list\n\n            # Parse circuit_reverse_bits\n            try:\n                circuit_reverse_bits = self.config_parser.getboolean(\n                    \"default\", \"circuit_reverse_bits\", fallback=None\n                )\n            except ValueError as err:\n                raise exceptions.QiskitUserConfigError(\n                    f\"Value assigned to circuit_reverse_bits is not valid. {str(err)}\"\n                )\n            if circuit_reverse_bits is not None:\n                self.settings[\"circuit_reverse_bits\"] = circuit_reverse_bits\n\n            # Parse circuit_idle_wires\n            try:\n                circuit_idle_wires = self.config_parser.getboolean(\n                    \"default\", \"circuit_idle_wires\", fallback=None\n                )\n            except ValueError as err:\n                raise exceptions.QiskitUserConfigError(\n                    f\"Value assigned to circuit_idle_wires is not valid. {str(err)}\"\n                )\n            if circuit_idle_wires is not None:\n                self.settings[\"circuit_idle_wires\"] = circuit_idle_wires\n\n            # Parse transpile_optimization_level\n            transpile_optimization_level = self.config_parser.getint(\n                \"default\", \"transpile_optimization_level\", fallback=-1\n            )\n            if transpile_optimization_level != -1:\n                if transpile_optimization_level < 0 or transpile_optimization_level > 3:\n                    raise exceptions.QiskitUserConfigError(\n                        \"%s is not a valid optimization level. Must be 0, 1, 2, or 3.\"\n                    )\n                self.settings[\"transpile_optimization_level\"] = transpile_optimization_level\n\n            # Parse parallel\n            parallel_enabled = self.config_parser.getboolean(\"default\", \"parallel\", fallback=None)\n            if parallel_enabled is not None:\n                self.settings[\"parallel_enabled\"] = parallel_enabled\n\n            # Parse num_processes\n            num_processes = self.config_parser.getint(\"default\", \"num_processes\", fallback=-1)\n            if num_processes != -1:\n                if num_processes <= 0:\n                    raise exceptions.QiskitUserConfigError(\n                        \"%s is not a valid number of processes. Must be greater than 0\"\n                    )\n                self.settings[\"num_processes\"] = num_processes\n\n            # Parse sabre_all_threads\n            sabre_all_threads = self.config_parser.getboolean(\n                \"default\", \"sabre_all_threads\", fallback=None\n            )\n            if sabre_all_threads is not None:\n                self.settings[\"sabre_all_threads\"] = sabre_all_threads\n\n\ndef set_config(key, value, section=None, file_path=None):\n    \"\"\"Adds or modifies a user configuration\n\n    It will add configuration to the currently configured location\n    or the value of file argument.\n\n    Only valid user config can be set in 'default' section. Custom\n    user config can be added in any other sections.\n\n    Changes to the existing config file will not be reflected in\n    the current session since the config file is parsed at import time.\n\n    Args:\n        key (str): name of the config\n        value (obj): value of the config\n        section (str, optional): if not specified, adds it to the\n            `default` section of the config file.\n        file_path (str, optional): the file to which config is added.\n            If not specified, adds it to the default config file or\n            if set, the value of `QISKIT_SETTINGS` env variable.\n\n    Raises:\n        QiskitUserConfigError: if the config is invalid\n    \"\"\"\n    filename = file_path or os.getenv(\"QISKIT_SETTINGS\", DEFAULT_FILENAME)\n    section = \"default\" if section is None else section\n\n    if not isinstance(key, str):\n        raise exceptions.QiskitUserConfigError(\"Key must be string type\")\n\n    valid_config = {\n        \"circuit_drawer\",\n        \"circuit_mpl_style\",\n        \"circuit_mpl_style_path\",\n        \"circuit_reverse_bits\",\n        \"circuit_idle_wires\",\n        \"transpile_optimization_level\",\n        \"parallel\",\n        \"num_processes\",\n        \"sabre_all_threads\",\n    }\n\n    if section in [None, \"default\"]:\n        if key not in valid_config:\n            raise exceptions.QiskitUserConfigError(f\"{key} is not a valid user config.\")\n\n    config = configparser.ConfigParser()\n    config.read(filename)\n\n    if section not in config.sections():\n        config.add_section(section)\n\n    config.set(section, key, str(value))\n\n    try:\n        with open(filename, \"w\") as cfgfile:\n            config.write(cfgfile)\n    except OSError as ex:\n        raise exceptions.QiskitUserConfigError(\n            f\"Unable to load the config file {filename}. Error: '{str(ex)}'\"\n        )\n\n    # validates config\n    user_config = UserConfig(filename)\n    user_config.read_config_file()\n\n\ndef get_config():\n    \"\"\"Read the config file from the default location or env var.\n\n    It will read a config file at the location specified by the ``QISKIT_SETTINGS`` environment\n    variable if set, or ``$HOME/.qiskit/settings.conf`` if not.\n\n    If the environment variable ``QISKIT_IGNORE_USER_SETTINGS`` is set to the string ``TRUE``, this\n    will return an empty configuration, regardless of all other variables.\n\n    Returns:\n        dict: The settings dict from the parsed config file.\n    \"\"\"\n    if os.getenv(\"QISKIT_IGNORE_USER_SETTINGS\", \"false\").lower() == \"true\":\n        return {}\n    filename = os.getenv(\"QISKIT_SETTINGS\", DEFAULT_FILENAME)\n    if not os.path.isfile(filename):\n        return {}\n    user_config = UserConfig(filename)\n    user_config.read_config_file()\n    return user_config.settings\n",
    "line_count": 267
  },
  {
    "filename": "version.py",
    "path": "qiskit/version.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2018.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n# pylint: disable=no-name-in-module,broad-except,cyclic-import\n\n\"\"\"Contains Qiskit version.\"\"\"\n\nimport os\nimport subprocess\n\nROOT_DIR = os.path.dirname(os.path.abspath(__file__))\n\n\ndef _minimal_ext_cmd(cmd):\n    # construct minimal environment\n    env = {}\n    for k in [\"SYSTEMROOT\", \"PATH\"]:\n        v = os.environ.get(k)\n        if v is not None:\n            env[k] = v\n    # LANGUAGE is used on win32\n    env[\"LANGUAGE\"] = \"C\"\n    env[\"LANG\"] = \"C\"\n    env[\"LC_ALL\"] = \"C\"\n    with subprocess.Popen(\n        cmd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        env=env,\n        cwd=os.path.join(os.path.dirname(ROOT_DIR)),\n    ) as proc:\n        stdout, stderr = proc.communicate()\n        if proc.returncode > 0:\n            error_message = stderr.strip().decode(\"ascii\")\n            raise OSError(f\"Command {cmd} exited with code {proc.returncode}: {error_message}\")\n    return stdout\n\n\ndef git_version():\n    \"\"\"Get the current git head sha1.\"\"\"\n    # Determine if we're at main\n    try:\n        out = _minimal_ext_cmd([\"git\", \"rev-parse\", \"HEAD\"])\n        git_revision = out.strip().decode(\"ascii\")\n    except OSError:\n        git_revision = \"Unknown\"\n\n    return git_revision\n\n\nwith open(os.path.join(ROOT_DIR, \"VERSION.txt\")) as version_file:\n    VERSION = version_file.read().strip()\n\n\ndef get_version_info():\n    \"\"\"Get the full version string.\"\"\"\n    # Adding the git rev number needs to be done inside\n    # write_version_py(), otherwise the import of scipy.version messes\n    # up the build under Python 3.\n    full_version = VERSION\n\n    if not os.path.exists(os.path.join(os.path.dirname(ROOT_DIR), \".git\")):\n        return full_version\n    try:\n        release = _minimal_ext_cmd([\"git\", \"tag\", \"-l\", \"--points-at\", \"HEAD\"])\n    except Exception:  # pylint: disable=broad-except\n        return full_version\n    git_revision = git_version()\n    if not release:\n        full_version += \".dev0+\" + git_revision[:7]\n\n    return full_version\n\n\n__version__ = get_version_info()\n",
    "line_count": 85
  },
  {
    "filename": "_add_control.py",
    "path": "qiskit/circuit/_add_control.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Add control to operation if supported.\"\"\"\nfrom __future__ import annotations\n\nfrom math import pi\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.transpiler import PassManager\nfrom qiskit.transpiler.passes.basis import BasisTranslator, UnrollCustomDefinitions\nfrom qiskit.circuit.equivalence_library import SessionEquivalenceLibrary as sel\n\nfrom . import ControlledGate, Gate, QuantumRegister, QuantumCircuit\nfrom ._utils import _ctrl_state_to_int\n\n\n# The list of gates whose controlled versions have efficient synthesis algorithms.\n# For example, a controlled version of X is MCX (with many synthesis algorithms avalable),\n# and a controlled version of Z is MCX + two Hadamard gates.\n#\n# Note: when adding a new gate to this list, also add the decomposition of its controlled\n# version to apply_basic_controlled_gate.\nEFFICIENTLY_CONTROLLED_GATES = [\n    \"p\",\n    \"u\",\n    \"x\",\n    \"z\",\n    \"y\",\n    \"h\",\n    \"sx\",\n    \"sxdg\",\n    \"rx\",\n    \"ry\",\n    \"rz\",\n    \"cx\",\n    \"cz\",\n]\n\n\ndef add_control(\n    operation: Gate | ControlledGate,\n    num_ctrl_qubits: int,\n    label: str | None,\n    ctrl_state: str | int | None,\n) -> ControlledGate:\n    \"\"\"Return the controlled version of the gate.\n\n    This function first checks whether the gate's name corresponds to a known\n    method for generating its controlled version. Currently, these methods exist\n    for gates in ``EFFICIENTLY_CONTROLLED_GATES``.\n\n    For gates not in ``EFFICIENTLY_CONTROLLED_GATES``, the function calls the unroller\n    to decompose the gate into gates in ``EFFICIENTLY_CONTROLLED_GATES``,\n    and then generates the controlled version by controlling every gate in this\n    decomposition.\n\n    Open controls are implemented by conjugating the control line with X gates.\n\n    This function is meant to be called from the\n    :method:`qiskit.circuit.gate.Gate.control()` method.\n\n    Args:\n        operation: The operation to be controlled.\n        num_ctrl_qubits: The number of controls to add to gate.\n        label: An optional gate label.\n        ctrl_state: The control state in decimal or as a bitstring\n            (e.g. '111'). If specified as a bitstring the length\n            must equal num_ctrl_qubits, MSB on left. If None, use\n            2**num_ctrl_qubits-1.\n\n    Returns:\n        Controlled version of gate.\n\n    \"\"\"\n    if isinstance(operation, UnitaryGate):\n        # attempt decomposition\n        operation._define()\n    cgate = control(operation, num_ctrl_qubits=num_ctrl_qubits, label=label, ctrl_state=ctrl_state)\n    if operation.label is not None:\n        cgate.base_gate = cgate.base_gate.to_mutable()\n        cgate.base_gate.label = operation.label\n    return cgate\n\n\ndef control(\n    operation: Gate | ControlledGate,\n    num_ctrl_qubits: int | None = 1,\n    label: str | None = None,\n    ctrl_state: str | int | None = None,\n) -> ControlledGate:\n    \"\"\"Return the controlled version of the gate.\n\n    This function first checks whether the gate's name corresponds to a known\n    method for generating its controlled version. Currently, these methods exist\n    for gates in ``EFFICIENTLY_CONTROLLED_GATES``.\n\n    For gates not in ``EFFICIENTLY_CONTROLLED_GATES``, the function calls the unroller\n    to decompose the gate into gates in ``EFFICIENTLY_CONTROLLED_GATES``,\n    and then generates the controlled version by controlling every gate in this\n    decomposition.\n\n    Open controls are implemented by conjugating the control line with X gates.\n\n    Args:\n        operation: The gate used to create the ControlledGate.\n        num_ctrl_qubits: The number of controls to add to gate (default=1).\n        label: An optional gate label.\n        ctrl_state: The control state in decimal or as\n            a bitstring (e.g. '111'). If specified as a bitstring the length\n            must equal num_ctrl_qubits, MSB on left. If None, use\n            2**num_ctrl_qubits-1.\n\n    Returns:\n        Controlled version of gate.\n\n    Raises:\n        CircuitError: gate contains non-gate in definition\n    \"\"\"\n\n    # pylint: disable=cyclic-import\n    from qiskit.circuit import controlledgate\n\n    ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n\n    q_control = QuantumRegister(num_ctrl_qubits, name=\"control\")\n    q_target = QuantumRegister(operation.num_qubits, name=\"target\")\n    controlled_circ = QuantumCircuit(q_control, q_target, name=f\"c_{operation.name}\")\n    if isinstance(operation, controlledgate.ControlledGate):\n        original_ctrl_state = operation.ctrl_state\n        operation = operation.to_mutable()\n        operation.ctrl_state = None\n\n    global_phase = 0\n\n    if operation.name in EFFICIENTLY_CONTROLLED_GATES:\n        apply_basic_controlled_gate(controlled_circ, operation, q_control, q_target)\n    else:\n        if isinstance(operation, controlledgate.ControlledGate):\n            operation = operation.to_mutable()\n            operation.ctrl_state = None\n\n        unrolled_gate = _unroll_gate(operation, basis_gates=EFFICIENTLY_CONTROLLED_GATES)\n        if unrolled_gate.definition.global_phase:\n            global_phase += unrolled_gate.definition.global_phase\n\n        definition = unrolled_gate.definition\n        bit_indices = {\n            bit: index\n            for bits in [definition.qubits, definition.clbits]\n            for index, bit in enumerate(bits)\n        }\n\n        for instruction in definition.data:\n            gate, qargs = instruction.operation, instruction.qubits\n\n            if len(qargs) == 1:\n                target = q_target[bit_indices[qargs[0]]]\n            else:\n                target = [q_target[bit_indices[qarg]] for qarg in qargs]\n\n            apply_basic_controlled_gate(controlled_circ, gate, q_control, target)\n\n            if gate.definition is not None and gate.definition.global_phase and gate.name != \"rz\":\n                global_phase += gate.definition.global_phase\n\n    # apply controlled global phase\n    if global_phase:\n        if len(q_control) < 2:\n            controlled_circ.p(global_phase, q_control)\n        else:\n            controlled_circ.mcp(global_phase, q_control[:-1], q_control[-1])\n    if isinstance(operation, controlledgate.ControlledGate):\n        operation.ctrl_state = original_ctrl_state\n        new_num_ctrl_qubits = num_ctrl_qubits + operation.num_ctrl_qubits\n        new_ctrl_state = operation.ctrl_state << num_ctrl_qubits | ctrl_state\n        base_name = operation.base_gate.name\n        base_gate = operation.base_gate\n    else:\n        new_num_ctrl_qubits = num_ctrl_qubits\n        new_ctrl_state = ctrl_state\n        base_name = operation.name\n        base_gate = operation\n\n    # In order to maintain some backward compatibility with gate names this\n    # uses a naming convention where if the number of controls is <=2 the gate\n    # is named like \"cc<base_gate.name>\", else it is named like\n    # \"c<num_ctrl_qubits><base_name>\".\n    if new_num_ctrl_qubits > 2:\n        ctrl_substr = f\"c{new_num_ctrl_qubits:d}\"\n    else:\n        ctrl_substr = (\"{0}\" * new_num_ctrl_qubits).format(\"c\")\n    new_name = f\"{ctrl_substr}{base_name}\"\n    cgate = controlledgate.ControlledGate(\n        new_name,\n        controlled_circ.num_qubits,\n        operation.params,\n        label=label,\n        num_ctrl_qubits=new_num_ctrl_qubits,\n        definition=controlled_circ,\n        ctrl_state=new_ctrl_state,\n        base_gate=base_gate,\n    )\n    return cgate\n\n\ndef apply_basic_controlled_gate(circuit, gate, controls, target):\n    \"\"\"Apply a controlled version of ``gate`` to the circuit.\n\n    This implements multi-control operations for every gate in\n    ``EFFICIENTLY_CONTROLLED_GATES``.\n\n    \"\"\"\n    num_ctrl_qubits = len(controls)\n\n    if gate.name == \"x\":\n        circuit.mcx(controls, target)\n    elif gate.name == \"rx\":\n        circuit.mcrx(\n            gate.definition.data[0].operation.params[0],\n            controls,\n            target,\n            use_basis_gates=False,\n        )\n    elif gate.name == \"ry\":\n        circuit.mcry(\n            gate.definition.data[0].operation.params[0],\n            controls,\n            target,\n            mode=\"noancilla\",\n            use_basis_gates=False,\n        )\n    elif gate.name == \"rz\":\n        circuit.mcrz(\n            gate.definition.data[0].operation.params[0],\n            controls,\n            target,\n            use_basis_gates=False,\n        )\n    elif gate.name == \"p\":\n        from qiskit.circuit.library import MCPhaseGate\n\n        circuit.append(\n            MCPhaseGate(gate.params[0], num_ctrl_qubits),\n            controls[:] + [target],\n        )\n    elif gate.name == \"cx\":\n        circuit.mcx(\n            controls[:] + [target[0]],  # CX has two targets\n            target[1],\n        )\n    elif gate.name == \"cz\":\n        circuit.h(target[1])\n        circuit.mcx(\n            controls[:] + [target[0]],  # CZ has two targets\n            target[1],\n        )\n        circuit.h(target[1])\n    elif gate.name == \"u\":\n        theta, phi, lamb = gate.params\n        if num_ctrl_qubits == 1:\n            if theta == 0 and phi == 0:\n                circuit.cp(lamb, controls[0], target)\n            else:\n                circuit.cu(theta, phi, lamb, 0, controls[0], target)\n        else:\n            if phi == -pi / 2 and lamb == pi / 2:\n                circuit.mcrx(theta, controls, target, use_basis_gates=False)\n            elif phi == 0 and lamb == 0:\n                circuit.mcry(\n                    theta,\n                    controls,\n                    target,\n                    use_basis_gates=False,\n                )\n            elif theta == 0 and phi == 0:\n                circuit.mcp(lamb, controls, target)\n            else:\n                circuit.mcrz(lamb, controls, target, use_basis_gates=False)\n                circuit.mcry(theta, controls, target, use_basis_gates=False)\n                circuit.mcrz(phi, controls, target, use_basis_gates=False)\n                circuit.mcp((phi + lamb) / 2, controls[1:], controls[0])\n    elif gate.name == \"z\":\n        circuit.h(target)\n        circuit.mcx(controls, target)\n        circuit.h(target)\n    elif gate.name == \"y\":\n        circuit.sdg(target)\n        circuit.mcx(controls, target)\n        circuit.s(target)\n    elif gate.name == \"h\":\n        circuit.s(target)\n        circuit.h(target)\n        circuit.t(target)\n        circuit.mcx(controls, target)\n        circuit.tdg(target)\n        circuit.h(target)\n        circuit.sdg(target)\n    elif gate.name == \"sx\":\n        circuit.h(target)\n        circuit.mcp(pi / 2, controls, target)\n        circuit.h(target)\n    elif gate.name == \"sxdg\":\n        circuit.h(target)\n        circuit.mcp(3 * pi / 2, controls, target)\n        circuit.h(target)\n    else:\n        raise CircuitError(f\"Gate {gate} not in supported basis.\")\n\n\ndef _gate_to_circuit(operation):\n    \"\"\"Converts a gate instance to a QuantumCircuit\"\"\"\n    if hasattr(operation, \"definition\") and operation.definition is not None:\n        return operation.definition\n\n    qr = QuantumRegister(operation.num_qubits)\n    qc = QuantumCircuit(qr, name=operation.name)\n    qc.append(operation, qr)\n    return qc\n\n\ndef _unroll_gate(operation, basis_gates):\n    \"\"\"Unrolls a gate, possibly composite, to the target basis\"\"\"\n    circ = _gate_to_circuit(operation)\n    pm = PassManager(\n        [\n            UnrollCustomDefinitions(sel, basis_gates=basis_gates),\n            BasisTranslator(sel, target_basis=basis_gates),\n        ]\n    )\n    opqc = pm.run(circ)\n    return opqc.to_gate()\n",
    "line_count": 342
  },
  {
    "filename": "_classical_resource_map.py",
    "path": "qiskit/circuit/_classical_resource_map.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Shared helper utility for mapping classical resources from one circuit or DAG to another.\"\"\"\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom . import Bit, Clbit, ClassicalRegister  # pylint: disable=cyclic-import\nfrom .classical import expr\n\n\nclass VariableMapper(expr.ExprVisitor[expr.Expr]):\n    \"\"\"Stateful helper class that manages the mapping of variables in conditions and expressions.\n\n    This is designed to be used by both :class:`.QuantumCircuit` and :class:`.DAGCircuit` when\n    managing operations that need to map classical resources from one circuit to another.\n\n    The general usage is to initialise this at the start of a many-block mapping operation, then\n    call its :meth:`map_condition`, :meth:`map_target` or :meth:`map_expr` methods as appropriate,\n    which will return the new object that should be used.\n\n    If an ``add_register`` callable is given to the initializer, the mapper will use it to attempt\n    to add new aliasing registers to the outer circuit object, if there is not already a suitable\n    register for the mapping available in the circuit.  If this parameter is not given, a\n    ``ValueError`` will be raised instead.  The given ``add_register`` callable may choose to raise\n    its own exception.\"\"\"\n\n    # We don't want docstrings for the inherited visitor methods, which are self-explanatory and\n    # would just be noise.\n    # pylint: disable=missing-function-docstring\n\n    __slots__ = (\"target_cregs\", \"register_map\", \"bit_map\", \"var_map\", \"add_register\")\n\n    def __init__(\n        self,\n        target_cregs: typing.Iterable[ClassicalRegister],\n        bit_map: typing.Mapping[Bit, Bit],\n        var_map: typing.Mapping[expr.Var | expr.Stretch, expr.Var | expr.Stretch] | None = None,\n        *,\n        add_register: typing.Callable[[ClassicalRegister], None] | None = None,\n    ):\n        self.target_cregs = tuple(target_cregs)\n        self.register_map = {}\n        self.bit_map = bit_map\n        self.var_map = var_map or {}\n        self.add_register = add_register\n\n    def _map_register(self, theirs: ClassicalRegister) -> ClassicalRegister:\n        \"\"\"Map the target's registers to suitable equivalents in the destination, adding an\n        extra one if there's no exact match.\"\"\"\n        if (mapped_theirs := self.register_map.get(theirs.name)) is not None:\n            return mapped_theirs\n        mapped_bits = [self.bit_map[bit] for bit in theirs]\n        for ours in self.target_cregs:\n            if mapped_bits == list(ours):\n                mapped_theirs = ours\n                break\n        else:\n            if self.add_register is None:\n                raise ValueError(f\"Register '{theirs.name}' has no counterpart in the destination.\")\n            mapped_theirs = ClassicalRegister(bits=mapped_bits)\n            self.add_register(mapped_theirs)\n        self.register_map[theirs.name] = mapped_theirs\n        return mapped_theirs\n\n    def map_condition(self, condition, /, *, allow_reorder=False):\n        \"\"\"Map the given ``condition`` so that it only references variables in the destination\n        circuit (as given to this class on initialization).\n\n        If ``allow_reorder`` is ``True``, then when a legacy condition (the two-tuple form) is made\n        on a register that has a counterpart in the destination with all the same (mapped) bits but\n        in a different order, then that register will be used and the value suitably modified to\n        make the equality condition work.  This is maintaining legacy (tested) behavior of\n        :meth:`.DAGCircuit.compose`; nowhere else does this, and in general this would require *far*\n        more complex classical rewriting than Terra needs to worry about in the full expression era.\n        \"\"\"\n        if condition is None:\n            return None\n        if isinstance(condition, expr.Expr):\n            return self.map_expr(condition)\n        target, value = condition\n        if isinstance(target, Clbit):\n            return (self.bit_map[target], value)\n        if not allow_reorder:\n            return (self._map_register(target), value)\n        # This is maintaining the legacy behavior of `DAGCircuit.compose`.  We don't attempt to\n        # speed-up this lookup with a cache, since that would just make the more standard cases more\n        # annoying to deal with.\n        mapped_bits_order = [self.bit_map[bit] for bit in target]\n        mapped_bits_set = set(mapped_bits_order)\n        for register in self.target_cregs:\n            if mapped_bits_set == set(register):\n                mapped_theirs = register\n                break\n        else:\n            if self.add_register is None:\n                raise self.exc_type(\n                    f\"Register '{target.name}' has no counterpart in the destination.\"\n                )\n            mapped_theirs = ClassicalRegister(bits=mapped_bits_order)\n            self.add_register(mapped_theirs)\n        new_order = {bit: i for i, bit in enumerate(mapped_bits_order)}\n        value_bits = f\"{value:0{len(target)}b}\"[::-1]  # Little-index-indexed binary bitstring.\n        mapped_value = int(\"\".join(value_bits[new_order[bit]] for bit in mapped_theirs)[::-1], 2)\n        return (mapped_theirs, mapped_value)\n\n    def map_target(self, target, /):\n        \"\"\"Map the real-time variables in a ``target`` of a :class:`.SwitchCaseOp` to the new\n        circuit, as defined in the ``circuit`` argument of the initializer of this class.\"\"\"\n        if isinstance(target, Clbit):\n            return self.bit_map[target]\n        if isinstance(target, ClassicalRegister):\n            return self._map_register(target)\n        return self.map_expr(target)\n\n    def map_expr(self, node: expr.Expr, /) -> expr.Expr:\n        \"\"\"Map the variables in an :class:`~.expr.Expr` node to the new circuit.\"\"\"\n        return node.accept(self)\n\n    def visit_var(self, node, /):\n        if isinstance(node.var, Clbit):\n            return expr.Var(self.bit_map[node.var], node.type)\n        if isinstance(node.var, ClassicalRegister):\n            return expr.Var(self._map_register(node.var), node.type)\n        return self.var_map.get(node, node)\n\n    def visit_stretch(self, node, /):\n        return self.var_map.get(node, node)\n\n    def visit_value(self, node, /):\n        return expr.Value(node.value, node.type)\n\n    def visit_unary(self, node, /):\n        return expr.Unary(node.op, node.operand.accept(self), node.type)\n\n    def visit_binary(self, node, /):\n        return expr.Binary(node.op, node.left.accept(self), node.right.accept(self), node.type)\n\n    def visit_cast(self, node, /):\n        return expr.Cast(node.operand.accept(self), node.type, implicit=node.implicit)\n\n    def visit_index(self, node, /):\n        return expr.Index(node.target.accept(self), node.index.accept(self), node.type)\n",
    "line_count": 155
  },
  {
    "filename": "_utils.py",
    "path": "qiskit/circuit/_utils.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\"\"\"\nThis module contains utility functions for circuits.\n\"\"\"\n\nimport math\nimport numpy\n\nfrom qiskit import _numpy_compat\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.circuit.exceptions import CircuitError\n\n\ndef _compute_control_matrix(base_mat, num_ctrl_qubits, ctrl_state=None):\n    r\"\"\"\n    Compute the controlled version of the input matrix with qiskit ordering.\n    This function computes the controlled unitary with :math:`n` control qubits\n    and :math:`m` target qubits,\n\n    .. math::\n\n        V_n^j(U_{2^m}) = (U_{2^m} \\otimes |j\\rangle\\!\\langle j|) +\n                         (I_{2^m} \\otimes (I_{2^n} - |j\\rangle\\!\\langle j|)).\n\n    where :math:`|j\\rangle \\in \\mathcal{H}^{2^n}` is the control state.\n\n    Args:\n        base_mat (ndarray): unitary to be controlled\n        num_ctrl_qubits (int): number of controls for new unitary\n        ctrl_state (int or str or None): The control state in decimal or as\n            a bitstring (e.g. '111'). If None, use 2**num_ctrl_qubits-1.\n\n    Returns:\n        ndarray: controlled version of base matrix.\n\n    Raises:\n        QiskitError: unrecognized mode or invalid ctrl_state\n    \"\"\"\n    num_target = int(math.log2(base_mat.shape[0]))\n    ctrl_dim = 2**num_ctrl_qubits\n    ctrl_grnd = numpy.repeat([[1], [0]], [1, ctrl_dim - 1])\n    if ctrl_state is None:\n        ctrl_state = ctrl_dim - 1\n    elif isinstance(ctrl_state, str):\n        ctrl_state = int(ctrl_state, 2)\n    if isinstance(ctrl_state, int):\n        if not 0 <= ctrl_state < ctrl_dim:\n            raise QiskitError(\"Invalid control state value specified.\")\n    else:\n        raise QiskitError(\"Invalid control state type specified.\")\n    ctrl_proj = numpy.diag(numpy.roll(ctrl_grnd, ctrl_state))\n    full_mat = numpy.kron(numpy.eye(2**num_target), numpy.eye(ctrl_dim) - ctrl_proj) + numpy.kron(\n        base_mat, ctrl_proj\n    )\n    return full_mat\n\n\ndef _ctrl_state_to_int(ctrl_state, num_ctrl_qubits):\n    \"\"\"Convert ctrl_state to int.\n\n    Args:\n        ctrl_state (None, str, int): ctrl_state. If None, set to 2**num_ctrl_qubits-1.\n            If str, convert to int. If int, pass.\n        num_ctrl_qubits (int): The number of control qubits.\n\n    Return:\n        int: ctrl_state\n\n    Raises:\n        CircuitError: invalid ctrl_state\n    \"\"\"\n    ctrl_state_std = None\n    if isinstance(ctrl_state, str):\n        try:\n            assert len(ctrl_state) == num_ctrl_qubits\n            ctrl_state = int(ctrl_state, 2)\n        except ValueError as ex:\n            raise CircuitError(\"invalid control bit string: \" + ctrl_state) from ex\n        except AssertionError as ex:\n            raise CircuitError(\"invalid control bit string: length != num_ctrl_qubits\") from ex\n    if isinstance(ctrl_state, int):\n        if 0 <= ctrl_state < 2**num_ctrl_qubits:\n            ctrl_state_std = ctrl_state\n        else:\n            raise CircuitError(\"invalid control state specification\")\n    elif ctrl_state is None:\n        ctrl_state_std = 2**num_ctrl_qubits - 1\n    else:\n        raise CircuitError(f\"invalid control state specification: {repr(ctrl_state)}\")\n    return ctrl_state_std\n\n\ndef with_gate_array(base_array):\n    \"\"\"Class decorator that adds an ``__array__`` method to a :class:`.Gate` instance that returns a\n    singleton nonwritable view onto the complex matrix described by ``base_array``.\"\"\"\n    nonwritable = numpy.array(base_array, dtype=numpy.complex128)\n    nonwritable.setflags(write=False)\n\n    def __array__(_self, dtype=None, copy=_numpy_compat.COPY_ONLY_IF_NEEDED):\n        dtype = nonwritable.dtype if dtype is None else dtype\n        return numpy.array(nonwritable, dtype=dtype, copy=copy)\n\n    def decorator(cls):\n        if hasattr(cls, \"__array__\"):\n            raise RuntimeError(\"Refusing to decorate a class that already has '__array__' defined.\")\n        cls.__array__ = __array__\n        return cls\n\n    return decorator\n\n\ndef with_controlled_gate_array(base_array, num_ctrl_qubits, cached_states=None):\n    \"\"\"Class decorator that adds an ``__array__`` method to a :class:`.ControlledGate` instance that\n    returns singleton nonwritable views onto a relevant precomputed complex matrix for the given\n    control state.\n\n    If ``cached_states`` is not given, then all possible control states are precomputed.  If it is\n    given, it should be an iterable of integers, and only these control states will be cached.\"\"\"\n    base = numpy.asarray(base_array, dtype=numpy.complex128)\n\n    def matrix_for_control_state(state):\n        out = numpy.asarray(\n            _compute_control_matrix(base, num_ctrl_qubits, state),\n            dtype=numpy.complex128,\n        )\n        out.setflags(write=False)\n        return out\n\n    if cached_states is None:\n        nonwritables = [matrix_for_control_state(state) for state in range(2**num_ctrl_qubits)]\n\n        def __array__(self, dtype=None, copy=_numpy_compat.COPY_ONLY_IF_NEEDED):\n            arr = nonwritables[self.ctrl_state]\n            dtype = arr.dtype if dtype is None else dtype\n            return numpy.array(arr, dtype=dtype, copy=copy)\n\n    else:\n        nonwritables = {state: matrix_for_control_state(state) for state in cached_states}\n\n        def __array__(self, dtype=None, copy=_numpy_compat.COPY_ONLY_IF_NEEDED):\n            if (arr := nonwritables.get(self.ctrl_state)) is not None:\n                dtype = arr.dtype if dtype is None else dtype\n                return numpy.array(arr, dtype=dtype, copy=copy)\n\n            if copy is False and copy is not _numpy_compat.COPY_ONLY_IF_NEEDED:\n                raise ValueError(\"could not produce matrix without calculation\")\n            return numpy.asarray(\n                _compute_control_matrix(base, num_ctrl_qubits, self.ctrl_state), dtype=dtype\n            )\n\n    def decorator(cls):\n        if hasattr(cls, \"__array__\"):\n            raise RuntimeError(\"Refusing to decorate a class that already has '__array__' defined.\")\n        cls.__array__ = __array__\n        return cls\n\n    return decorator\n",
    "line_count": 168
  },
  {
    "filename": "annotated_operation.py",
    "path": "qiskit/circuit/annotated_operation.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Annotated Operations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Union, List\n\nfrom qiskit.circuit.operation import Operation\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.circuit._utils import _compute_control_matrix, _ctrl_state_to_int\nfrom qiskit.circuit.exceptions import CircuitError\n\n\nclass Modifier:\n    \"\"\"The base class that all modifiers of :class:`~.AnnotatedOperation` should\n    inherit from.\"\"\"\n\n    pass\n\n\n@dataclasses.dataclass\nclass InverseModifier(Modifier):\n    \"\"\"Inverse modifier: specifies that the operation is inverted.\"\"\"\n\n    pass\n\n\n@dataclasses.dataclass\nclass ControlModifier(Modifier):\n    \"\"\"Control modifier: specifies that the operation is controlled by ``num_ctrl_qubits``\n    and has control state ``ctrl_state``.\"\"\"\n\n    num_ctrl_qubits: int = 0\n    ctrl_state: Union[int, str, None] = None\n\n    def __init__(self, num_ctrl_qubits: int = 0, ctrl_state: Union[int, str, None] = None):\n        self.num_ctrl_qubits = num_ctrl_qubits\n        self.ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n\n\n@dataclasses.dataclass\nclass PowerModifier(Modifier):\n    \"\"\"Power modifier: specifies that the operation is raised to the power ``power``.\"\"\"\n\n    power: float\n\n\nclass AnnotatedOperation(Operation):\n    \"\"\"Annotated operation.\"\"\"\n\n    def __init__(self, base_op: Operation, modifiers: Union[Modifier, List[Modifier]]):\n        \"\"\"\n        Create a new AnnotatedOperation.\n\n        An \"annotated operation\" allows to add a list of modifiers to the\n        \"base\" operation. For now, the only supported modifiers are of\n        types :class:`~.InverseModifier`, :class:`~.ControlModifier` and\n        :class:`~.PowerModifier`.\n\n        An annotated operation can be viewed as an extension of\n        :class:`~.ControlledGate` (which also allows adding control to the\n        base operation). However, an important difference is that the\n        circuit definition of an annotated operation is not constructed when\n        the operation is declared, and instead happens during transpilation,\n        specifically during the :class:`~.HighLevelSynthesis` transpiler pass.\n\n        An annotated operation can be also viewed as a \"higher-level\"\n        or \"more abstract\" object that can be added to a quantum circuit.\n        This enables writing transpiler optimization passes that make use of\n        this higher-level representation, for instance removing a gate\n        that is immediately followed by its inverse.\n\n        Args:\n            base_op: base operation being modified\n            modifiers: ordered list of modifiers. Supported modifiers include\n                ``InverseModifier``, ``ControlModifier`` and ``PowerModifier``.\n\n        Examples::\n\n            op1 = AnnotatedOperation(SGate(), [InverseModifier(), ControlModifier(2)])\n\n            op2_inner = AnnotatedGate(SGate(), InverseModifier())\n            op2 = AnnotatedGate(op2_inner, ControlModifier(2))\n\n        Both op1 and op2 are semantically equivalent to an ``SGate()`` which is first\n        inverted and then controlled by 2 qubits.\n        \"\"\"\n        self.base_op = base_op\n        \"\"\"The base operation that the modifiers in this annotated operation applies to.\"\"\"\n        self.modifiers = modifiers if isinstance(modifiers, List) else [modifiers]\n        \"\"\"Ordered sequence of the modifiers to apply to :attr:`base_op`.  The modifiers are applied\n        in order from lowest index to highest index.\"\"\"\n\n    @property\n    def name(self):\n        \"\"\"Unique string identifier for operation type.\"\"\"\n        return \"annotated\"\n\n    @property\n    def num_qubits(self):\n        \"\"\"Number of qubits.\"\"\"\n        num_ctrl_qubits = 0\n        for modifier in self.modifiers:\n            if isinstance(modifier, ControlModifier):\n                num_ctrl_qubits += modifier.num_ctrl_qubits\n\n        return num_ctrl_qubits + self.base_op.num_qubits\n\n    @property\n    def num_clbits(self):\n        \"\"\"Number of classical bits.\"\"\"\n        return self.base_op.num_clbits\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Checks if two AnnotatedOperations are equal.\"\"\"\n        return (\n            isinstance(other, AnnotatedOperation)\n            and self.modifiers == other.modifiers\n            and self.base_op == other.base_op\n        )\n\n    def copy(self) -> \"AnnotatedOperation\":\n        \"\"\"Return a copy of the :class:`~.AnnotatedOperation`.\"\"\"\n        return AnnotatedOperation(base_op=self.base_op.copy(), modifiers=self.modifiers.copy())\n\n    def to_matrix(self):\n        \"\"\"Return a matrix representation (allowing to construct Operator).\"\"\"\n        from qiskit.quantum_info.operators import Operator  # pylint: disable=cyclic-import\n\n        operator = Operator(self.base_op)\n\n        for modifier in self.modifiers:\n            if isinstance(modifier, InverseModifier):\n                operator = operator.power(-1)\n            elif isinstance(modifier, ControlModifier):\n                operator = Operator(\n                    _compute_control_matrix(\n                        operator.data, modifier.num_ctrl_qubits, modifier.ctrl_state\n                    )\n                )\n            elif isinstance(modifier, PowerModifier):\n                operator = operator.power(modifier.power)\n            else:\n                raise CircuitError(f\"Unknown modifier {modifier}.\")\n        return operator\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: str | None = None,\n        ctrl_state: int | str | None = None,\n        annotated: bool = True,\n    ) -> AnnotatedOperation:\n        \"\"\"\n        Return the controlled version of itself.\n\n        Implemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\n        Args:\n            num_ctrl_qubits: number of controls to add to gate (default: ``1``)\n            label: ignored (used for consistency with other control methods)\n            ctrl_state: The control state in decimal or as a bitstring\n                (e.g. ``'111'``). If ``None``, use ``2**num_ctrl_qubits-1``.\n            annotated: ignored (used for consistency with other control methods)\n\n        Returns:\n            Controlled version of the given operation.\n        \"\"\"\n        # pylint: disable=unused-argument\n        extended_modifiers = self.modifiers.copy()\n        extended_modifiers.append(\n            ControlModifier(num_ctrl_qubits=num_ctrl_qubits, ctrl_state=ctrl_state)\n        )\n        return AnnotatedOperation(self.base_op, extended_modifiers)\n\n    def inverse(self, annotated: bool = True):\n        \"\"\"\n        Return the inverse version of itself.\n\n        Implemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\n        Args:\n            annotated: ignored (used for consistency with other inverse methods)\n\n        Returns:\n            Inverse version of the given operation.\n        \"\"\"\n        # pylint: disable=unused-argument\n        extended_modifiers = self.modifiers.copy()\n        extended_modifiers.append(InverseModifier())\n        return AnnotatedOperation(self.base_op, extended_modifiers)\n\n    def power(self, exponent: float, annotated: bool = False):\n        \"\"\"\n        Raise this gate to the power of ``exponent``.\n\n        Implemented as an annotated operation, see  :class:`.AnnotatedOperation`.\n\n        Args:\n            exponent: the power to raise the gate to\n            annotated: ignored (used for consistency with other power methods)\n\n        Returns:\n            An operation implementing ``gate^exponent``\n        \"\"\"\n        # pylint: disable=unused-argument\n        extended_modifiers = self.modifiers.copy()\n        extended_modifiers.append(PowerModifier(exponent))\n        return AnnotatedOperation(self.base_op, extended_modifiers)\n\n    @property\n    def params(self) -> list[ParameterValueType]:\n        \"\"\"The params of the underlying base operation.\"\"\"\n        return getattr(self.base_op, \"params\", [])\n\n    @params.setter\n    def params(self, value: list[ParameterValueType]):\n        if hasattr(self.base_op, \"params\"):\n            self.base_op.params = value\n        else:\n            raise AttributeError(\n                f\"Cannot set attribute ``params`` on the base operation {self.base_op}.\"\n            )\n\n    def validate_parameter(self, parameter: ParameterValueType) -> ParameterValueType:\n        \"\"\"Validate a parameter for the underlying base operation.\"\"\"\n        if hasattr(self.base_op, \"validate_parameter\"):\n            return self.base_op.validate_parameter(parameter)\n\n        raise AttributeError(f\"Cannot validate parameters on the base operation {self.base_op}.\")\n\n\ndef _canonicalize_modifiers(modifiers):\n    \"\"\"\n    Returns the canonical representative of the modifier list. This is possible\n    since all the modifiers commute; also note that InverseModifier is a special\n    case of PowerModifier. The current solution is to compute the total number\n    of control qubits / control state and the total power. The InverseModifier\n    will be present if total power is negative, whereas the power modifier will\n    be present only with positive powers different from 1.\n    \"\"\"\n    power = 1\n    num_ctrl_qubits = 0\n    ctrl_state = 0\n\n    for modifier in modifiers:\n        if isinstance(modifier, InverseModifier):\n            power *= -1\n        elif isinstance(modifier, ControlModifier):\n            num_ctrl_qubits += modifier.num_ctrl_qubits\n            ctrl_state = (ctrl_state << modifier.num_ctrl_qubits) | modifier.ctrl_state\n        elif isinstance(modifier, PowerModifier):\n            power *= modifier.power\n        else:\n            raise CircuitError(f\"Unknown modifier {modifier}.\")\n\n    canonical_modifiers = []\n    if power < 0:\n        canonical_modifiers.append(InverseModifier())\n        power *= -1\n\n    if power != 1:\n        canonical_modifiers.append(PowerModifier(power))\n    if num_ctrl_qubits > 0:\n        canonical_modifiers.append(ControlModifier(num_ctrl_qubits, ctrl_state))\n\n    return canonical_modifiers\n",
    "line_count": 280
  },
  {
    "filename": "barrier.py",
    "path": "qiskit/circuit/barrier.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Barrier instruction.\n\nCan be applied to a :class:`~qiskit.circuit.QuantumCircuit`\nwith the :meth:`~qiskit.circuit.QuantumCircuit.barrier` method.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit.instruction import Instruction\nfrom qiskit._accelerate.circuit import StandardInstructionType\n\n\nclass Barrier(Instruction):\n    \"\"\"A directive for circuit compilation to separate pieces of a circuit so that any optimizations\n    or re-writes are constrained to only act between barriers.\n\n    This will also appear in visualizations as a visual marker.\n    \"\"\"\n\n    _directive = True\n    _standard_instruction_type = StandardInstructionType.Barrier\n\n    def __init__(self, num_qubits: int, label: str | None = None):\n        \"\"\"\n        Args:\n            num_qubits: the number of qubits for the barrier.\n            label: the optional label of this barrier.\n        \"\"\"\n        self._label = label\n        super().__init__(\"barrier\", num_qubits, 0, [], label=label)\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Special case. Return self.\"\"\"\n        return Barrier(self.num_qubits)\n",
    "line_count": 47
  },
  {
    "filename": "commutation_checker.py",
    "path": "qiskit/circuit/commutation_checker.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Code from commutative_analysis pass that checks commutation relations between DAG nodes.\"\"\"\n\nfrom __future__ import annotations\nfrom typing import List, Union, Set, Optional\n\nfrom qiskit.circuit.operation import Operation\nfrom qiskit._accelerate.commutation_checker import CommutationChecker as RustChecker\n\n\nclass CommutationChecker:\n    r\"\"\"Check commutations of two operations.\n\n    Two unitaries :math:`A` and :math:`B` on :math:`n` qubits commute if\n\n    .. math::\n\n        \\frac{2^n F_{\\text{process}}(AB, BA) + 1}{2^n + 1} > 1 - \\varepsilon,\n\n    where\n\n    .. math::\n\n        F_{\\text{process}}(U_1, U_2) = \\left|\\frac{\\mathrm{Tr}(U_1 U_2^\\dagger)}{2^n} \\right|^2,\n\n    and we set :math:`\\varepsilon` to :math:`10^{-12}` to account for round-off errors on\n    few-qubit systems. This metric is chosen for consistency with other closeness checks in\n    Qiskit.\n\n    When possible, commutation relations are queried from a lookup table. This is the case\n    for standard gates without parameters (such as :class:`.XGate` or :class:`.HGate`) or\n    gates with free parameters (such as :class:`.RXGate` with a :class:`.ParameterExpression` as\n    angle). Otherwise, a matrix-based check is performed, where two operations are said to\n    commute, if the average gate fidelity of performing the commutation is above a certain threshold\n    (see ``approximation_degree``). The result of this commutation is then added to the\n    cached lookup table.\n    \"\"\"\n\n    def __init__(\n        self,\n        standard_gate_commutations: dict = None,\n        cache_max_entries: int = 10**6,\n        *,\n        gates: Optional[Set[str]] = None,\n    ):\n        self.cc = RustChecker(standard_gate_commutations, cache_max_entries, gates)\n\n    def commute_nodes(\n        self,\n        op1,\n        op2,\n        max_num_qubits: int = 3,\n        approximation_degree: float = 1.0,\n    ) -> bool:\n        \"\"\"Checks if two DAGOpNodes commute.\"\"\"\n        return self.cc.commute_nodes(op1, op2, max_num_qubits, approximation_degree)\n\n    def commute(\n        self,\n        op1: Operation,\n        qargs1: List,\n        cargs1: List,\n        op2: Operation,\n        qargs2: List,\n        cargs2: List,\n        max_num_qubits: int = 3,\n        approximation_degree: float = 1.0,\n    ) -> bool:\n        \"\"\"\n        Checks if two Operations commute. The return value of `True` means that the operations\n        truly commute, and the return value of `False` means that either the operations do not\n        commute or that the commutation check was skipped (for example, when the operations\n        have conditions or have too many qubits).\n\n        Args:\n            op1: first operation.\n            qargs1: first operation's qubits.\n            cargs1: first operation's clbits.\n            op2: second operation.\n            qargs2: second operation's qubits.\n            cargs2: second operation's clbits.\n            max_num_qubits: the maximum number of qubits to consider, the check may be skipped if\n                the number of qubits for either operation exceeds this amount.\n            approximation_degree: If the average gate fidelity in between the two operations\n                is above this number (up to ``1e-12``) they are assumed to commute.\n\n        Returns:\n            bool: whether two operations commute.\n        \"\"\"\n        return self.cc.commute(\n            op1, qargs1, cargs1, op2, qargs2, cargs2, max_num_qubits, approximation_degree\n        )\n\n    def num_cached_entries(self):\n        \"\"\"Returns number of cached entries\"\"\"\n        return self.cc.num_cached_entries()\n\n    def clear_cached_commutations(self):\n        \"\"\"Clears the dictionary holding cached commutations\"\"\"\n        self.cc.clear_cached_commutations()\n\n    def check_commutation_entries(\n        self,\n        first_op: Operation,\n        first_qargs: List,\n        second_op: Operation,\n        second_qargs: List,\n    ) -> Union[bool, None]:\n        \"\"\"Returns stored commutation relation if any\n\n        Args:\n            first_op: first operation.\n            first_qargs: first operation's qubits.\n            second_op: second operation.\n            second_qargs: second operation's qubits.\n\n        Return:\n            bool: True if the gates commute and false if it is not the case.\n        \"\"\"\n        return self.cc.library.check_commutation_entries(\n            first_op, first_qargs, second_op, second_qargs\n        )\n",
    "line_count": 134
  },
  {
    "filename": "commutation_library.py",
    "path": "qiskit/circuit/commutation_library.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Provides a commutation checker that caches the determined commutation results during this session \"\"\"\n\nfrom qiskit.circuit import CommutationChecker\n\nfrom qiskit.circuit._standard_gates_commutations import standard_gates_commutations\n\nStandardGateCommutations = standard_gates_commutations\nSessionCommutationChecker = CommutationChecker(StandardGateCommutations)\n",
    "line_count": 21
  },
  {
    "filename": "controlledgate.py",
    "path": "qiskit/circuit/controlledgate.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Controlled unitary gate.\"\"\"\n\nfrom __future__ import annotations\nimport copy\nfrom typing import Optional, Union\n\nfrom qiskit.circuit.exceptions import CircuitError\n\n# pylint: disable=cyclic-import\nfrom . import QuantumRegister\nfrom .quantumcircuit import QuantumCircuit\nfrom .gate import Gate\nfrom ._utils import _ctrl_state_to_int\n\n\nclass ControlledGate(Gate):\n    \"\"\"Controlled unitary gate.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        num_qubits: int,\n        params: list,\n        label: Optional[str] = None,\n        num_ctrl_qubits: Optional[int] = 1,\n        definition: Optional[\"QuantumCircuit\"] = None,\n        ctrl_state: Optional[Union[int, str]] = None,\n        base_gate: Optional[Gate] = None,\n        *,\n        _base_label=None,\n    ):\n        \"\"\"Create a new ControlledGate. In the new gate the first ``num_ctrl_qubits``\n        of the gate are the controls.\n\n        Args:\n            name: The name of the gate.\n            num_qubits: The number of qubits the gate acts on.\n            params: A list of parameters for the gate.\n            label: An optional label for the gate.\n            num_ctrl_qubits: Number of control qubits.\n            definition: A list of gate rules for implementing this gate. The\n                elements of the list are tuples of (:meth:`~qiskit.circuit.Gate`, [qubit_list],\n                [clbit_list]).\n            ctrl_state: The control state in decimal or as\n                a bitstring (e.g. '111'). If specified as a bitstring the length\n                must equal num_ctrl_qubits, MSB on left. If None, use\n                2**num_ctrl_qubits-1.\n            base_gate: Gate object to be controlled.\n\n        Raises:\n            CircuitError: If ``num_ctrl_qubits`` >= ``num_qubits``.\n            CircuitError: ctrl_state < 0 or ctrl_state > 2**num_ctrl_qubits.\n\n        Examples:\n\n        Create a controlled standard gate and apply it to a circuit.\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit import QuantumCircuit, QuantumRegister\n           from qiskit.circuit.library.standard_gates import HGate\n\n           qr = QuantumRegister(3)\n           qc = QuantumCircuit(qr)\n           c3h_gate = HGate().control(2)\n           qc.append(c3h_gate, qr)\n           qc.draw('mpl')\n\n        Create a controlled custom gate and apply it to a circuit.\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit import QuantumCircuit, QuantumRegister\n           from qiskit.circuit.library.standard_gates import HGate\n\n           qc1 = QuantumCircuit(2)\n           qc1.x(0)\n           qc1.h(1)\n           custom = qc1.to_gate().control(2)\n\n           qc2 = QuantumCircuit(4)\n           qc2.append(custom, [0, 3, 1, 2])\n           qc2.draw('mpl')\n        \"\"\"\n        self.base_gate = None if base_gate is None else base_gate.copy()\n        super().__init__(name, num_qubits, params, label=label)\n        self._num_ctrl_qubits = 1\n        self.num_ctrl_qubits = num_ctrl_qubits\n        self.definition = copy.deepcopy(definition)\n        self._ctrl_state = None\n        self._open_ctrl = None\n        self.ctrl_state = ctrl_state\n        self._name = name\n\n    @property\n    def definition(self) -> QuantumCircuit:\n        \"\"\"Return definition in terms of other basic gates. If the gate has\n        open controls, as determined from :attr:`ctrl_state`, the returned\n        definition is conjugated with X without changing the internal\n        ``_definition``.\n        \"\"\"\n        if self._open_ctrl:\n            closed_gate = self.to_mutable()\n            closed_gate.ctrl_state = None\n            bit_ctrl_state = bin(self.ctrl_state)[2:].zfill(self.num_ctrl_qubits)\n            qreg = QuantumRegister(self.num_qubits, \"q\")\n            qc_open_ctrl = QuantumCircuit(qreg)\n            for qind, val in enumerate(bit_ctrl_state[::-1]):\n                if val == \"0\":\n                    qc_open_ctrl.x(qind)\n            qc_open_ctrl.append(closed_gate, qargs=qreg[:])\n            for qind, val in enumerate(bit_ctrl_state[::-1]):\n                if val == \"0\":\n                    qc_open_ctrl.x(qind)\n            return qc_open_ctrl\n        else:\n            return super().definition\n\n    @definition.setter\n    def definition(self, excited_def: \"QuantumCircuit\"):\n        \"\"\"Set controlled gate definition with closed controls.\n\n        Args:\n            excited_def: The circuit with all closed controls.\n        \"\"\"\n        self._definition = excited_def\n\n    @property\n    def name(self) -> str:\n        \"\"\"Get name of gate. If the gate has open controls the gate name\n        will become:\n\n           <original_name_o<ctrl_state>\n\n        where <original_name> is the gate name for the default case of\n        closed control qubits and <ctrl_state> is the integer value of\n        the control state for the gate.\n        \"\"\"\n        if self._open_ctrl:\n            return f\"{self._name}_o{self.ctrl_state}\"\n        else:\n            return self._name\n\n    @name.setter\n    def name(self, name_str):\n        \"\"\"Set the name of the gate. Note the reported name may differ\n        from the set name if the gate has open controls.\n        \"\"\"\n        self._name = name_str\n\n    @property\n    def num_ctrl_qubits(self):\n        \"\"\"Get number of control qubits.\n\n        Returns:\n            int: The number of control qubits for the gate.\n        \"\"\"\n        return self._num_ctrl_qubits\n\n    @num_ctrl_qubits.setter\n    def num_ctrl_qubits(self, num_ctrl_qubits):\n        \"\"\"Set the number of control qubits.\n\n        Args:\n            num_ctrl_qubits (int): The number of control qubits.\n\n        Raises:\n            CircuitError: ``num_ctrl_qubits`` is not an integer in ``[1, num_qubits]``.\n        \"\"\"\n        if num_ctrl_qubits != int(num_ctrl_qubits):\n            raise CircuitError(\"The number of control qubits must be an integer.\")\n        num_ctrl_qubits = int(num_ctrl_qubits)\n        # This is a range rather than an equality limit because some controlled gates represent a\n        # controlled version of the base gate whose definition also uses auxiliary qubits.\n        upper_limit = self.num_qubits - getattr(self.base_gate, \"num_qubits\", 0)\n        if num_ctrl_qubits < 1 or num_ctrl_qubits > upper_limit:\n            limit = \"num_qubits\" if self.base_gate is None else \"num_qubits - base_gate.num_qubits\"\n            raise CircuitError(f\"The number of control qubits must be in `[1, {limit}]`.\")\n        self._num_ctrl_qubits = num_ctrl_qubits\n\n    @property\n    def ctrl_state(self) -> int:\n        \"\"\"Return the control state of the gate as a decimal integer.\"\"\"\n        return self._ctrl_state\n\n    @ctrl_state.setter\n    def ctrl_state(self, ctrl_state: Union[int, str, None]):\n        \"\"\"Set the control state of this gate.\n\n        Args:\n            ctrl_state: The control state of the gate.\n\n        Raises:\n            CircuitError: ctrl_state is invalid.\n        \"\"\"\n        self._ctrl_state = _ctrl_state_to_int(ctrl_state, self.num_ctrl_qubits)\n        self._open_ctrl = self.ctrl_state < 2**self.num_ctrl_qubits - 1\n\n    @property\n    def params(self):\n        \"\"\"Get parameters from base_gate.\n\n        Returns:\n            list: List of gate parameters.\n\n        Raises:\n            CircuitError: Controlled gate does not define a base gate\n        \"\"\"\n        if self.base_gate:\n            return self.base_gate.params\n        else:\n            raise CircuitError(\"Controlled gate does not define base gate for extracting params\")\n\n    @params.setter\n    def params(self, parameters):\n        \"\"\"Set base gate parameters.\n\n        Args:\n            parameters (list): The list of parameters to set.\n\n        Raises:\n            CircuitError: If controlled gate does not define a base gate.\n        \"\"\"\n        if self.base_gate:\n            if self.base_gate.mutable:\n                self.base_gate.params = parameters\n            elif parameters:\n                raise CircuitError(\"cannot set parameters on immutable base gate\")\n        else:\n            raise CircuitError(\"Controlled gate does not define base gate for extracting params\")\n\n    def __deepcopy__(self, memo=None):\n        cpy = copy.copy(self)\n        cpy.base_gate = self.base_gate.copy()\n        if self._definition:\n            cpy._definition = copy.deepcopy(self._definition, memo)\n        return cpy\n\n    def __eq__(self, other) -> bool:\n        return (\n            isinstance(other, ControlledGate)\n            and self.num_ctrl_qubits == other.num_ctrl_qubits\n            and self.ctrl_state == other.ctrl_state\n            and self.base_gate == other.base_gate\n            and self.num_qubits == other.num_qubits\n            and self.num_clbits == other.num_clbits\n            and self.definition == other.definition\n        )\n\n    def inverse(self, annotated: bool = False) -> \"ControlledGate\" | \"AnnotatedOperation\":\n        \"\"\"Invert this gate by calling inverse on the base gate.\"\"\"\n        if not annotated:\n            inverse_gate = self.base_gate.inverse().control(\n                self.num_ctrl_qubits, ctrl_state=self.ctrl_state\n            )\n        else:\n            inverse_gate = super().inverse(annotated=annotated)\n        return inverse_gate\n",
    "line_count": 275
  },
  {
    "filename": "delay.py",
    "path": "qiskit/circuit/delay.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nDelay instruction (for circuit module).\n\"\"\"\nimport numpy as np\n\nfrom qiskit.circuit.classical import expr, types\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit.instruction import Instruction\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit import _utils\nfrom qiskit.circuit.parameterexpression import ParameterExpression\nfrom qiskit._accelerate.circuit import StandardInstructionType\n\n\n@_utils.with_gate_array(np.eye(2, dtype=complex))\nclass Delay(Instruction):\n    \"\"\"Do nothing and just delay/wait/idle for a specified duration.\"\"\"\n\n    _standard_instruction_type = StandardInstructionType.Delay\n\n    def __init__(self, duration, unit=None):\n        \"\"\"\n        Args:\n            duration: the length of time of the duration. If this is an\n                :class:`~.expr.Expr`, it must be a constant expression of type\n                :class:`~.types.Duration` and the ``unit`` parameter should be\n                omitted (or MUST be \"expr\" if it is specified).\n            unit: the unit of the duration, if ``duration`` is a numeric\n                value. Must be ``\"dt\"``, an SI-prefixed seconds unit, or \"expr\".\n\n        Raises:\n            CircuitError: A ``duration`` expression was specified with a resolved\n                type that is not timing-based, or the ``unit`` was improperly specified.\n        \"\"\"\n        if isinstance(duration, expr.Expr):\n            if unit is not None and unit != \"expr\":\n                raise CircuitError(\n                    \"Argument 'unit' must not be specified for a duration expression.\"\n                )\n            if duration.type.kind is not types.Duration:\n                raise CircuitError(\n                    f\"Expression of type '{duration.type}' is not valid for 'duration'.\"\n                )\n            if not duration.const:\n                raise CircuitError(\"Duration expressions must be constant.\")\n            unit = \"expr\"\n        elif unit is None:\n            unit = \"dt\"\n        elif unit not in {\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"dt\"}:\n            raise CircuitError(f\"Unknown unit {unit} is specified.\")\n        # Double underscore to differentiate from the private attribute in\n        # `Instruction`. This can be changed to `_unit` in 2.0 after we\n        # remove `unit` and `duration` from the standard instruction model\n        # as it only will exist in `Delay` after that point.\n        self.__unit = unit\n        super().__init__(\"delay\", 1, 0, params=[duration])\n\n    broadcast_arguments = Gate.broadcast_arguments\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Special case. Return self.\"\"\"\n        return self\n\n    @property\n    def unit(self):\n        \"\"\"The unit for the duration of the delay in :attr`.params`\"\"\"\n        return self.__unit\n\n    @unit.setter\n    def unit(self, value):\n        if value not in {\"s\", \"ms\", \"us\", \"ns\", \"ps\", \"dt\"}:\n            raise CircuitError(f\"Unknown unit {value} is specified.\")\n        self.__unit = value\n\n    @property\n    def duration(self):\n        \"\"\"Get the duration of this delay.\"\"\"\n        return self.params[0]\n\n    @duration.setter\n    def duration(self, duration):\n        \"\"\"Set the duration of this delay.\"\"\"\n        self.params = [duration]\n\n    def to_matrix(self) -> np.ndarray:\n        \"\"\"Return a Numpy.array for the unitary matrix. This has been\n        added to enable simulation without making delay a full Gate type.\n\n        Returns:\n            np.ndarray: matrix representation.\n        \"\"\"\n        return self.__array__(dtype=complex)\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, Delay) and self.unit == other.unit and self._compare_parameters(other)\n        )\n\n    def __repr__(self):\n        \"\"\"Return the official string representing the delay.\"\"\"\n        return f\"{self.__class__.__name__}(duration={self.params[0]}[unit={self.unit}])\"\n\n    # pylint: disable=too-many-return-statements\n    def validate_parameter(self, parameter):\n        \"\"\"Delay parameter (i.e. duration) must be Expr, int, float or ParameterExpression.\"\"\"\n        if isinstance(parameter, int):\n            if parameter < 0:\n                raise CircuitError(\n                    f\"Duration for Delay instruction must be positive. Found {parameter}\"\n                )\n            return parameter\n        elif isinstance(parameter, float):\n            if parameter < 0:\n                raise CircuitError(\n                    f\"Duration for Delay instruction must be positive. Found {parameter}\"\n                )\n            if self.__unit == \"dt\":\n                parameter_int = int(parameter)\n                if parameter != parameter_int:\n                    raise CircuitError(\"Integer duration is expected for 'dt' unit.\")\n                return parameter_int\n            return parameter\n        elif isinstance(parameter, expr.Expr):\n            if parameter.type.kind is not types.Duration:\n                raise CircuitError(f\"Expression duration of type '{parameter.type}' is not valid.\")\n            if not parameter.const:\n                raise CircuitError(\"Duration expressions must be constant.\")\n            return parameter\n        elif isinstance(parameter, ParameterExpression):\n            if len(parameter.parameters) > 0:\n                return parameter  # expression has free parameters, we cannot validate it\n            if not parameter.is_real():\n                raise CircuitError(f\"Bound parameter expression is complex in delay {self.name}\")\n            fval = float(parameter)\n            if fval < 0:\n                raise CircuitError(f\"Duration for Delay instruction must be positive. Found {fval}\")\n            if self.unit == \"dt\":\n                ival = int(parameter)\n                rounding_error = abs(fval - ival)\n                if rounding_error > 1e-15:\n                    raise CircuitError(\"Integer parameter is required for duration in 'dt' unit.\")\n                return ival\n            return fval  # per default assume parameters must be real when bound\n        else:\n            raise CircuitError(f\"Invalid param type {type(parameter)} for delay {self.name}.\")\n",
    "line_count": 158
  },
  {
    "filename": "duration.py",
    "path": "qiskit/circuit/duration.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nUtilities for handling duration of a circuit instruction.\n\"\"\"\nimport warnings\n\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.utils.units import apply_prefix\n\n\ndef duration_in_dt(duration_in_sec: float, dt_in_sec: float) -> int:\n    \"\"\"\n    Return duration in dt.\n\n    Args:\n        duration_in_sec: duration [s] to be converted.\n        dt_in_sec: duration of dt in seconds used for conversion.\n\n    Returns:\n        Duration in dt.\n    \"\"\"\n    res = round(duration_in_sec / dt_in_sec)\n    rounding_error = abs(duration_in_sec - res * dt_in_sec)\n    if rounding_error > 1e-15:\n        warnings.warn(\n            f\"Duration is rounded to {res:d} [dt] = {res * dt_in_sec:e} [s] \"\n            f\"from {duration_in_sec:e} [s]\",\n            UserWarning,\n        )\n    return res\n\n\ndef convert_durations_to_dt(qc: QuantumCircuit, dt_in_sec: float, inplace=True):\n    \"\"\"Convert all the durations in SI (seconds) into those in dt.\n\n    Returns a new circuit if `inplace=False`.\n\n    Parameters:\n        qc (QuantumCircuit): Duration of dt in seconds used for conversion.\n        dt_in_sec (float): Duration of dt in seconds used for conversion.\n        inplace (bool): All durations are converted inplace or return new circuit.\n\n    Returns:\n        QuantumCircuit: Converted circuit if `inplace = False`, otherwise None.\n\n    Raises:\n        CircuitError: if fail to convert durations.\n    \"\"\"\n    if inplace:\n        circ = qc\n    else:\n        circ = qc.copy()\n\n    if circ.duration is not None and circ.unit != \"dt\":\n        if not circ.unit.endswith(\"s\"):\n            raise CircuitError(f\"Invalid time unit: '{circ.unit}'\")\n\n        duration = circ.duration\n        if circ.unit != \"s\":\n            duration = apply_prefix(duration, circ.unit)\n\n        circ.duration = duration_in_dt(duration, dt_in_sec)\n        circ.unit = \"dt\"\n\n    if not inplace:\n        return circ\n    else:\n        return None\n",
    "line_count": 81
  },
  {
    "filename": "equivalence.py",
    "path": "qiskit/circuit/equivalence.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Gate equivalence library.\"\"\"\n\nfrom rustworkx.visualization import graphviz_draw\nimport rustworkx as rx\n\n\nfrom qiskit.exceptions import InvalidFileError\nfrom qiskit._accelerate.equivalence import (  # pylint: disable=unused-import\n    BaseEquivalenceLibrary,\n    Key,\n    Equivalence,\n    NodeData,\n    EdgeData,\n)\n\n\nclass EquivalenceLibrary(BaseEquivalenceLibrary):\n    \"\"\"A library providing a one-way mapping of Gates to their equivalent\n    implementations as QuantumCircuits.\"\"\"\n\n    def draw(self, filename=None):\n        \"\"\"Draws the equivalence relations available in the library.\n\n        Args:\n            filename (str): An optional path to write the output image to\n                if specified this method will return None.\n\n        Returns:\n            PIL.Image or IPython.display.SVG: Drawn equivalence library as an\n                IPython SVG if in a jupyter notebook, or as a PIL.Image otherwise.\n\n        Raises:\n            InvalidFileError: if filename is not valid.\n        \"\"\"\n        image_type = None\n        if filename:\n            if \".\" not in filename:\n                raise InvalidFileError(\"Parameter 'filename' must be in format 'name.extension'\")\n            image_type = filename.split(\".\")[-1]\n        return graphviz_draw(\n            self._build_basis_graph(),\n            lambda node: {\"label\": node[\"label\"]},\n            lambda edge: edge,\n            filename=filename,\n            image_type=image_type,\n        )\n\n    def _build_basis_graph(self):\n        graph = rx.PyDiGraph()\n\n        node_map = {}\n        for key in super().keys():\n            name, num_qubits = key.name, key.num_qubits\n            equivalences = self._get_equivalences(key)\n\n            basis = frozenset([f\"{name}/{num_qubits}\"])\n            for equivalence in equivalences:\n                params, decomp = equivalence.params, equivalence.circuit\n                decomp_basis = frozenset(\n                    f\"{name}/{num_qubits}\"\n                    for name, num_qubits in {\n                        (instruction.operation.name, instruction.operation.num_qubits)\n                        for instruction in decomp.data\n                    }\n                )\n                if basis not in node_map:\n                    basis_node = graph.add_node({\"basis\": basis, \"label\": str(set(basis))})\n                    node_map[basis] = basis_node\n                if decomp_basis not in node_map:\n                    decomp_basis_node = graph.add_node(\n                        {\"basis\": decomp_basis, \"label\": str(set(decomp_basis))}\n                    )\n                    node_map[decomp_basis] = decomp_basis_node\n\n                label = f\"{str(params)}\\n{str(decomp) if num_qubits <= 5 else '...'}\"\n                graph.add_edge(\n                    node_map[basis],\n                    node_map[decomp_basis],\n                    {\"label\": label, \"fontname\": \"Courier\", \"fontsize\": str(8)},\n                )\n\n        return graph\n",
    "line_count": 95
  },
  {
    "filename": "equivalence_library.py",
    "path": "qiskit/circuit/equivalence_library.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Session gates.\"\"\"\n\nfrom .library.standard_gates.equivalence_library import StandardEquivalenceLibrary\nfrom .equivalence import EquivalenceLibrary\n\nSessionEquivalenceLibrary = EquivalenceLibrary(base=StandardEquivalenceLibrary)\n",
    "line_count": 19
  },
  {
    "filename": "exceptions.py",
    "path": "qiskit/circuit/exceptions.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Exceptions for errors raised while handling Quantum Circuits.\"\"\"\n\nfrom qiskit.exceptions import QiskitError\n\n\nclass CircuitError(QiskitError):\n    \"\"\"Base class for errors raised while processing a circuit.\"\"\"\n",
    "line_count": 20
  },
  {
    "filename": "gate.py",
    "path": "qiskit/circuit/gate.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Unitary gate.\"\"\"\n\nfrom __future__ import annotations\nfrom typing import Iterator, Iterable\nimport numpy as np\n\nfrom qiskit.circuit.parameterexpression import ParameterExpression\nfrom qiskit.circuit.exceptions import CircuitError\nfrom .annotated_operation import AnnotatedOperation, ControlModifier, PowerModifier\nfrom .instruction import Instruction\n\n\nclass Gate(Instruction):\n    \"\"\"Unitary gate.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        num_qubits: int,\n        params: list,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Create a new gate.\n\n        Args:\n            name: The Qobj name of the gate.\n            num_qubits: The number of qubits the gate acts on.\n            params: A list of parameters.\n            label: An optional label for the gate.\n        \"\"\"\n        self.definition = None\n        super().__init__(name, num_qubits, 0, params, label=label)\n\n    # Set higher priority than Numpy array and matrix classes\n    __array_priority__ = 20\n\n    def to_matrix(self) -> np.ndarray:\n        \"\"\"Return a Numpy.array for the gate unitary matrix.\n\n        Returns:\n            np.ndarray: if the Gate subclass has a matrix definition.\n\n        Raises:\n            CircuitError: If a Gate subclass does not implement this method an\n                exception will be raised when this base class method is called.\n        \"\"\"\n        if hasattr(self, \"__array__\"):\n            return self.__array__(dtype=complex)\n        raise CircuitError(f\"to_matrix not defined for this {type(self)}\")\n\n    def power(self, exponent: float, annotated: bool = False):\n        \"\"\"Raise this gate to the power of ``exponent``.\n\n        Implemented either as a unitary gate (ref. :class:`~.library.UnitaryGate`)\n        or as an annotated operation (ref. :class:`.AnnotatedOperation`). In the case of several standard\n        gates, such as :class:`.RXGate`, when the power of a gate can be expressed in terms of another\n        standard gate that is returned directly.\n\n        Args:\n            exponent (float): the power to raise the gate to\n            annotated (bool): indicates whether the power gate can be implemented\n                as an annotated operation. In the case of several standard\n                gates, such as :class:`.RXGate`, this argument is ignored when\n                the power of a gate can be expressed in terms of another\n                standard gate.\n\n        Returns:\n            An operation implementing ``gate^exponent``\n\n        Raises:\n            CircuitError: If gate is not unitary\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.quantum_info.operators import Operator\n        from qiskit.circuit.library.generalized_gates.unitary import UnitaryGate\n\n        if not annotated:\n            return UnitaryGate(\n                Operator(self).power(exponent, assume_unitary=True), label=f\"{self.name}^{exponent}\"\n            )\n        else:\n            return AnnotatedOperation(self, PowerModifier(exponent))\n\n    def __pow__(self, exponent: float) -> \"Gate\":\n        return self.power(exponent)\n\n    def _return_repeat(self, exponent: float) -> \"Gate\":\n        gate = Gate(name=f\"{self.name}*{exponent}\", num_qubits=self.num_qubits, params=[])\n        gate.validate_parameter = self.validate_parameter\n        gate.params = self.params\n        return gate\n\n    def control(\n        self,\n        num_ctrl_qubits: int = 1,\n        label: str | None = None,\n        ctrl_state: int | str | None = None,\n        annotated: bool | None = None,\n    ):\n        \"\"\"Return the controlled version of itself.\n\n        Implemented either as a controlled gate (ref. :class:`.ControlledGate`)\n        or as an annotated operation (ref. :class:`.AnnotatedOperation`).\n\n        Args:\n            num_ctrl_qubits: number of controls to add to gate (default: ``1``)\n            label: optional gate label. Ignored if implemented as an annotated\n                operation.\n            ctrl_state: the control state in decimal or as a bitstring\n                (e.g. ``'111'``). If ``None``, use ``2**num_ctrl_qubits-1``.\n            annotated: indicates whether the controlled gate is implemented\n                as an annotated gate. If ``None``, this is set to ``False``\n                if the controlled gate can directly be constructed, and otherwise\n                set to ``True``. This allows defering the construction process in case the\n                synthesis of the controlled gate requires more information (e.g.\n                values of unbound parameters).\n\n        Returns:\n            Controlled version of the given operation.\n\n        Raises:\n            QiskitError: unrecognized mode or invalid ctrl_state\n        \"\"\"\n        if not annotated:  # captures both None and False\n            # pylint: disable=cyclic-import\n            from ._add_control import add_control\n\n            return add_control(self, num_ctrl_qubits, label, ctrl_state)\n\n        else:\n            return AnnotatedOperation(\n                self, ControlModifier(num_ctrl_qubits=num_ctrl_qubits, ctrl_state=ctrl_state)\n            )\n\n    @staticmethod\n    def _broadcast_single_argument(qarg: list) -> Iterator[tuple[list, list]]:\n        \"\"\"Expands a single argument.\n\n        For example: [q[0], q[1]] -> [q[0]], [q[1]]\n        \"\"\"\n        # [q[0], q[1]] -> [q[0]]\n        #              -> [q[1]]\n        for arg0 in qarg:\n            yield [arg0], []\n\n    @staticmethod\n    def _broadcast_2_arguments(qarg0: list, qarg1: list) -> Iterator[tuple[list, list]]:\n        if len(qarg0) == len(qarg1):\n            # [[q[0], q[1]], [r[0], r[1]]] -> [q[0], r[0]]\n            #                              -> [q[1], r[1]]\n            for arg0, arg1 in zip(qarg0, qarg1):\n                yield [arg0, arg1], []\n        elif len(qarg0) == 1:\n            # [[q[0]], [r[0], r[1]]] -> [q[0], r[0]]\n            #                        -> [q[0], r[1]]\n            for arg1 in qarg1:\n                yield [qarg0[0], arg1], []\n        elif len(qarg1) == 1:\n            # [[q[0], q[1]], [r[0]]] -> [q[0], r[0]]\n            #                        -> [q[1], r[0]]\n            for arg0 in qarg0:\n                yield [arg0, qarg1[0]], []\n        else:\n            raise CircuitError(\n                f\"Not sure how to combine these two-qubit arguments:\\n {qarg0}\\n {qarg1}\"\n            )\n\n    @staticmethod\n    def _broadcast_3_or_more_args(qargs: list) -> Iterator[tuple[list, list]]:\n        if all(len(qarg) == len(qargs[0]) for qarg in qargs):\n            for arg in zip(*qargs):\n                yield list(arg), []\n        else:\n            raise CircuitError(f\"Not sure how to combine these qubit arguments:\\n {qargs}\\n\")\n\n    def broadcast_arguments(self, qargs: list, cargs: list) -> Iterable[tuple[list, list]]:\n        \"\"\"Validation and handling of the arguments and its relationship.\n\n        For example, ``cx([q[0],q[1]], q[2])`` means ``cx(q[0], q[2]); cx(q[1], q[2])``. This\n        method yields the arguments in the right grouping. In the given example::\n\n            in: [[q[0],q[1]], q[2]],[]\n            outs: [q[0], q[2]], []\n                  [q[1], q[2]], []\n\n        The general broadcasting rules are:\n\n            * If len(qargs) == 1::\n\n                [q[0], q[1]] -> [q[0]],[q[1]]\n\n            * If len(qargs) == 2::\n\n                [[q[0], q[1]], [r[0], r[1]]] -> [q[0], r[0]], [q[1], r[1]]\n                [[q[0]], [r[0], r[1]]]       -> [q[0], r[0]], [q[0], r[1]]\n                [[q[0], q[1]], [r[0]]]       -> [q[0], r[0]], [q[1], r[0]]\n\n            * If len(qargs) >= 3::\n\n                [q[0], q[1]], [r[0], r[1]],  ...] -> [q[0], r[0], ...], [q[1], r[1], ...]\n\n        Args:\n            qargs: List of quantum bit arguments.\n            cargs: List of classical bit arguments.\n\n        Returns:\n            A tuple with single arguments.\n\n        Raises:\n            CircuitError: If the input is not valid. For example, the number of\n                arguments does not match the gate expectation.\n        \"\"\"\n        if len(qargs) != self.num_qubits or cargs:\n            raise CircuitError(\n                f\"The amount of qubit({len(qargs)})/clbit({len(cargs)}) arguments does\"\n                f\" not match the gate expectation ({self.num_qubits}).\"\n            )\n\n        if any(not qarg for qarg in qargs):\n            raise CircuitError(\"One or more of the arguments are empty\")\n\n        if len(qargs) == 0:\n            return [\n                ([], []),\n            ]\n        if len(qargs) == 1:\n            return Gate._broadcast_single_argument(qargs[0])\n        elif len(qargs) == 2:\n            return Gate._broadcast_2_arguments(qargs[0], qargs[1])\n        elif len(qargs) >= 3:\n            return Gate._broadcast_3_or_more_args(qargs)\n        else:\n            raise CircuitError(f\"This gate cannot handle {len(qargs)} arguments\")\n\n    def validate_parameter(self, parameter):\n        \"\"\"Gate parameters should be int, float, or ParameterExpression\"\"\"\n        if isinstance(parameter, ParameterExpression):\n            if len(parameter.parameters) > 0:\n                return parameter  # expression has free parameters, we cannot validate it\n            if not parameter.is_real():\n                msg = f\"Bound parameter expression is complex in gate {self.name}\"\n                raise CircuitError(msg)\n            return parameter  # per default assume parameters must be real when bound\n        if isinstance(parameter, (int, float)):\n            return parameter\n        elif isinstance(parameter, (np.integer, np.floating)):\n            return parameter.item()\n        else:\n            raise CircuitError(f\"Invalid param type {type(parameter)} for gate {self.name}.\")\n",
    "line_count": 262
  },
  {
    "filename": "instructionset.py",
    "path": "qiskit/circuit/instructionset.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nInstruction collection.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import MutableSequence\nfrom typing import Callable, TYPE_CHECKING\n\nfrom qiskit.circuit.exceptions import CircuitError\nfrom .operation import Operation\nfrom .quantumcircuitdata import CircuitInstruction\n\nif TYPE_CHECKING:\n    from qiskit.circuit import Clbit, ClassicalRegister\n\n\nclass InstructionSet:\n    \"\"\"Instruction collection, and their contexts.\"\"\"\n\n    __slots__ = (\"_instructions\", \"_requester\")\n\n    def __init__(  # pylint: disable=bad-docstring-quotes\n        self,\n        *,\n        resource_requester: Callable[..., ClassicalRegister | Clbit] | None = None,\n    ):\n        \"\"\"New collection of instructions.\n\n        The context (``qargs`` and ``cargs`` that each instruction is attached to) is also stored\n        separately for each instruction.\n\n        Args:\n            resource_requester: A callable that takes in the classical resource used in the\n                condition, verifies that it is present in the attached circuit, resolves any indices\n                into concrete :obj:`.Clbit` instances, and returns the concrete resource.  If this\n                is not given, specifying a condition with an index is forbidden, and all concrete\n                :obj:`.Clbit` and :obj:`.ClassicalRegister` resources will be assumed to be valid.\n\n                .. note::\n\n                    The callback ``resource_requester`` assumes that a call implies that the\n                    resource will now be used.  It may throw an error if the resource is not valid\n                    for usage.\n\n        \"\"\"\n        self._instructions: list[\n            CircuitInstruction | (MutableSequence[CircuitInstruction], int)\n        ] = []\n        self._requester = resource_requester\n\n    def __len__(self):\n        \"\"\"Return number of instructions in set\"\"\"\n        return len(self._instructions)\n\n    def __getitem__(self, i):\n        \"\"\"Return instruction at index\"\"\"\n        inst = self._instructions[i]\n        if isinstance(inst, CircuitInstruction):\n            return inst\n        data, idx = inst\n        return data[idx]\n\n    def add(self, instruction, qargs=None, cargs=None):\n        \"\"\"Add an instruction and its context (where it is attached).\"\"\"\n        if not isinstance(instruction, CircuitInstruction):\n            if not isinstance(instruction, Operation):\n                raise CircuitError(\"attempt to add non-Operation to InstructionSet\")\n            if qargs is None or cargs is None:\n                raise CircuitError(\"missing qargs or cargs in old-style InstructionSet.add\")\n            instruction = CircuitInstruction(instruction, tuple(qargs), tuple(cargs))\n        self._instructions.append(instruction)\n\n    def _add_ref(self, data: MutableSequence[CircuitInstruction], pos: int):\n        \"\"\"Add a reference to an instruction and its context within a mutable sequence.\n        Updates to the instruction set will modify the specified sequence in place.\"\"\"\n        self._instructions.append((data, pos))\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Invert all instructions.\n\n        .. note::\n            It is preferable to take the inverse *before* appending the gate(s) to the circuit.\n        \"\"\"\n        for i, instruction in enumerate(self._instructions):\n            if isinstance(instruction, CircuitInstruction):\n                self._instructions[i] = instruction.replace(\n                    operation=instruction.operation.inverse(annotated=annotated)\n                )\n            else:\n                data, idx = instruction\n                instruction = data[idx]\n                data[idx] = instruction.replace(\n                    operation=instruction.operation.inverse(annotated=annotated)\n                )\n        return self\n\n    # Legacy support for properties.  Added in Terra 0.21 to support the internal switch in\n    # `QuantumCircuit.data` from the 3-tuple to `CircuitInstruction`.\n\n    def _instructions_iter(self):\n        return (i if isinstance(i, CircuitInstruction) else i[0][i[1]] for i in self._instructions)\n\n    @property\n    def instructions(self):\n        \"\"\"Legacy getter for the instruction components of an instruction set.  This does not\n        support mutation.\"\"\"\n        return [instruction.operation for instruction in self._instructions_iter()]\n\n    @property\n    def qargs(self):\n        \"\"\"Legacy getter for the qargs components of an instruction set.  This does not support\n        mutation.\"\"\"\n        return [list(instruction.qubits) for instruction in self._instructions_iter()]\n\n    @property\n    def cargs(self):\n        \"\"\"Legacy getter for the cargs components of an instruction set.  This does not support\n        mutation.\"\"\"\n        return [list(instruction.clbits) for instruction in self._instructions_iter()]\n",
    "line_count": 133
  },
  {
    "filename": "measure.py",
    "path": "qiskit/circuit/measure.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nQuantum measurement in the computational basis.\n\"\"\"\n\nfrom qiskit.circuit.singleton import SingletonInstruction, stdlib_singleton_key\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit._accelerate.circuit import StandardInstructionType\n\n\nclass Measure(SingletonInstruction):\n    \"\"\"Quantum measurement in the computational basis.\"\"\"\n\n    _standard_instruction_type = StandardInstructionType.Measure\n\n    def __init__(self, label=None):\n        \"\"\"\n        Args:\n            label: optional string label for this instruction.\n        \"\"\"\n        super().__init__(\"measure\", 1, 1, [], label=label)\n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n        # Subclasses of Measure are not \"standard\", so we set this to None to\n        # prevent the Rust code from treating them as such.\n        cls._standard_instruction_type = None\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def broadcast_arguments(self, qargs, cargs):\n        qarg = qargs[0]\n        carg = cargs[0]\n\n        if len(carg) == len(qarg):\n            for qarg, carg in zip(qarg, carg):\n                yield [qarg], [carg]\n        elif len(qarg) == 1 and carg:\n            for each_carg in carg:\n                yield qarg, [each_carg]\n        else:\n            raise CircuitError(\"register size error\")\n",
    "line_count": 54
  },
  {
    "filename": "operation.py",
    "path": "qiskit/circuit/operation.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Quantum Operation Mixin.\"\"\"\n\nfrom abc import ABC, abstractmethod\n\n\nclass Operation(ABC):\n    \"\"\"Quantum operation interface.\n\n    The minimal interface that any object must fulfil in order to be added to a\n    :class:`.QuantumCircuit`.\n\n    Concrete instances of this interface include :class:`~qiskit.circuit.Gate`,\n    :class:`~qiskit.circuit.Reset`, :class:`~qiskit.circuit.Barrier`,\n    :class:`~qiskit.circuit.Measure`, and operators such as :class:`~qiskit.quantum_info.Clifford`.\n\n    The main purpose is to allow abstract mathematical objects to be added directly onto\n    abstract circuits, and for the exact syntheses of these to be determined later, during\n    compilation.\n\n    Example:\n\n        Add a Clifford and a Toffoli gate to a :class:`QuantumCircuit`.\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit import QuantumCircuit\n           from qiskit.quantum_info import Clifford, random_clifford\n\n           qc = QuantumCircuit(3)\n           cliff = random_clifford(2)\n           qc.append(cliff, [0, 1])\n           qc.ccx(0, 1, 2)\n           qc.draw('mpl')\n    \"\"\"\n\n    __slots__ = ()\n\n    @property\n    @abstractmethod\n    def name(self):\n        \"\"\"Unique string identifier for operation type.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def num_qubits(self):\n        \"\"\"Number of qubits.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def num_clbits(self):\n        \"\"\"Number of classical bits.\"\"\"\n        raise NotImplementedError\n",
    "line_count": 69
  },
  {
    "filename": "parameter.py",
    "path": "qiskit/circuit/parameter.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\"\"\"\nParameter Class for variable parameters.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom uuid import uuid4, UUID\n\nimport symengine\n\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .parameterexpression import ParameterExpression\n\n\nclass Parameter(ParameterExpression):\n    \"\"\"A compile-time symbolic parameter.\n\n    The value of a :class:`Parameter` must be entirely determined before a circuit begins execution.\n    Typically this will mean that you should supply values for all :class:`Parameter`\\\\ s in a\n    circuit using :meth:`.QuantumCircuit.assign_parameters`, though certain hardware vendors may\n    allow you to give them a circuit in terms of these parameters, provided you also pass the values\n    separately.\n\n    This is the atom of :class:`.ParameterExpression`, and is itself an expression.  The numeric\n    value of a parameter need not be fixed while the circuit is being defined.\n\n    Examples:\n\n        Construct a variable-rotation X gate using circuit parameters.\n\n        .. plot::\n           :alt: Circuit diagram output by the previous code.\n           :include-source:\n\n           from qiskit.circuit import QuantumCircuit, Parameter\n\n           # create the parameter\n           phi = Parameter('phi')\n           qc = QuantumCircuit(1)\n\n           # parameterize the rotation\n           qc.rx(phi, 0)\n           qc.draw('mpl')\n\n           # bind the parameters after circuit to create a bound circuit\n           bc = qc.assign_parameters({phi: 3.14})\n           bc.measure_all()\n           bc.draw('mpl')\n    \"\"\"\n\n    __slots__ = (\"_uuid\", \"_hash\")\n\n    # This `__init__` does not call the super init, because we can't construct the\n    # `_parameter_symbols` dictionary we need to pass to it before we're entirely initialized\n    # anyway, because `ParameterExpression` depends heavily on the structure of `Parameter`.\n\n    def __init__(\n        self, name: str, *, uuid: UUID | None = None\n    ):  # pylint: disable=super-init-not-called\n        \"\"\"\n        Args:\n            name: name of the ``Parameter``, used for visual representation. This can\n                be any Unicode string, e.g. \"\u03d5\".\n            uuid: For advanced usage only.  Override the UUID of this parameter, in order to make it\n                compare equal to some other parameter object.  By default, two parameters with the\n                same name do not compare equal to help catch shadowing bugs when two circuits\n                containing the same named parameters are spurious combined.  Setting the ``uuid``\n                field when creating two parameters to the same thing (along with the same name)\n                allows them to be equal.  This is useful during serialization and deserialization.\n        \"\"\"\n        self._uuid = uuid4() if uuid is None else uuid\n        symbol = symengine.Symbol(name)\n\n        self._symbol_expr = symbol\n        self._parameter_keys = frozenset((self._hash_key(),))\n        self._hash = hash((self._parameter_keys, self._symbol_expr))\n        self._parameter_symbols = {self: symbol}\n        self._name_map = None\n        self._qpy_replay = []\n        self._standalone_param = True\n\n    def assign(self, parameter, value):\n        if parameter != self:\n            # Corresponds to superclass calls to `subs` and `bind` that would implicitly set\n            # `allow_unknown_parameters=False`.\n            raise CircuitError(\n                f\"Cannot bind Parameters ({[str(parameter)]}) not present in expression.\"\n            )\n        if isinstance(value, ParameterExpression):\n            # This is the `super().subs` case.\n            return value\n        # This is the `super().bind` case, where we're required to return a `ParameterExpression`,\n        # so we need to lift the given value to a symbolic expression.\n        return ParameterExpression({}, symengine.sympify(value))\n\n    def subs(self, parameter_map: dict, allow_unknown_parameters: bool = False):\n        \"\"\"Substitute self with the corresponding parameter in ``parameter_map``.\"\"\"\n        if self in parameter_map:\n            return parameter_map[self]\n        if allow_unknown_parameters:\n            return self\n        raise CircuitError(\n            f\"Cannot bind Parameters ({[str(p) for p in parameter_map]}) not present in \"\n            \"expression.\"\n        )\n\n    @property\n    def name(self):\n        \"\"\"Returns the name of the :class:`Parameter`.\"\"\"\n        return self._symbol_expr.name\n\n    @property\n    def uuid(self) -> UUID:\n        \"\"\"Returns the :class:`~uuid.UUID` of the :class:`Parameter`.\n\n        In advanced use cases, this property can be passed to the\n        :class:`Parameter` constructor to produce an instance that compares\n        equal to another instance.\n        \"\"\"\n        return self._uuid\n\n    def __str__(self):\n        return self.name\n\n    def __copy__(self):\n        return self\n\n    def __deepcopy__(self, memo=None):\n        return self\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self.name})\"\n\n    def __eq__(self, other):\n        if isinstance(other, Parameter):\n            return (self._uuid, self._symbol_expr) == (other._uuid, other._symbol_expr)\n        elif isinstance(other, ParameterExpression):\n            return super().__eq__(other)\n        else:\n            return False\n\n    def _hash_key(self):\n        # `ParameterExpression` needs to be able to hash all its contained `Parameter` instances in\n        # its hash as part of the equality comparison but has its own more complete symbolic\n        # expression, so its full hash key is split into `(parameter_keys, symbolic_expression)`.\n        # This method lets containing expressions get only the bits they need for equality checks in\n        # the first value, without wasting time re-hashing individual Sympy/Symengine symbols.\n        return (self._symbol_expr, self._uuid)\n\n    def __hash__(self):\n        # This is precached for performance, since it's used a lot and we are immutable.\n        return self._hash\n\n    # We have to manually control the pickling so that the hash is computable before the unpickling\n    # operation attempts to put this parameter into a hashmap.\n\n    def __getstate__(self):\n        return (self.name, self._uuid, self._symbol_expr)\n\n    def __setstate__(self, state):\n        _, self._uuid, self._symbol_expr = state\n        self._parameter_keys = frozenset((self._hash_key(),))\n        self._hash = hash((self._parameter_keys, self._symbol_expr))\n        self._parameter_symbols = {self: self._symbol_expr}\n        self._name_map = None\n        self._qpy_replay = []\n        self._standalone_param = True\n",
    "line_count": 180
  },
  {
    "filename": "parametertable.py",
    "path": "qiskit/circuit/parametertable.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\"\"\"\nLook-up table for variable parameters in QuantumCircuit.\n\"\"\"\n\nfrom collections.abc import MappingView\n\n\nclass ParameterView(MappingView):\n    \"\"\"Temporary class to transition from a set return-type to list.\n\n    Derives from a list but implements all set methods, but all set-methods emit deprecation\n    warnings.\n    \"\"\"\n\n    def __init__(self, iterable=None):\n        if iterable is not None:\n            self.data = list(iterable)\n        else:\n            self.data = []\n\n        super().__init__(self.data)\n\n    def copy(self):\n        \"\"\"Copy the ParameterView.\"\"\"\n        return self.__class__(self.data.copy())\n\n    def isdisjoint(self, x):\n        \"\"\"Check whether self and the input are disjoint.\"\"\"\n        return not any(element in self for element in x)\n\n    def remove(self, x):\n        \"\"\"Remove an existing element from the view.\"\"\"\n        self.data.remove(x)\n\n    def __repr__(self):\n        \"\"\"Format the class as string.\"\"\"\n        return f\"ParameterView({self.data})\"\n\n    def __getitem__(self, index):\n        \"\"\"Get items.\"\"\"\n        return self.data[index]\n\n    def __and__(self, x):\n        \"\"\"Get the intersection between self and the input.\"\"\"\n        inter = []\n        for element in self:\n            if element in x:\n                inter.append(element)\n\n        return self.__class__(inter)\n\n    def __rand__(self, x):\n        \"\"\"Get the intersection between self and the input.\"\"\"\n        return self.__and__(x)\n\n    def __iand__(self, x):\n        \"\"\"Get the intersection between self and the input in-place.\"\"\"\n        for element in self:\n            if element not in x:\n                self.remove(element)\n        return self\n\n    def __len__(self):\n        \"\"\"Get the length.\"\"\"\n        return len(self.data)\n\n    def __or__(self, x):\n        \"\"\"Get the union of self and the input.\"\"\"\n        return set(self) | set(x)\n\n    def __sub__(self, x):\n        \"\"\"Get the difference between self and the input.\"\"\"\n        return set(self) - set(x)\n\n    def __xor__(self, x):\n        \"\"\"Get the symmetric difference between self and the input.\"\"\"\n        return set(self) ^ set(x)\n\n    def __ne__(self, other):\n        return set(other) != set(self)\n\n    def __eq__(self, other):\n        return set(other) == set(self)\n\n    def __le__(self, x):\n        return all(element in x for element in self)\n\n    def __lt__(self, x):\n        if x != self:\n            return self <= x\n        return False\n\n    def __ge__(self, x):\n        return all(element in self for element in x)\n\n    def __gt__(self, x):\n        if x != self:\n            return self >= x\n        return False\n\n    def __iter__(self):\n        return iter(self.data)\n\n    def __contains__(self, x):\n        return x in self.data\n\n    __hash__: None  # type: ignore\n    __ror__ = __or__\n",
    "line_count": 120
  },
  {
    "filename": "parametervector.py",
    "path": "qiskit/circuit/parametervector.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Parameter Vector Class to simplify management of parameter lists.\"\"\"\n\nfrom uuid import uuid4, UUID\n\nfrom .parameter import Parameter\n\n\nclass ParameterVectorElement(Parameter):\n    \"\"\"An element of a :class:`ParameterVector`.\n\n    .. note::\n        There is very little reason to ever construct this class directly.  Objects of this type are\n        automatically constructed efficiently as part of creating a :class:`ParameterVector`.\n    \"\"\"\n\n    ___slots__ = (\"_vector\", \"_index\")\n\n    def __init__(self, vector, index, uuid=None):\n        super().__init__(f\"{vector.name}[{index}]\", uuid=uuid)\n        self._vector = vector\n        self._index = index\n\n    @property\n    def index(self):\n        \"\"\"Get the index of this element in the parent vector.\"\"\"\n        return self._index\n\n    @property\n    def vector(self):\n        \"\"\"Get the parent vector instance.\"\"\"\n        return self._vector\n\n    def __getstate__(self):\n        return super().__getstate__() + (self._vector, self._index)\n\n    def __setstate__(self, state):\n        *super_state, vector, index = state\n        super().__setstate__(super_state)\n        self._vector = vector\n        self._index = index\n\n\nclass ParameterVector:\n    \"\"\"A container of many related :class:`Parameter` objects.\n\n    This class is faster to construct than constructing many :class:`Parameter` objects\n    individually, and the individual names of the parameters will all share a common stem (the name\n    of the vector).  For a vector called ``v`` with length 3, the individual elements will have\n    names ``v[0]``, ``v[1]`` and ``v[2]``.\n\n    The elements of a vector are sorted by the name of the vector, then the numeric value of their\n    index.\n\n    This class fulfill the :class:`collections.abc.Sequence` interface.\n    \"\"\"\n\n    __slots__ = (\"_name\", \"_params\", \"_root_uuid\")\n\n    def __init__(self, name, length=0):\n        self._name = name\n        self._root_uuid = uuid4()\n        root_uuid_int = self._root_uuid.int\n        self._params = [\n            ParameterVectorElement(self, i, UUID(int=root_uuid_int + i)) for i in range(length)\n        ]\n\n    @property\n    def name(self):\n        \"\"\"The name of the :class:`ParameterVector`.\"\"\"\n        return self._name\n\n    @property\n    def params(self):\n        \"\"\"A list of the contained :class:`ParameterVectorElement` instances.\n\n        It is not safe to mutate this list.\"\"\"\n        return self._params\n\n    def index(self, value):\n        \"\"\"Find the index of a :class:`ParameterVectorElement` within the list.\n\n        It is typically much faster to use the :attr:`ParameterVectorElement.index` property.\"\"\"\n        return self._params.index(value)\n\n    def __getitem__(self, key):\n        return self.params[key]\n\n    def __iter__(self):\n        return iter(self.params)\n\n    def __len__(self):\n        return len(self._params)\n\n    def __str__(self):\n        return f\"{self.name}, {[str(item) for item in self.params]}\"\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(name={repr(self.name)}, length={len(self)})\"\n\n    def resize(self, length):\n        \"\"\"Resize the parameter vector.  If necessary, new elements are generated.\n\n        Note that the UUID of each :class:`.Parameter` element will be generated\n        deterministically given the root UUID of the ``ParameterVector`` and the index\n        of the element.  In particular, if a ``ParameterVector`` is resized to\n        be smaller and then later resized to be larger, the UUID of the later\n        generated element at a given index will be the same as the UUID of the\n        previous element at that index.\n        This is to ensure that the parameter instances do not change.\n\n        >>> from qiskit.circuit import ParameterVector\n        >>> pv = ParameterVector(\"theta\", 20)\n        >>> elt_19 = pv[19]\n        >>> rv.resize(10)\n        >>> rv.resize(20)\n        >>> pv[19] == elt_19\n        True\n        \"\"\"\n        if length > len(self._params):\n            root_uuid_int = self._root_uuid.int\n            self._params.extend(\n                [\n                    ParameterVectorElement(self, i, UUID(int=root_uuid_int + i))\n                    for i in range(len(self._params), length)\n                ]\n            )\n        else:\n            del self._params[length:]\n",
    "line_count": 141
  },
  {
    "filename": "quantumcircuitdata.py",
    "path": "qiskit/circuit/quantumcircuitdata.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"A wrapper class for the purposes of validating modifications to\nQuantumCircuit.data while maintaining the interface of a python list.\"\"\"\n\nfrom collections.abc import MutableSequence\n\nimport qiskit._accelerate.circuit\n\nfrom .exceptions import CircuitError\nfrom .instruction import Instruction\nfrom .operation import Operation\n\n\nCircuitInstruction = qiskit._accelerate.circuit.CircuitInstruction\n\n\nclass QuantumCircuitData(MutableSequence):\n    \"\"\"A wrapper class for the purposes of validating modifications to\n    QuantumCircuit.data while maintaining the interface of a python list.\"\"\"\n\n    def __init__(self, circuit):\n        self._circuit = circuit\n\n    def __getitem__(self, i):\n        return self._circuit._data[i]\n\n    def __setitem__(self, key, value):\n        # For now (Terra 0.21), the `QuantumCircuit.data` setter is meant to perform validation, so\n        # we do the same qubit checks that `QuantumCircuit.append` would do.\n        if isinstance(value, CircuitInstruction):\n            operation, qargs, cargs = value.operation, value.qubits, value.clbits\n        else:\n            # Handle the legacy 3-tuple format.\n            operation, qargs, cargs = value\n        value = self._resolve_legacy_value(operation, qargs, cargs)\n        self._circuit._data[key] = value\n\n    def _resolve_legacy_value(self, operation, qargs, cargs) -> CircuitInstruction:\n        \"\"\"Resolve the old-style 3-tuple into the new :class:`CircuitInstruction` type.\"\"\"\n        if not isinstance(operation, Operation) and hasattr(operation, \"to_instruction\"):\n            operation = operation.to_instruction()\n        if not isinstance(operation, Operation):\n            raise CircuitError(\"object is not an Operation.\")\n\n        expanded_qargs = [self._circuit._qbit_argument_conversion(qarg) for qarg in qargs or []]\n        expanded_cargs = [self._circuit._cbit_argument_conversion(carg) for carg in cargs or []]\n\n        if isinstance(operation, Instruction):\n            broadcast_args = list(operation.broadcast_arguments(expanded_qargs, expanded_cargs))\n        else:\n            broadcast_args = list(\n                Instruction.broadcast_arguments(operation, expanded_qargs, expanded_cargs)\n            )\n\n        if len(broadcast_args) > 1:\n            raise CircuitError(\n                \"QuantumCircuit.data modification does not support argument broadcasting.\"\n            )\n\n        qargs, cargs = broadcast_args[0]\n\n        self._circuit._check_dups(qargs)\n        return CircuitInstruction(operation, tuple(qargs), tuple(cargs))\n\n    def insert(self, index, value):\n        self._circuit._data.insert(index, value.replace(qubits=(), clbits=()))\n        try:\n            self[index] = value\n        except CircuitError:\n            del self._circuit._data[index]\n            raise\n\n    def __iter__(self):\n        return iter(self._circuit._data)\n\n    def __delitem__(self, i):\n        del self._circuit._data[i]\n\n    def __len__(self):\n        return len(self._circuit._data)\n\n    def __cast(self, other):\n        return list(other._circuit._data) if isinstance(other, QuantumCircuitData) else other\n\n    def __repr__(self):\n        return repr(list(self._circuit._data))\n\n    def __lt__(self, other):\n        return list(self._circuit._data) < self.__cast(other)\n\n    def __le__(self, other):\n        return list(self._circuit._data) <= self.__cast(other)\n\n    def __eq__(self, other):\n        return self._circuit._data == self.__cast(other)\n\n    def __gt__(self, other):\n        return list(self._circuit._data) > self.__cast(other)\n\n    def __ge__(self, other):\n        return list(self._circuit._data) >= self.__cast(other)\n\n    def __add__(self, other):\n        return list(self._circuit._data) + self.__cast(other)\n\n    def __radd__(self, other):\n        return self.__cast(other) + list(self._circuit._data)\n\n    def __mul__(self, n):\n        return list(self._circuit._data) * n\n\n    def __rmul__(self, n):\n        return n * list(self._circuit._data)\n\n    def sort(self, *args, **kwargs):\n        \"\"\"In-place stable sort. Accepts arguments of list.sort.\"\"\"\n        data = list(self._circuit._data)\n        data.sort(*args, **kwargs)\n        self._circuit._data.clear()\n        self._circuit._data.reserve(len(data))\n        self._circuit._data.extend(data)\n\n    def copy(self):\n        \"\"\"Returns a shallow copy of instruction list.\"\"\"\n        return list(self._circuit._data)\n",
    "line_count": 137
  },
  {
    "filename": "reset.py",
    "path": "qiskit/circuit/reset.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nQubit reset to computational zero.\n\"\"\"\n\nfrom qiskit.circuit.singleton import SingletonInstruction, stdlib_singleton_key\nfrom qiskit._accelerate.circuit import StandardInstructionType\n\n\nclass Reset(SingletonInstruction):\n    r\"\"\"Incoherently reset a qubit to the :math:`\\lvert0\\rangle` state.\"\"\"\n\n    _standard_instruction_type = StandardInstructionType.Reset\n\n    def __init__(self, label=None):\n        \"\"\"\n        Args:\n            label: optional string label of this instruction.\n        \"\"\"\n        super().__init__(\"reset\", 1, 0, [], label=label)\n\n    _singleton_lookup_key = stdlib_singleton_key()\n\n    def broadcast_arguments(self, qargs, cargs):\n        for qarg in qargs[0]:\n            yield [qarg], []\n",
    "line_count": 38
  },
  {
    "filename": "store.py",
    "path": "qiskit/circuit/store.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The 'Store' operation.\"\"\"\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom .exceptions import CircuitError\nfrom .classical import expr, types\nfrom .instruction import Instruction\n\n\ndef _handle_equal_types(lvalue: expr.Expr, rvalue: expr.Expr, /) -> tuple[expr.Expr, expr.Expr]:\n    return lvalue, rvalue\n\n\ndef _handle_implicit_cast(lvalue: expr.Expr, rvalue: expr.Expr, /) -> tuple[expr.Expr, expr.Expr]:\n    return lvalue, expr.Cast(rvalue, lvalue.type, implicit=True)\n\n\ndef _requires_lossless_cast(lvalue: expr.Expr, rvalue: expr.Expr, /) -> typing.NoReturn:\n    raise CircuitError(f\"an explicit cast is required from '{rvalue.type}' to '{lvalue.type}'\")\n\n\ndef _requires_dangerous_cast(lvalue: expr.Expr, rvalue: expr.Expr, /) -> typing.NoReturn:\n    raise CircuitError(\n        f\"an explicit cast is required from '{rvalue.type}' to '{lvalue.type}', which may be lossy\"\n    )\n\n\ndef _no_cast_possible(lvalue: expr.Expr, rvalue: expr.Expr) -> typing.NoReturn:\n    raise CircuitError(f\"no cast is possible from '{rvalue.type}' to '{lvalue.type}'\")\n\n\n_HANDLE_CAST = {\n    types.CastKind.EQUAL: _handle_equal_types,\n    types.CastKind.IMPLICIT: _handle_implicit_cast,\n    types.CastKind.LOSSLESS: _requires_lossless_cast,\n    types.CastKind.DANGEROUS: _requires_dangerous_cast,\n    types.CastKind.NONE: _no_cast_possible,\n}\n\n\nclass Store(Instruction):\n    \"\"\"A manual storage of some classical value to a classical memory location.\n\n    This is a low-level primitive of the classical-expression handling (similar to how\n    :class:`~.circuit.Measure` is a primitive for quantum measurement), and is not safe for\n    subclassing.\"\"\"\n\n    # This is a compiler/backend intrinsic operation, separate to any quantum processing.\n    _directive = True\n\n    def __init__(self, lvalue: expr.Expr, rvalue: expr.Expr):\n        \"\"\"\n        Args:\n            lvalue: the memory location being stored into.\n            rvalue: the expression result being stored.\n        \"\"\"\n        if not expr.is_lvalue(lvalue):\n            raise CircuitError(f\"'{lvalue}' is not an l-value\")\n\n        cast_kind = types.cast_kind(rvalue.type, lvalue.type)\n        if (handler := _HANDLE_CAST.get(cast_kind)) is None:\n            raise RuntimeError(f\"unhandled cast kind required: {cast_kind}\")\n        lvalue, rvalue = handler(lvalue, rvalue)\n\n        super().__init__(\"store\", 0, 0, [lvalue, rvalue])\n\n    @property\n    def lvalue(self):\n        \"\"\"Get the l-value :class:`~.expr.Expr` node that is being stored to.\"\"\"\n        return self.params[0]\n\n    @property\n    def rvalue(self):\n        \"\"\"Get the r-value :class:`~.expr.Expr` node that is being written into the l-value.\"\"\"\n        return self.params[1]\n",
    "line_count": 90
  },
  {
    "filename": "twirling.py",
    "path": "qiskit/circuit/twirling.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2024\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The twirling module.\"\"\"\n\nfrom __future__ import annotations\nimport typing\n\nfrom qiskit._accelerate.twirling import twirl_circuit as twirl_rs\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit, _copy_metadata\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.library.standard_gates import CXGate, ECRGate, CZGate, iSwapGate\nfrom qiskit.exceptions import QiskitError\n\nif typing.TYPE_CHECKING:\n    from qiskit.transpiler.target import Target\n\n\nNAME_TO_CLASS = {\n    \"cx\": CXGate._standard_gate,\n    \"ecr\": ECRGate._standard_gate,\n    \"cz\": CZGate._standard_gate,\n    \"iswap\": iSwapGate._standard_gate,\n}\n\n\ndef pauli_twirl_2q_gates(\n    circuit: QuantumCircuit,\n    twirling_gate: None | str | Gate | list[str] | list[Gate] = None,\n    seed: int | None = None,\n    num_twirls: int | None = None,\n    target: Target | None = None,\n) -> QuantumCircuit | list[QuantumCircuit]:\n    \"\"\"Create copies of a given circuit with Pauli twirling applied around specified two qubit\n    gates.\n\n    If you're running this function with the intent to twirl a circuit to run on hardware this\n    may not be the most efficient way to perform twirling. Especially if the hardware vendor\n    has implemented the :mod:`.primitives` execution interface with :class:`.SamplerV2` and\n    :class:`.EstimatorV2` this most likely is not the best way to apply twirling to your\n    circuit and you'll want to refer to the implementation of :class:`.SamplerV2` and/or\n    :class:`.EstimatorV2` for the specified hardware vendor.\n\n    If the intent of this function is to be run after :func:`.transpile` or\n    :meth:`.PassManager.run` the optional ``target`` argument can be used\n    so that the inserted 1 qubit Pauli gates are synthesized to be\n    compatible with the given :class:`.Target` so the output circuit(s) are\n    still compatible.\n\n    Args:\n        circuit: The circuit to twirl\n        twirling_gate: The gate to twirl, defaults to `None` which means twirl all default gates:\n            :class:`.CXGate`, :class:`.CZGate`, :class:`.ECRGate`, and :class:`.iSwapGate`.\n            If supplied it can either be a single gate or a list of gates either as either a gate\n            object or its string name. Currently only the names `\"cx\"`, `\"cz\"`, `\"ecr\"`,  and\n            `\"iswap\"` are supported. If a gate object is provided outside the default gates it must\n            have a matrix defined from its :class:`~.Gate.to_matrix` method for the gate to potentially\n            be twirled. If a valid twirling configuration can't be computed that particular gate will\n            be silently ignored and not twirled.\n        seed: An integer seed for the random number generator used internally by this function.\n            If specified this must be between 0 and 18,446,744,073,709,551,615.\n        num_twirls: The number of twirling circuits to build. This defaults to ``None`` and will return\n            a single circuit. If it is an integer a list of circuits with `num_twirls` circuits\n            will be returned.\n        target: If specified an :class:`.Target` instance to use for running single qubit decomposition\n            as part of the Pauli twirling to optimize and map the pauli gates added to the circuit\n            to the specified target.\n\n    Returns:\n        A copy of the given circuit with Pauli twirling applied to each\n        instance of the specified twirling gate.\n    \"\"\"\n    custom_gates = None\n    if isinstance(twirling_gate, str):\n        gate = NAME_TO_CLASS.get(twirling_gate, None)\n        if gate is None:\n            raise QiskitError(f\"The specified gate name {twirling_gate} is not supported\")\n        twirling_std_gate = [gate]\n    elif isinstance(twirling_gate, list):\n        custom_gates = []\n        twirling_std_gate = []\n        for gate in twirling_gate:\n            if isinstance(gate, str):\n                gate = NAME_TO_CLASS.get(gate, None)\n                if gate is None:\n                    raise QiskitError(f\"The specified gate name {twirling_gate} is not supported\")\n                twirling_std_gate.append(gate)\n            else:\n                twirling_gate = getattr(gate, \"_standard_gate\", None)\n\n                if twirling_gate is None:\n                    custom_gates.append(gate)\n                else:\n                    if twirling_gate in NAME_TO_CLASS.values():\n                        twirling_std_gate.append(twirling_gate)\n                    else:\n                        custom_gates.append(gate)\n        if not custom_gates:\n            custom_gates = None\n        if not twirling_std_gate:\n            twirling_std_gate = None\n    elif twirling_gate is not None:\n        std_gate = getattr(twirling_gate, \"_standard_gate\", None)\n        if std_gate is None:\n            twirling_std_gate = None\n            custom_gates = [twirling_gate]\n        else:\n            if std_gate in NAME_TO_CLASS.values():\n                twirling_std_gate = [std_gate]\n            else:\n                twirling_std_gate = None\n                custom_gates = [twirling_gate]\n    else:\n        twirling_std_gate = twirling_gate\n    out_twirls = num_twirls\n    if out_twirls is None:\n        out_twirls = 1\n    new_data = twirl_rs(\n        circuit._data,\n        twirling_std_gate,\n        custom_gates,\n        seed,\n        out_twirls,\n        target,\n    )\n    if num_twirls is not None:\n        out_list = []\n        for circ in new_data:\n            new_circ = QuantumCircuit._from_circuit_data(circ)\n            _copy_metadata(circuit, new_circ, \"alike\")\n            out_list.append(new_circ)\n        return out_list\n    else:\n        out_circ = QuantumCircuit._from_circuit_data(new_data[0])\n        _copy_metadata(circuit, out_circ, \"alike\")\n        return out_circ\n",
    "line_count": 146
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/classical/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\n=======================================================\nClassical expressions (:mod:`qiskit.circuit.classical`)\n=======================================================\n\nThis module contains an exploratory representation of real-time operations on classical values\nduring circuit execution.\n\nCurrently, only simple expressions on bits and registers that result in a Boolean value are\nsupported, and these are only valid for use in the conditions of :meth:`.QuantumCircuit.if_test`\n(:class:`.IfElseOp`) and :meth:`.QuantumCircuit.while_loop` (:class:`.WhileLoopOp`), and in the\ntarget of :meth:`.QuantumCircuit.switch` (:class:`.SwitchCaseOp`).\n\n.. note::\n    This is an exploratory module, and while we will commit to the standard Qiskit deprecation\n    policy within it, please be aware that the module will be deliberately limited in scope at the\n    start, and early versions may not evolve cleanly into the final version.  It is possible that\n    various components of this module will be replaced (subject to deprecations) instead of improved\n    into a new form.\n\n    The type system and expression tree will be expanded over time, and it is possible that the\n    allowed types of some operations may need to change between versions of Qiskit as the classical\n    processing capabilities develop.\n\n.. automodule:: qiskit.circuit.classical.expr\n.. automodule:: qiskit.circuit.classical.types\n\"\"\"\n\nfrom . import types, expr\n",
    "line_count": 42
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/classical/expr/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\n==================================================\nExpressions (:mod:`qiskit.circuit.classical.expr`)\n==================================================\n\nThe necessary components for building expressions are all exported from the\n:mod:`~.qiskit.circuit.classical.expr` namespace within :mod:`qiskit.circuit.classical`, so you can\nchoose whether to use qualified access (for example :class:`.expr.Value`) or import the names you\nneed directly and call them without the prefix.\n\nThere are two pathways for constructing expressions.  The classes that form :ref:`the\nrepresentation of the expression system <circuit-classical-expressions-expr-representation>`\nhave constructors that perform zero type checking; it is up to the caller to ensure that they\nare building valid objects.  For a more user-friendly interface to direct construction, there\nare helper functions associated with most of the classes that do type validation and inference.\nThese are described below, in :ref:`circuit-classical-expressions-expr-construction`.\n\n.. _circuit-classical-expressions-expr-representation:\n\nRepresentation\n==============\n\nThe expression system is based on tree representation.  All nodes in the tree are final\n(uninheritable) instances of the abstract base class:\n\n.. autoclass:: Expr\n\nThese objects are mutable and should not be reused in a different location without a copy.\n\nAll :class:`Expr` instances define a boolean :attr:`~Expr.const` attribute, which indicates\nwhether the expression can be evaluated at compile time. Most expression classes infer this\nduring construction based on the const-ness of their operands.\n\nThe base for dynamic variables is the :class:`Var`, which can be either an arbitrarily typed\nreal-time variable, or a wrapper around a :class:`.Clbit` or :class:`.ClassicalRegister`.\n\n.. autoclass:: Var\n    :members: var, name, new\n\nSimilarly, literals used in expressions (such as integers) should be lifted to :class:`Value` nodes\nwith associated types. A :class:`Value` is always considered a constant expression.\n\n.. autoclass:: Value\n\nStretch variables for use in duration expressions are represented by the :class:`Stretch` node.\n\n.. autoclass:: Stretch\n    :members: var, name, new\n\nThe operations traditionally associated with pre-, post- or infix operators in programming are\nrepresented by the :class:`Unary` and :class:`Binary` nodes as appropriate.  These each take an\noperation type code, which are exposed as enumerations inside each class as :class:`Unary.Op`\nand :class:`Binary.Op` respectively.\n\n.. autoclass:: Unary\n    :members: Op\n    :member-order: bysource\n.. autoclass:: Binary\n    :members: Op\n    :member-order: bysource\n\nBit-like types (unsigned integers) can be indexed by integer types, represented by :class:`Index`.\nThe result is a single bit.  The resulting expression has an associated memory location (and so can\nbe used as an lvalue for :class:`.Store`, etc) if the target is also an lvalue.\n\n.. autoclass:: Index\n\nWhen constructing expressions, one must ensure that the types are valid for the operation.\nAttempts to construct expressions with invalid types will raise a regular Python ``TypeError``.\n\nExpressions in this system are defined to act only on certain sets of types.  However, values\nmay be cast to a suitable supertype in order to satisfy the typing requirements.  In these\ncases, a node in the expression tree is used to represent the promotion.  In all cases where\noperations note that they \"implicitly cast\" or \"coerce\" their arguments, the expression tree\nmust have this node representing the conversion.\n\n.. autoclass:: Cast\n\n\n.. _circuit-classical-expressions-expr-construction:\n\nConstruction\n============\n\nConstructing the tree representation directly is verbose and easy to make a mistake with the\ntyping.  In many cases, much of the typing can be inferred, scalar values can automatically\nbe promoted to :class:`Value` instances, and any required promotions can be resolved into\nsuitable :class:`Cast` nodes.\n\nThe functions and methods described in this section are a more user-friendly way to build the\nexpression tree, while staying close to the internal representation.  All these functions will\nautomatically lift valid Python scalar values into corresponding :class:`Var` or :class:`Value`\nobjects, and will resolve any required implicit casts on your behalf.  If you want to directly use\nsome scalar value as an :class:`Expr` node, you can manually :func:`lift` it yourself.\n\n.. autofunction:: lift\n\nTypically you should create memory-owning :class:`Var` instances by using the\n:meth:`.QuantumCircuit.add_var` method to declare them in some circuit context, since a\n:class:`.QuantumCircuit` will not accept an :class:`Expr` that contains variables that are not\nalready declared in it, since it needs to know how to allocate the storage and how the variable will\nbe initialized.  However, should you want to do this manually, you should use the low-level\n:meth:`Var.new` call to safely generate a named variable for usage.\n\nYou can manually specify casts in cases where the cast is allowed in explicit form, but may be\nlossy (such as the cast of a higher precision :class:`~.types.Uint` to a lower precision one).\n\n.. autofunction:: cast\n\nThere are helper constructor functions for each of the unary operations.\n\n.. autofunction:: bit_not\n.. autofunction:: logic_not\n\nSimilarly, the binary operations and relations have helper functions defined.\n\n.. autofunction:: bit_and\n.. autofunction:: bit_or\n.. autofunction:: bit_xor\n.. autofunction:: logic_and\n.. autofunction:: logic_or\n.. autofunction:: equal\n.. autofunction:: not_equal\n.. autofunction:: less\n.. autofunction:: less_equal\n.. autofunction:: greater\n.. autofunction:: greater_equal\n.. autofunction:: shift_left\n.. autofunction:: shift_right\n.. autofunction:: add\n.. autofunction:: sub\n.. autofunction:: mul\n.. autofunction:: div\n\nYou can index into unsigned integers and bit-likes using another unsigned integer of any width.\nThis includes in storing operations, if the target of the index is writeable.\n\n.. autofunction:: index\n\nQiskit's legacy method for specifying equality conditions for use in conditionals is to use a\ntwo-tuple of a :class:`.Clbit` or :class:`.ClassicalRegister` and an integer.  This represents an\nexact equality condition, and there are no ways to specify any other relations.  The helper function\n:func:`lift_legacy_condition` converts this legacy format into the new expression syntax.\n\n.. autofunction:: lift_legacy_condition\n\nWorking with the expression tree\n================================\n\nA typical consumer of the expression tree wants to recursively walk through the tree, potentially\nstatefully, acting on each node differently depending on its type.  This is naturally a\ndouble-dispatch problem; the logic of 'what is to be done' is likely stateful and users should be\nfree to define their own operations, yet each node defines 'what is being acted on'.  We enable this\ndouble dispatch by providing a base visitor class for the expression tree.\n\n.. autoclass:: ExprVisitor\n    :members:\n    :undoc-members:\n\nConsumers of the expression tree should subclass the visitor, and override the ``visit_*`` methods\nthat they wish to handle.  Any non-overridden methods will call :meth:`~ExprVisitor.visit_generic`,\nwhich unless overridden will raise a ``RuntimeError`` to ensure that you are aware if new nodes\nhave been added to the expression tree that you are not yet handling.\n\nFor the convenience of simple visitors that only need to inspect the variables in an expression and\nnot the general structure, the iterator method :func:`iter_vars` is provided.\n\n.. autofunction:: iter_vars\n\nTo iterator over all variables including stretch variables, the iterator method\n:func:`iter_identifiers` is provided.\n\n.. autofunction:: iter_identifiers\n\nTwo expressions can be compared for direct structural equality by using the built-in Python ``==``\noperator.  In general, though, one might want to compare two expressions slightly more semantically,\nallowing that the :class:`Var` nodes inside them are bound to different memory-location descriptions\nbetween two different circuits.  In this case, one can use :func:`structurally_equivalent` with two\nsuitable \"key\" functions to do the comparison.\n\n.. autofunction:: structurally_equivalent\n\nSome expressions have associated memory locations, and others may be purely temporary.\nYou can use :func:`is_lvalue` to determine whether an expression has an associated memory location.\n\n.. autofunction:: is_lvalue\n\"\"\"\n\n__all__ = [\n    \"Expr\",\n    \"Var\",\n    \"Value\",\n    \"Cast\",\n    \"Unary\",\n    \"Binary\",\n    \"Index\",\n    \"Stretch\",\n    \"ExprVisitor\",\n    \"iter_vars\",\n    \"iter_identifiers\",\n    \"structurally_equivalent\",\n    \"is_lvalue\",\n    \"lift\",\n    \"cast\",\n    \"bit_not\",\n    \"logic_not\",\n    \"bit_and\",\n    \"bit_or\",\n    \"bit_xor\",\n    \"shift_left\",\n    \"shift_right\",\n    \"logic_and\",\n    \"logic_or\",\n    \"equal\",\n    \"not_equal\",\n    \"less\",\n    \"less_equal\",\n    \"greater\",\n    \"greater_equal\",\n    \"index\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"div\",\n    \"lift_legacy_condition\",\n]\n\nfrom .expr import Expr, Var, Value, Cast, Unary, Binary, Index, Stretch\nfrom .visitors import ExprVisitor, iter_vars, iter_identifiers, structurally_equivalent, is_lvalue\nfrom .constructors import (\n    lift,\n    cast,\n    bit_not,\n    logic_not,\n    bit_and,\n    bit_or,\n    bit_xor,\n    logic_and,\n    logic_or,\n    equal,\n    not_equal,\n    less,\n    less_equal,\n    greater,\n    greater_equal,\n    shift_left,\n    shift_right,\n    index,\n    add,\n    sub,\n    mul,\n    div,\n    lift_legacy_condition,\n)\n",
    "line_count": 267
  },
  {
    "filename": "expr.py",
    "path": "qiskit/circuit/classical/expr/expr.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Expression-tree nodes.\"\"\"\n\n\n__all__ = [\n    \"Expr\",\n    \"Var\",\n    \"Stretch\",\n    \"Value\",\n    \"Cast\",\n    \"Unary\",\n    \"Binary\",\n    \"Index\",\n]\n\nimport enum\n\nfrom qiskit._accelerate.circuit.classical.expr import (\n    Expr,\n    Var,\n    Stretch,\n    Value,\n    Cast,\n    Unary,\n    Binary,\n    Index,\n)  # pylint: disable=unused-import\n\n\nclass _UnaryOp(enum.Enum):\n    \"\"\"Enumeration of the opcodes for unary operations.\n\n    The bitwise negation :data:`BIT_NOT` takes a single bit or an unsigned integer of known\n    width, and returns a value of the same type.\n\n    The logical negation :data:`LOGIC_NOT` takes an input that is implicitly coerced to a\n    Boolean, and returns a Boolean.\n    \"\"\"\n\n    # If adding opcodes, remember to add helper constructor functions in `constructors.py`.\n    # The opcode integers should be considered a public interface; they are used by\n    # serialization formats that may transfer data between different versions of Qiskit.\n    #\n    # !!! YOU MUST ALSO UPDATE the underlying Rust enum if you touch this.\n    BIT_NOT = 1\n    \"\"\"Bitwise negation. ``~operand``.\"\"\"\n    LOGIC_NOT = 2\n    \"\"\"Logical negation. ``!operand``.\"\"\"\n\n    def __str__(self):\n        return f\"Unary.{super().__str__()}\"\n\n    def __repr__(self):\n        return f\"Unary.{super().__repr__()}\"\n\n\n# Setting these tricks Sphinx into thinking that this enum is actually\n# defined as an inner class of the Rust pyclass.\n_UnaryOp.__module__ = \"qiskit._accelerate.circuit.classical.expr\"\n_UnaryOp.__name__ = \"Op\"\n_UnaryOp.__qualname__ = \"Unary.Op\"\n\n\nclass _BinaryOp(enum.Enum):\n    \"\"\"Enumeration of the opcodes for binary operations.\n\n    The bitwise operations :data:`BIT_AND`, :data:`BIT_OR` and :data:`BIT_XOR` apply to two\n    operands of the same type, which must be a single bit or an unsigned integer of fixed width.\n    The resultant type is the same as the two input types.\n\n    The logical operations :data:`LOGIC_AND` and :data:`LOGIC_OR` first implicitly coerce their\n    arguments to Booleans, and then apply the logical operation.  The resultant type is always\n    Boolean.\n\n    The binary mathematical relations :data:`EQUAL`, :data:`NOT_EQUAL`, :data:`LESS`,\n    :data:`LESS_EQUAL`, :data:`GREATER` and :data:`GREATER_EQUAL` take unsigned integers\n    (with an implicit cast to make them the same width), and return a Boolean.\n\n    The bitshift operations :data:`SHIFT_LEFT` and :data:`SHIFT_RIGHT` can take bit-like\n    container types (e.g. unsigned integers) as the left operand, and any integer type as the\n    right-hand operand.  In all cases, the output bit width is the same as the input, and zeros\n    fill in the \"exposed\" spaces.\n\n    The binary arithmetic operators :data:`ADD`, :data:`SUB:, :data:`MUL`, and :data:`DIV`\n    can be applied to two floats or two unsigned integers, which should be made to be of\n    the same width during construction via a cast.\n    The :data:`ADD`, :data:`SUB`, and :data:`DIV` operators can be applied on two durations\n    yielding another duration, or a float in the case of :data:`DIV`. The :data:`MUL` operator\n    can also be applied to a duration and a numeric type, yielding another duration. Finally,\n    the :data:`DIV` operator can be used to divide a duration by a numeric type, yielding a\n    duration.\n    \"\"\"\n\n    # If adding opcodes, remember to add helper constructor functions in `constructors.py`\n    # The opcode integers should be considered a public interface; they are used by\n    # serialization formats that may transfer data between different versions of Qiskit.\n    #\n    # !!! YOU MUST ALSO UPDATE the underlying Rust enum if you touch this.\n    BIT_AND = 1\n    \"\"\"Bitwise \"and\". ``lhs & rhs``.\"\"\"\n    BIT_OR = 2\n    \"\"\"Bitwise \"or\". ``lhs | rhs``.\"\"\"\n    BIT_XOR = 3\n    \"\"\"Bitwise \"exclusive or\". ``lhs ^ rhs``.\"\"\"\n    LOGIC_AND = 4\n    \"\"\"Logical \"and\". ``lhs && rhs``.\"\"\"\n    LOGIC_OR = 5\n    \"\"\"Logical \"or\". ``lhs || rhs``.\"\"\"\n    EQUAL = 6\n    \"\"\"Numeric equality. ``lhs == rhs``.\"\"\"\n    NOT_EQUAL = 7\n    \"\"\"Numeric inequality. ``lhs != rhs``.\"\"\"\n    LESS = 8\n    \"\"\"Numeric less than. ``lhs < rhs``.\"\"\"\n    LESS_EQUAL = 9\n    \"\"\"Numeric less than or equal to. ``lhs <= rhs``\"\"\"\n    GREATER = 10\n    \"\"\"Numeric greater than. ``lhs > rhs``.\"\"\"\n    GREATER_EQUAL = 11\n    \"\"\"Numeric greater than or equal to. ``lhs >= rhs``.\"\"\"\n    SHIFT_LEFT = 12\n    \"\"\"Zero-padding bitshift to the left.  ``lhs << rhs``.\"\"\"\n    SHIFT_RIGHT = 13\n    \"\"\"Zero-padding bitshift to the right.  ``lhs >> rhs``.\"\"\"\n    ADD = 14\n    \"\"\"Addition. ``lhs + rhs``.\"\"\"\n    SUB = 15\n    \"\"\"Subtraction. ``lhs - rhs``.\"\"\"\n    MUL = 16\n    \"\"\"Multiplication. ``lhs * rhs``.\"\"\"\n    DIV = 17\n    \"\"\"Division. ``lhs / rhs``.\"\"\"\n\n    def __str__(self):\n        return f\"Binary.{super().__str__()}\"\n\n    def __repr__(self):\n        return f\"Binary.{super().__repr__()}\"\n\n\n# Setting these tricks Sphinx into thinking that this enum is actually\n# defined as an inner class of the Rust pyclass.\n_BinaryOp.__module__ = \"qiskit._accelerate.circuit.classical.expr\"\n_BinaryOp.__name__ = \"Op\"\n_BinaryOp.__qualname__ = \"Binary.Op\"\n",
    "line_count": 157
  },
  {
    "filename": "visitors.py",
    "path": "qiskit/circuit/classical/expr/visitors.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Expression visitors.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"ExprVisitor\",\n    \"iter_vars\",\n    \"iter_identifiers\",\n    \"structurally_equivalent\",\n    \"is_lvalue\",\n]\n\nimport typing\n\nfrom . import expr\n\n_T_co = typing.TypeVar(\"_T_co\", covariant=True)\n\n\nclass ExprVisitor(typing.Generic[_T_co]):\n    \"\"\"Base class for visitors to the :class:`Expr` tree.  Subclasses should override whichever of\n    the ``visit_*`` methods that they are able to handle, and should be organized such that\n    non-existent methods will never be called.\"\"\"\n\n    # The method names are self-explanatory and docstrings would just be noise.\n    # pylint: disable=missing-function-docstring\n\n    __slots__ = ()\n\n    def visit_generic(self, node: expr.Expr, /) -> _T_co:  # pragma: no cover\n        raise RuntimeError(f\"expression visitor {self} has no method to handle expr {node}\")\n\n    def visit_var(self, node: expr.Var, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_stretch(self, node: expr.Stretch, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_value(self, node: expr.Value, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_unary(self, node: expr.Unary, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_binary(self, node: expr.Binary, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_cast(self, node: expr.Cast, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n    def visit_index(self, node: expr.Index, /) -> _T_co:  # pragma: no cover\n        return self.visit_generic(node)\n\n\nclass _VarWalkerImpl(ExprVisitor[typing.Iterable[expr.Var]]):\n    # We don't want docstrings for the inherited visitor methods, which are self-explanatory and\n    # would just be noise.\n    # pylint: disable=missing-function-docstring\n\n    __slots__ = ()\n\n    def visit_var(self, node, /):\n        yield node\n\n    def visit_stretch(self, node, /):\n        # pylint: disable=unused-argument\n        yield from ()\n\n    def visit_value(self, node, /):\n        # pylint: disable=unused-argument\n        yield from ()\n\n    def visit_unary(self, node, /):\n        yield from node.operand.accept(self)\n\n    def visit_binary(self, node, /):\n        yield from node.left.accept(self)\n        yield from node.right.accept(self)\n\n    def visit_cast(self, node, /):\n        yield from node.operand.accept(self)\n\n    def visit_index(self, node, /):\n        yield from node.target.accept(self)\n        yield from node.index.accept(self)\n\n\nclass _IdentWalkerImpl(ExprVisitor[typing.Iterable[typing.Union[expr.Var, expr.Stretch]]]):\n    __slots__ = ()\n\n    def visit_var(self, node, /):\n        yield node\n\n    def visit_stretch(self, node, /):\n        yield node\n\n    def visit_value(self, node, /):\n        yield from ()\n\n    def visit_unary(self, node, /):\n        yield from node.operand.accept(self)\n\n    def visit_binary(self, node, /):\n        yield from node.left.accept(self)\n        yield from node.right.accept(self)\n\n    def visit_cast(self, node, /):\n        yield from node.operand.accept(self)\n\n    def visit_index(self, node, /):\n        yield from node.target.accept(self)\n        yield from node.index.accept(self)\n\n\n_VAR_WALKER = _VarWalkerImpl()\n_IDENT_WALKER = _IdentWalkerImpl()\n\n\ndef iter_vars(node: expr.Expr) -> typing.Iterator[expr.Var]:\n    \"\"\"Get an iterator over the :class:`~.expr.Var` nodes referenced at any level in the given\n    :class:`~.expr.Expr`.\n\n    Examples:\n        Print out the name of each :class:`.ClassicalRegister` encountered::\n\n            from qiskit.circuit import ClassicalRegister\n            from qiskit.circuit.classical import expr\n\n            cr1 = ClassicalRegister(3, \"a\")\n            cr2 = ClassicalRegister(3, \"b\")\n\n            for node in expr.iter_vars(expr.bit_and(expr.bit_not(cr1), cr2)):\n                if isinstance(node.var, ClassicalRegister):\n                    print(node.var.name)\n\n    .. seealso::\n        :func:`iter_identifiers`\n            Get an iterator over all identifier nodes in the expression, including\n            both :class:`~.expr.Var` and :class:`~.expr.Stretch` nodes.\n    \"\"\"\n    yield from node.accept(_VAR_WALKER)\n\n\ndef iter_identifiers(node: expr.Expr) -> typing.Iterator[typing.Union[expr.Var, expr.Stretch]]:\n    \"\"\"Get an iterator over the :class:`~.expr.Var` and :class:`~.expr.Stretch`\n    nodes referenced at any level in the given :class:`~.expr.Expr`.\n\n    Examples:\n        Print out the name of each :class:`.ClassicalRegister` encountered::\n\n            from qiskit.circuit import ClassicalRegister\n            from qiskit.circuit.classical import expr\n\n            cr1 = ClassicalRegister(3, \"a\")\n            cr2 = ClassicalRegister(3, \"b\")\n\n            for node in expr.iter_vars(expr.bit_and(expr.bit_not(cr1), cr2)):\n                if isinstance(node.var, ClassicalRegister):\n                    print(node.var.name)\n\n    .. seealso::\n        :func:`iter_vars`\n            Get an iterator over just the :class:`~.expr.Var` nodes in the expression.\n    \"\"\"\n    yield from node.accept(_IDENT_WALKER)\n\n\nclass _StructuralEquivalenceImpl(ExprVisitor[bool]):\n    # The strategy here is to continue to do regular double dispatch through the visitor format,\n    # since we simply exit out with a ``False`` as soon as the structure of the two trees isn't the\n    # same; we never need to do any sort of \"triple\" dispatch.  To recurse through both trees\n    # simultaneously, we hold a pointer to the \"full\" expression of the other (at the given depth)\n    # in the stack variables of each visit function, and pass the next \"deeper\" pointer via the\n    # `other` state in the class instance.\n\n    __slots__ = (\n        \"self_key\",\n        \"other_key\",\n        \"other\",\n    )\n\n    def __init__(self, other: expr.Expr, self_key, other_key):\n        self.self_key = self_key\n        self.other_key = other_key\n        self.other = other\n\n    def visit_var(self, node, /):\n        if self.other.__class__ is not node.__class__ or self.other.type != node.type:\n            return False\n        if self.self_key is None or (self_var := self.self_key(node.var)) is None:\n            self_var = node.var\n        if self.other_key is None or (other_var := self.other_key(self.other.var)) is None:\n            other_var = self.other.var\n        return self_var == other_var\n\n    def visit_stretch(self, node, /):\n        if self.other.__class__ is not node.__class__:\n            return False\n        return node.var == self.other.var\n\n    def visit_value(self, node, /):\n        return (\n            node.__class__ is self.other.__class__\n            and node.type == self.other.type\n            and node.value == self.other.value\n        )\n\n    def visit_unary(self, node, /):\n        if (\n            self.other.__class__ is not node.__class__\n            or self.other.op is not node.op\n            or self.other.type != node.type\n        ):\n            return False\n        self.other = self.other.operand\n        return node.operand.accept(self)\n\n    def visit_binary(self, node, /):\n        if (\n            self.other.__class__ is not node.__class__\n            or self.other.op is not node.op\n            or self.other.type != node.type\n        ):\n            return False\n        other = self.other\n        self.other = other.left\n        if not node.left.accept(self):\n            return False\n        self.other = other.right\n        return node.right.accept(self)\n\n    def visit_cast(self, node, /):\n        if self.other.__class__ is not node.__class__ or self.other.type != node.type:\n            return False\n        self.other = self.other.operand\n        return node.operand.accept(self)\n\n    def visit_index(self, node, /):\n        if self.other.__class__ is not node.__class__ or self.other.type != node.type:\n            return False\n        other = self.other\n        self.other = other.target\n        if not node.target.accept(self):\n            return False\n        self.other = other.index\n        return node.index.accept(self)\n\n\ndef structurally_equivalent(\n    left: expr.Expr,\n    right: expr.Expr,\n    left_var_key: typing.Callable[[typing.Any], typing.Any] | None = None,\n    right_var_key: typing.Callable[[typing.Any], typing.Any] | None = None,\n) -> bool:\n    \"\"\"Do these two expressions have exactly the same tree structure, up to some key function for\n    the :class:`~.expr.Var` objects?\n\n    In other words, are these two expressions the exact same trees, except we compare the\n    :attr:`.Var.var` fields by calling the appropriate ``*_var_key`` function on them, and comparing\n    that output for equality.  This function does not allow any semantic \"equivalences\" such as\n    asserting that ``a == b`` is equivalent to ``b == a``; the evaluation order of the operands\n    could, in general, cause such a statement to be false (consider hypothetical ``extern``\n    functions that access global state).\n\n    There's no requirements on the key functions, except that their outputs should have general\n    ``__eq__`` methods.  If a key function returns ``None``, the variable will be used verbatim\n    instead.\n\n    Args:\n        left: one of the :class:`~.expr.Expr` nodes.\n        right: the other :class:`~.expr.Expr` node.\n        left_var_key: a callable whose output should be used when comparing :attr:`.Var.var`\n            attributes.  If this argument is ``None`` or its output is ``None`` for a given\n            variable in ``left``, the variable will be used verbatim.\n        right_var_key: same as ``left_var_key``, but used on the variables in ``right`` instead.\n\n    Examples:\n        Comparing two expressions for structural equivalence, with no remapping of the variables.\n        These are different because the different :class:`.Clbit` instances compare differently::\n\n            >>> from qiskit.circuit import Clbit\n            >>> from qiskit.circuit.classical import expr\n            >>> left_bits = [Clbit(), Clbit()]\n            >>> right_bits = [Clbit(), Clbit()]\n            >>> left = expr.logic_and(expr.logic_not(left_bits[0]), left_bits[1])\n            >>> right = expr.logic_and(expr.logic_not(right_bits[0]), right_bits[1])\n            >>> expr.structurally_equivalent(left, right)\n            False\n\n        Comparing the same two expressions, but this time using mapping functions that associate\n        the bits with simple indices::\n\n            >>> left_key = {var: i for i, var in enumerate(left_bits)}.get\n            >>> right_key = {var: i for i, var in enumerate(right_bits)}.get\n            >>> expr.structurally_equivalent(left, right, left_key, right_key)\n            True\n    \"\"\"\n    return left.accept(_StructuralEquivalenceImpl(right, left_var_key, right_var_key))\n\n\nclass _IsLValueImpl(ExprVisitor[bool]):\n    __slots__ = ()\n\n    def visit_var(self, node, /):\n        return True\n\n    def visit_stretch(self, node, /):\n        return False\n\n    def visit_value(self, node, /):\n        return False\n\n    def visit_unary(self, node, /):\n        return False\n\n    def visit_binary(self, node, /):\n        return False\n\n    def visit_cast(self, node, /):\n        return False\n\n    def visit_index(self, node, /):\n        return node.target.accept(self)\n\n\n_IS_LVALUE = _IsLValueImpl()\n\n\ndef is_lvalue(node: expr.Expr, /) -> bool:\n    \"\"\"Return whether this expression can be used in l-value positions, that is, whether it has a\n    well-defined location in memory, such as one that might be writeable.\n\n    Being an l-value is a necessary but not sufficient for this location to be writeable; it is\n    permissible that a larger object containing this memory location may not allow writing from\n    the scope that attempts to write to it.  This would be an access property of the containing\n    program, however, and not an inherent property of the expression system.\n\n    A constant expression is never an lvalue.\n\n    Examples:\n        Literal values are never l-values; there's no memory location associated with (for example)\n        the constant ``1``::\n\n            >>> from qiskit.circuit.classical import expr\n            >>> expr.is_lvalue(expr.lift(2))\n            False\n\n        :class:`~.expr.Var` nodes are always l-values, because they always have some associated\n        memory location::\n\n            >>> from qiskit.circuit.classical import types\n            >>> from qiskit.circuit import Clbit\n            >>> expr.is_lvalue(expr.Var.new(\"a\", types.Bool()))\n            True\n            >>> expr.is_lvalue(expr.lift(Clbit()))\n            True\n\n        Currently there are no unary or binary operations on variables that can produce an l-value\n        expression, but it is likely in the future that some sort of \"indexing\" operation will be\n        added, which could produce l-values::\n\n            >>> a = expr.Var.new(\"a\", types.Uint(8))\n            >>> b = expr.Var.new(\"b\", types.Uint(8))\n            >>> expr.is_lvalue(a) and expr.is_lvalue(b)\n            True\n            >>> expr.is_lvalue(expr.bit_and(a, b))\n            False\n    \"\"\"\n    return node.accept(_IS_LVALUE)\n",
    "line_count": 382
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/classical/types/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\n==============================================\nTyping (:mod:`qiskit.circuit.classical.types`)\n==============================================\n\nRepresentation\n==============\n\nThe type system of the expression tree is exposed through this module.  This is inherently linked to\nthe expression system in the :mod:`~.classical.expr` module, as most expressions can only be\nunderstood with the context of the types that they act on.\n\nAll types inherit from an abstract base class:\n\n.. autoclass:: Type\n\nTypes should be considered immutable objects, and you must not mutate them.  It is permissible to\nreuse a :class:`Type` that you take from another object without copying it, and generally this will\nbe the best approach for performance.  :class:`Type` objects are designed to be small amounts of\ndata, and it's best to point to the same instance of the data where possible rather than\nheap-allocating a new version of the same thing.  Where possible, the class constructors will return\nsingleton instances to facilitate this.\n\nThe :class:`Bool` type represents :class:`.Clbit` and the literals ``True`` and ``False``, the\n:class:`Uint` type represents :class:`.ClassicalRegister` and Python integers, the :class:`Float`\ntype represents Python floats, and the :class:`Duration` type represents a duration for use in\ntiming-aware circuit operations.\n\n.. autoclass:: Bool\n.. autoclass:: Uint\n.. autoclass:: Float\n.. autoclass:: Duration\n\nWorking with types\n==================\n\nThere are some additional functions on these types documented in the subsequent sections. \nThese are mostly expected to be used only in manipulations of the expression tree;\nusers who are building expressions using the\n:ref:`user-facing construction interface <circuit-classical-expressions-expr-construction>` should\nnot need to use these.\n\nPartial ordering of types\n=========================\n\nThe type system is equipped with a partial ordering, where :math:`a < b` is interpreted as\n\":math:`a` is a strict subtype of :math:`b`\".  Note that the partial ordering is a subset of the\ndirected graph that describes the allowed explicit casting operations between types.  The partial\nordering defines when one type may be lossless directly interpreted as another.\n\nThe low-level interface to querying the subtyping relationship is the :func:`order` function.\n\n.. autofunction:: order\n\nThe return value is an enumeration :class:`Ordering` that describes what, if any, subtyping\nrelationship exists between the two types.\n\n.. autoclass:: Ordering\n    :member-order: bysource\n\nSome helper methods are then defined in terms of this low-level :func:`order` primitive:\n\n.. autofunction:: is_subtype\n.. autofunction:: is_supertype\n.. autofunction:: greater\n\n\nCasting between types\n=====================\n\nIt is common to need to cast values of one type to another type.  The casting rules for this are\nembedded into the :mod:`types` module.  You can query the casting kinds using :func:`cast_kind`:\n\n.. autofunction:: cast_kind\n\nThe return values from this function are an enumeration explaining the types of cast that are\nallowed from the left type to the right type.\n\nNote that casts between :class:`Float` and :class:`Uint` are considered dangerous in either\ndirection, and must be done explicitly.\n\n.. autoclass:: CastKind\n\"\"\"\n\n__all__ = [\n    \"Type\",\n    \"Bool\",\n    \"Duration\",\n    \"Float\",\n    \"Uint\",\n    \"Ordering\",\n    \"order\",\n    \"is_subtype\",\n    \"is_supertype\",\n    \"greater\",\n    \"CastKind\",\n    \"cast_kind\",\n]\n\nfrom .types import Type, Bool, Duration, Float, Uint\nfrom .ordering import Ordering, order, is_subtype, is_supertype, greater, CastKind, cast_kind\n",
    "line_count": 114
  },
  {
    "filename": "ordering.py",
    "path": "qiskit/circuit/classical/types/ordering.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Tools for working with the partial ordering of the type system.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"Ordering\",\n    \"is_subtype\",\n    \"is_supertype\",\n    \"order\",\n    \"greater\",\n    \"CastKind\",\n    \"cast_kind\",\n]\n\nimport enum\n\nfrom .types import Type, Bool, Duration, Float, Uint\n\n\n# While the type system is simple, it's overkill to represent the complete partial ordering graph of\n# the set of types in an explicit graph form.  The strategy here is to assume that two types have no\n# ordering between them, and an ordering is defined by putting a function `Type * Type -> Ordering`\n# into the `_ORDERERS`.\n\n\nclass Ordering(enum.Enum):\n    \"\"\"Enumeration listing the possible relations between two types.  Types only have a partial\n    ordering, so it's possible for two types to have no sub-typing relationship.\n\n    Note that the sub-/supertyping relationship is not the same as whether a type can be explicitly\n    cast from one to another.\"\"\"\n\n    LESS = enum.auto()\n    \"\"\"The left type is a strict subtype of the right type.\"\"\"\n    EQUAL = enum.auto()\n    \"\"\"The two types are equal.\"\"\"\n    GREATER = enum.auto()\n    \"\"\"The left type is a strict supertype of the right type.\"\"\"\n    NONE = enum.auto()\n    \"\"\"There is no typing relationship between the two types.\"\"\"\n\n    def __repr__(self):\n        return str(self)\n\n\ndef _order_uint_uint(left: Uint, right: Uint, /) -> Ordering:\n    if left.width < right.width:\n        return Ordering.LESS\n    if left.width == right.width:\n        return Ordering.EQUAL\n    return Ordering.GREATER\n\n\n_ORDERERS = {\n    (Bool, Bool): lambda _a, _b, /: Ordering.EQUAL,\n    (Uint, Uint): _order_uint_uint,\n    (Float, Float): lambda _a, _b, /: Ordering.EQUAL,\n    (Duration, Duration): lambda _a, _b, /: Ordering.EQUAL,\n}\n\n\ndef order(left: Type, right: Type, /) -> Ordering:\n    \"\"\"Get the ordering relationship between the two types as an enumeration value.\n\n    Examples:\n        Compare two :class:`Uint` types of different widths::\n\n            >>> from qiskit.circuit.classical import types\n            >>> types.order(types.Uint(8), types.Uint(16))\n            Ordering.LESS\n\n        Compare two types that have no ordering between them::\n\n            >>> types.order(types.Uint(8), types.Bool())\n            Ordering.NONE\n    \"\"\"\n    if (orderer := _ORDERERS.get((left.kind, right.kind))) is None:\n        return Ordering.NONE\n    return orderer(left, right)\n\n\ndef is_subtype(left: Type, right: Type, /, strict: bool = False) -> bool:\n    r\"\"\"Does the relation :math:`\\text{left} \\le \\text{right}` hold?  If there is no ordering\n    relation between the two types, then this returns ``False``.  If ``strict``, then the equality\n    is also forbidden.\n\n    Examples:\n        Check if one type is a subclass of another::\n\n            >>> from qiskit.circuit.classical import types\n            >>> types.is_subtype(types.Uint(8), types.Uint(16))\n            True\n\n        Check if one type is a strict subclass of another::\n\n            >>> types.is_subtype(types.Bool(), types.Bool())\n            True\n            >>> types.is_subtype(types.Bool(), types.Bool(), strict=True)\n            False\n    \"\"\"\n    order_ = order(left, right)\n    return order_ is Ordering.LESS or (not strict and order_ is Ordering.EQUAL)\n\n\ndef is_supertype(left: Type, right: Type, /, strict: bool = False) -> bool:\n    r\"\"\"Does the relation :math:`\\text{left} \\ge \\text{right}` hold?  If there is no ordering\n    relation between the two types, then this returns ``False``.  If ``strict``, then the equality\n    is also forbidden.\n\n    Examples:\n        Check if one type is a superclass of another::\n\n            >>> from qiskit.circuit.classical import types\n            >>> types.is_supertype(types.Uint(8), types.Uint(16))\n            False\n\n        Check if one type is a strict superclass of another::\n\n            >>> types.is_supertype(types.Bool(), types.Bool())\n            True\n            >>> types.is_supertype(types.Bool(), types.Bool(), strict=True)\n            False\n    \"\"\"\n    order_ = order(left, right)\n    return order_ is Ordering.GREATER or (not strict and order_ is Ordering.EQUAL)\n\n\ndef greater(left: Type, right: Type, /) -> Type:\n    \"\"\"Get the greater of the two types, assuming that there is an ordering relation between them.\n    Technically, this is a slightly restricted version of the concept of the 'meet' of the two\n    types in that the return value must be one of the inputs. In practice in the type system there\n    is no concept of a 'sum' type, so the 'meet' exists if and only if there is an ordering between\n    the two types, and is equal to the greater of the two types.\n\n    Returns:\n        The greater of the two types.\n\n    Raises:\n        TypeError: if there is no ordering relation between the two types.\n\n    Examples:\n        Find the greater of two :class:`Uint` types::\n\n            >>> from qiskit.circuit.classical import types\n            >>> types.greater(types.Uint(8), types.Uint(16))\n            types.Uint(16)\n    \"\"\"\n    order_ = order(left, right)\n    if order_ is Ordering.NONE:\n        raise TypeError(f\"no ordering exists between '{left}' and '{right}'\")\n    return left if order_ is Ordering.GREATER else right\n\n\nclass CastKind(enum.Enum):\n    \"\"\"A return value indicating the type of cast that can occur from one type to another.\"\"\"\n\n    EQUAL = enum.auto()\n    \"\"\"The two types are equal; no cast node is required at all.\"\"\"\n    IMPLICIT = enum.auto()\n    \"\"\"The 'from' type can be cast to the 'to' type implicitly.  A :class:`~.expr.Cast` node with\n    ``implicit==True`` is the minimum required to specify this.\"\"\"\n    LOSSLESS = enum.auto()\n    \"\"\"The 'from' type can be cast to the 'to' type explicitly, and the cast will be lossless.  This\n    requires a :class:`~.expr.Cast`` node with ``implicit=False``, but there's no danger from\n    inserting one.\"\"\"\n    DANGEROUS = enum.auto()\n    \"\"\"The 'from' type has a defined cast to the 'to' type, but depending on the value, it may lose\n    data.  A user would need to manually specify casts.\"\"\"\n    NONE = enum.auto()\n    \"\"\"There is no casting permitted from the 'from' type to the 'to' type.\"\"\"\n\n\ndef _uint_cast(from_: Uint, to_: Uint, /) -> CastKind:\n    if from_.width == to_.width:\n        return CastKind.EQUAL\n    if from_.width < to_.width:\n        return CastKind.LOSSLESS\n    return CastKind.DANGEROUS\n\n\n_ALLOWED_CASTS = {\n    (Bool, Bool): lambda _a, _b, /: CastKind.EQUAL,\n    (Bool, Uint): lambda _a, _b, /: CastKind.LOSSLESS,\n    (Bool, Float): lambda _a, _b, /: CastKind.LOSSLESS,\n    (Uint, Bool): lambda _a, _b, /: CastKind.IMPLICIT,\n    (Uint, Uint): _uint_cast,\n    (Uint, Float): lambda _a, _b, /: CastKind.DANGEROUS,\n    (Float, Float): lambda _a, _b, /: CastKind.EQUAL,\n    (Float, Uint): lambda _a, _b, /: CastKind.DANGEROUS,\n    (Float, Bool): lambda _a, _b, /: CastKind.DANGEROUS,\n    (Duration, Duration): lambda _a, _b, /: CastKind.EQUAL,\n}\n\n\ndef cast_kind(from_: Type, to_: Type, /) -> CastKind:\n    \"\"\"Determine the sort of cast that is required to move from the left type to the right type.\n\n    Examples:\n\n        .. plot::\n           :include-source:\n           :nofigs:\n\n\n            >>> from qiskit.circuit.classical import types\n            >>> types.cast_kind(types.Bool(), types.Bool())\n            <CastKind.EQUAL: 1>\n            >>> types.cast_kind(types.Uint(8), types.Bool())\n            <CastKind.IMPLICIT: 2>\n            >>> types.cast_kind(types.Bool(), types.Uint(8))\n            <CastKind.LOSSLESS: 3>\n            >>> types.cast_kind(types.Uint(16), types.Uint(8))\n            <CastKind.DANGEROUS: 4>\n    \"\"\"\n    if (coercer := _ALLOWED_CASTS.get((from_.kind, to_.kind))) is None:\n        return CastKind.NONE\n    return coercer(from_, to_)\n",
    "line_count": 230
  },
  {
    "filename": "types.py",
    "path": "qiskit/circuit/classical/types/types.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Type-system definition for the expression tree.\"\"\"\n\n\n__all__ = [\n    \"Type\",\n    \"Bool\",\n    \"Duration\",\n    \"Float\",\n    \"Uint\",\n]\n\nfrom qiskit._accelerate.circuit.classical.types import (\n    Type,\n    Bool,\n    Uint,\n    Float,\n    Duration,\n)  # pylint: disable=unused-import\n",
    "line_count": 31
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/controlflow/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Instruction sub-classes for dynamic circuits.\"\"\"\n\n\nfrom ._builder_utils import condition_resources, node_resources, LegacyResources\nfrom .control_flow import ControlFlowOp\nfrom .continue_loop import ContinueLoopOp\nfrom .break_loop import BreakLoopOp\n\nfrom .box import BoxOp\nfrom .if_else import IfElseOp\nfrom .while_loop import WhileLoopOp\nfrom .for_loop import ForLoopOp\nfrom .switch_case import SwitchCaseOp, CASE_DEFAULT\n\n\nCONTROL_FLOW_OP_NAMES = frozenset((\"for_loop\", \"while_loop\", \"if_else\", \"switch_case\", \"box\"))\n\"\"\"Set of the instruction names of Qiskit's known control-flow operations.\"\"\"\n\n\ndef get_control_flow_name_mapping():\n    \"\"\"Return a dictionary mapping the names of control-flow operations\n    to their corresponding classes.\"\n\n    Examples:\n\n        .. code-block:: python\n\n            from qiskit.circuit import get_control_flow_name_mapping\n\n            ctrl_flow_name_map = get_control_flow_name_mapping()\n            if_else_object = ctrl_flow_name_map[\"if_else\"]\n\n            print(if_else_object)\n\n        .. code-block:: text\n\n            <class 'qiskit.circuit.controlflow.if_else.IfElseOp'>\n    \"\"\"\n\n    name_mapping = {\n        \"if_else\": IfElseOp,\n        \"while_loop\": WhileLoopOp,\n        \"for_loop\": ForLoopOp,\n        \"switch_case\": SwitchCaseOp,\n        \"box\": BoxOp,\n    }\n    return name_mapping\n",
    "line_count": 60
  },
  {
    "filename": "_builder_utils.py",
    "path": "qiskit/circuit/controlflow/_builder_utils.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2022.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Private utility functions that are used by the builder interfaces.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Iterable, Tuple, Set, Union, TypeVar, TYPE_CHECKING\n\nfrom qiskit.circuit import (  # pylint: disable=cyclic-import\n    ClassicalRegister,\n    Clbit,\n    QuantumRegister,\n)\nfrom qiskit.circuit.classical import expr, types\nfrom qiskit.circuit.exceptions import CircuitError\n\nif TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit, Register\n\n_ConditionT = TypeVar(\n    \"_ConditionT\", bound=Union[Tuple[ClassicalRegister, int], Tuple[Clbit, int], expr.Expr]\n)\n\n\ndef validate_condition(condition: _ConditionT) -> _ConditionT:\n    \"\"\"Validate that a condition is in a valid format and return it, but raise if it is invalid.\n\n    Args:\n        condition: the condition to be tested for validity.  Must be either the legacy 2-tuple\n            format, or a :class:`~.expr.Expr` that has `Bool` type.\n\n    Raises:\n        CircuitError: if the condition is not in a valid format.\n\n    Returns:\n        The same condition as passed, if it was valid.\n    \"\"\"\n    if isinstance(condition, expr.Expr):\n        if condition.type.kind is not types.Bool:\n            raise CircuitError(\n                \"Classical conditions must be expressions with the type 'Bool()',\"\n                f\" not '{condition.type}'.\"\n            )\n        return condition\n    try:\n        bits, value = condition\n        if isinstance(bits, (ClassicalRegister, Clbit)) and isinstance(value, int):\n            return (bits, value)\n    except (TypeError, ValueError):\n        pass\n    raise CircuitError(\n        \"A classical condition should be a 2-tuple of `(ClassicalRegister | Clbit, int)`,\"\n        f\" but received '{condition!r}'.\"\n    )\n\n\n@dataclasses.dataclass\nclass LegacyResources:\n    \"\"\"A pair of the :class:`.Clbit` and :class:`.ClassicalRegister` resources used by some other\n    object (such as a legacy condition or :class:`.expr.Expr` node).\"\"\"\n\n    clbits: tuple[Clbit, ...]\n    cregs: tuple[ClassicalRegister, ...]\n\n\ndef node_resources(node: expr.Expr) -> LegacyResources:\n    \"\"\"Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\n    referenced by an :class:`~.expr.Expr`.\"\"\"\n    # It's generally convenient for us to ensure that the resources are returned in some\n    # deterministic order.  This uses the ordering of 'dict' objects to fake out an ordered set.\n    clbits = {}\n    cregs = {}\n    for var in expr.iter_vars(node):\n        if isinstance(var.var, Clbit):\n            clbits[var.var] = None\n        elif isinstance(var.var, ClassicalRegister):\n            clbits.update((bit, None) for bit in var.var)\n            cregs[var.var] = None\n    return LegacyResources(tuple(clbits), tuple(cregs))\n\n\ndef condition_resources(\n    condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr\n) -> LegacyResources:\n    \"\"\"Get the legacy classical resources (:class:`.Clbit` and :class:`.ClassicalRegister`)\n    referenced by a legacy condition or an :class:`~.expr.Expr`.\"\"\"\n    if isinstance(condition, expr.Expr):\n        return node_resources(condition)\n    target, _ = condition\n    if isinstance(target, ClassicalRegister):\n        return LegacyResources(tuple(target), (target,))\n    return LegacyResources((target,), ())\n\n\ndef partition_registers(\n    registers: Iterable[Register],\n) -> Tuple[Set[QuantumRegister], Set[ClassicalRegister]]:\n    \"\"\"Partition a sequence of registers into its quantum and classical registers.\"\"\"\n    qregs = set()\n    cregs = set()\n    for register in registers:\n        if isinstance(register, QuantumRegister):\n            qregs.add(register)\n        elif isinstance(register, ClassicalRegister):\n            cregs.add(register)\n        else:\n            # Purely defensive against Terra expansion.\n            raise CircuitError(f\"Unknown register: {register}.\")\n    return qregs, cregs\n\n\ndef unify_circuit_resources(circuits: Iterable[QuantumCircuit]) -> Iterable[QuantumCircuit]:\n    \"\"\"\n    Ensure that all the given ``circuits`` have all the same qubits, clbits and registers, and\n    that they are defined in the same order.  The order is important for binding when the bodies are\n    used in the 3-tuple :obj:`.Instruction` context.\n\n    This function will preferentially try to mutate its inputs if they share an ordering, but if\n    not, it will rebuild two new circuits.  This is to avoid coupling too tightly to the inner\n    class; there is no real support for deleting or re-ordering bits within a :obj:`.QuantumCircuit`\n    context, and we don't want to rely on the *current* behavior of the private APIs, since they\n    are very liable to change.  No matter the method used, circuits with unified bits and registers\n    are returned.\n    \"\"\"\n    circuits = tuple(circuits)\n    if len(circuits) < 2:\n        return circuits\n    qubits = []\n    clbits = []\n    for circuit in circuits:\n        if circuit.qubits[: len(qubits)] != qubits:\n            return _unify_circuit_resources_rebuild(circuits)\n        if circuit.clbits[: len(qubits)] != clbits:\n            return _unify_circuit_resources_rebuild(circuits)\n        if circuit.num_qubits > len(qubits):\n            qubits = list(circuit.qubits)\n        if circuit.num_clbits > len(clbits):\n            clbits = list(circuit.clbits)\n    for circuit in circuits:\n        circuit.add_bits(qubits[circuit.num_qubits :])\n        circuit.add_bits(clbits[circuit.num_clbits :])\n    return _unify_circuit_registers(circuits)\n\n\ndef _unify_circuit_resources_rebuild(  # pylint: disable=invalid-name  # (it's too long?!)\n    circuits: Tuple[QuantumCircuit, ...]\n) -> Tuple[QuantumCircuit, QuantumCircuit]:\n    \"\"\"\n    Ensure that all the given circuits have all the same qubits and clbits, and that they\n    are defined in the same order.  The order is important for binding when the bodies are used in\n    the 3-tuple :obj:`.Instruction` context.\n\n    This function will always rebuild the objects into new :class:`.QuantumCircuit` instances.\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from qiskit.circuit import QuantumCircuit\n\n    qubits, clbits = set(), set()\n    for circuit in circuits:\n        qubits.update(circuit.qubits)\n        clbits.update(circuit.clbits)\n    qubits, clbits = list(qubits), list(clbits)\n\n    # We use the inner `_append` method because everything is already resolved in the builders.\n    out_circuits = []\n    for circuit in circuits:\n        out = QuantumCircuit(\n            qubits,\n            clbits,\n            *circuit.qregs,\n            *circuit.cregs,\n            global_phase=circuit.global_phase,\n            inputs=circuit.iter_input_vars(),\n            captures=circuit.iter_captures(),\n        )\n        for var in circuit.iter_declared_vars():\n            out.add_uninitialized_var(var)\n        for stretch in circuit.iter_declared_stretches():\n            out.add_stretch(stretch)\n        for instruction in circuit.data:\n            out._append(instruction)\n        out_circuits.append(out)\n    return _unify_circuit_registers(out_circuits)\n\n\ndef _unify_circuit_registers(circuits: Iterable[QuantumCircuit]) -> Iterable[QuantumCircuit]:\n    \"\"\"\n    Ensure that ``true_body`` and ``false_body`` have the same registers defined within them.  These\n    do not need to be in the same order between circuits.  The two input circuits are returned,\n    mutated to have the same registers.\n    \"\"\"\n    circuits = tuple(circuits)\n    total_registers = set()\n    for circuit in circuits:\n        total_registers.update(circuit.qregs)\n        total_registers.update(circuit.cregs)\n    for circuit in circuits:\n        for register in total_registers - set(circuit.qregs) - set(circuit.cregs):\n            circuit.add_register(register)\n    return circuits\n",
    "line_count": 212
  },
  {
    "filename": "box.py",
    "path": "qiskit/circuit/controlflow/box.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2025.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Simple box basic block.\"\"\"\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom qiskit.circuit.exceptions import CircuitError\nfrom .control_flow import ControlFlowOp\n\nif typing.TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n\n\nclass BoxOp(ControlFlowOp):\n    \"\"\"A scoped \"box\" of operations on a circuit that are treated atomically in the greater context.\n\n    A \"box\" is a control-flow construct that is entered unconditionally.  The contents of the box\n    behave somewhat as if the start and end of the box were barriers, except it is permissible to\n    commute operations \"all the way\" through the box.  The box is also an explicit scope for the\n    purposes of variables, stretches and compiler passes.\n\n    Typically you create this by using the builder-interface form of :meth:`.QuantumCircuit.box`.\n    \"\"\"\n\n    def __init__(\n        self,\n        body: QuantumCircuit,\n        duration: None = None,\n        unit: typing.Literal[\"dt\", \"s\", \"ms\", \"us\", \"ns\", \"ps\"] = \"dt\",\n        label: str | None = None,\n    ):\n        \"\"\"\n        Default constructor of :class:`BoxOp`.\n\n        Args:\n            body: the circuit to use as the body of the box.  This should explicit close over any\n                :class:`.expr.Var` variables that must be incident from the outer circuit.  The\n                expected number of qubit and clbits for the resulting instruction are inferred from\n                the number in the circuit, even if they are idle.\n            duration: an optional duration for the box as a whole.\n            unit: the unit of the ``duration``.\n            label: an optional string label for the instruction.\n        \"\"\"\n        super().__init__(\"box\", body.num_qubits, body.num_clbits, [body], label=label)\n        self.duration = duration\n        self.unit = unit\n\n    @property\n    def params(self):\n        return self._params\n\n    @params.setter\n    def params(self, parameters):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        (body,) = parameters\n\n        if not isinstance(body, QuantumCircuit):\n            raise CircuitError(\n                \"BoxOp expects a body parameter of type \"\n                f\"QuantumCircuit, but received {type(body)}.\"\n            )\n\n        if body.num_qubits != self.num_qubits or body.num_clbits != self.num_clbits:\n            raise CircuitError(\n                \"Attempted to assign a body parameter with a num_qubits or \"\n                \"num_clbits different than that of the BoxOp. \"\n                f\"BoxOp num_qubits/clbits: {self.num_qubits}/{self.num_clbits} \"\n                f\"Supplied body num_qubits/clbits: {body.num_qubits}/{body.num_clbits}.\"\n            )\n\n        self._params = [body]\n\n    @property\n    def body(self):\n        \"\"\"The ``body`` :class:`.QuantumCircuit` of the operation.\n\n        This is the same as object returned as the sole entry in :meth:`params` and :meth:`blocks`.\n        \"\"\"\n        # Not settable via this property; the only meaningful way to replace a body is via\n        # larger `QuantumCircuit` methods, or using `replace_blocks`.\n        return self.params[0]\n\n    @property\n    def blocks(self):\n        return (self._params[0],)\n\n    def replace_blocks(self, blocks):\n        (body,) = blocks\n        return BoxOp(body, duration=self.duration, unit=self.unit, label=self.label)\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, BoxOp)\n            and self.duration == other.duration\n            and self.unit == other.unit\n            and super().__eq__(other)\n        )\n\n\nclass BoxContext:\n    \"\"\"Context-manager that powers :meth:`.QuantumCircuit.box`.\n\n    This is not part of the public interface, and should not be instantiated by users.\n    \"\"\"\n\n    __slots__ = (\"_circuit\", \"_duration\", \"_unit\", \"_label\")\n\n    def __init__(\n        self,\n        circuit: QuantumCircuit,\n        *,\n        duration: None = None,\n        unit: typing.Literal[\"dt\", \"s\", \"ms\", \"us\", \"ns\", \"ps\"] = \"dt\",\n        label: str | None = None,\n    ):\n        \"\"\"\n        Args:\n            circuit: the outermost scope of the circuit under construction.\n            duration: the final duration of the box.\n            unit: the unit of ``duration``.\n            label: an optional label for the box.\n        \"\"\"\n        self._circuit = circuit\n        self._duration = duration\n        self._unit = unit\n        self._label = label\n\n    def __enter__(self):\n        # For a box to have the semantics of internal qubit alignment with a resolvable duration, we\n        # can't allow conditional jumps to exit it.  Technically an unconditional `break` or\n        # `continue` could work, but we're not getting into that.\n        self._circuit._push_scope(allow_jumps=False)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            # If we're leaving the context manager because an exception was raised, there's nothing\n            # to do except restore the circuit state.\n            self._circuit._pop_scope()\n            return False\n        scope = self._circuit._pop_scope()\n        # Boxes do not need to pass any further resources in, because there's no jumps out of a\n        # `box` permitted.\n        body = scope.build(scope.qubits(), scope.clbits())\n        self._circuit.append(\n            BoxOp(body, duration=self._duration, unit=self._unit, label=self._label),\n            body.qubits,\n            body.clbits,\n        )\n        return False\n",
    "line_count": 164
  },
  {
    "filename": "break_loop.py",
    "path": "qiskit/circuit/controlflow/break_loop.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"Circuit operation representing a ``break`` from a loop.\"\n\nfrom typing import Optional\n\nfrom qiskit.circuit.instruction import Instruction\nfrom .builder import InstructionPlaceholder, InstructionResources\n\n\nclass BreakLoopOp(Instruction):\n    \"\"\"A circuit operation which, when encountered, jumps to the end of the nearest enclosing loop.\n    Can only be used inside loops.\n    \"\"\"\n\n    def __init__(self, num_qubits: int, num_clbits: int, label: Optional[str] = None):\n        \"\"\"\n        Args:\n            num_qubits: the number of qubits this affects.\n            num_clbits: the number of qubits this affects.\n            label: an optional string label for the instruction.\n        \"\"\"\n        super().__init__(\"break_loop\", num_qubits, num_clbits, [], label=label)\n\n\nclass BreakLoopPlaceholder(InstructionPlaceholder):\n    \"\"\"A placeholder instruction for use in control-flow context managers, when the number of qubits\n    and clbits is not yet known.\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    def __init__(self, *, label: Optional[str] = None):\n        super().__init__(\"break_loop\", 0, 0, [], label=label)\n\n    def concrete_instruction(self, qubits, clbits):\n        return (\n            BreakLoopOp(len(qubits), len(clbits), label=self.label),\n            InstructionResources(qubits=tuple(qubits), clbits=tuple(clbits)),\n        )\n\n    def placeholder_resources(self):\n        return InstructionResources()\n",
    "line_count": 57
  },
  {
    "filename": "continue_loop.py",
    "path": "qiskit/circuit/controlflow/continue_loop.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"Circuit operation representing a ``continue`` from a loop.\"\n\nfrom typing import Optional\n\nfrom qiskit.circuit.instruction import Instruction\nfrom .builder import InstructionPlaceholder, InstructionResources\n\n\nclass ContinueLoopOp(Instruction):\n    \"\"\"A circuit operation which, when encountered, moves to the next iteration of the nearest\n    enclosing loop.  Can only be used inside loops.\n    \"\"\"\n\n    def __init__(self, num_qubits: int, num_clbits: int, label: Optional[str] = None):\n        \"\"\"\n        Args:\n            num_qubits: the number of qubits this affects.\n            num_clbits: the number of qubits this affects.\n            label: an optional string label for the instruction.\n        \"\"\"\n        super().__init__(\"continue_loop\", num_qubits, num_clbits, [], label=label)\n\n\nclass ContinueLoopPlaceholder(InstructionPlaceholder):\n    \"\"\"A placeholder instruction for use in control-flow context managers, when the number of qubits\n    and clbits is not yet known.\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    def __init__(self, *, label: Optional[str] = None):\n        super().__init__(\"continue_loop\", 0, 0, [], label=label)\n\n    def concrete_instruction(self, qubits, clbits):\n        return (\n            ContinueLoopOp(len(qubits), len(clbits), label=self.label),\n            InstructionResources(qubits=tuple(qubits), clbits=tuple(clbits)),\n        )\n\n    def placeholder_resources(self):\n        return InstructionResources()\n",
    "line_count": 57
  },
  {
    "filename": "control_flow.py",
    "path": "qiskit/circuit/controlflow/control_flow.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"Container to encapsulate all control flow operations.\"\n\nfrom __future__ import annotations\n\nimport typing\nfrom abc import ABC, abstractmethod\n\nfrom qiskit.circuit.instruction import Instruction\nfrom qiskit.circuit.exceptions import CircuitError\n\nif typing.TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n    from qiskit.circuit.classical import expr\n\n\nclass ControlFlowOp(Instruction, ABC):\n    \"\"\"Abstract class to encapsulate all control flow operations.\n\n    All subclasses of :class:`ControlFlowOp` have an internal attribute,\n    :attr:`~ControlFlowOp.blocks`, which exposes the inner subcircuits used in the different blocks\n    of the control flow.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        for block in self.blocks:\n            if block.num_input_vars:\n                raise CircuitError(\"control-flow blocks cannot contain input variables\")\n\n    @property\n    @abstractmethod\n    def blocks(self) -> tuple[QuantumCircuit, ...]:\n        \"\"\"Tuple of :class:`.QuantumCircuit`\\\\ s which may be executed as part of the\n        execution of this :class:`ControlFlowOp`.\"\"\"\n\n    @abstractmethod\n    def replace_blocks(self, blocks: typing.Iterable[QuantumCircuit]) -> ControlFlowOp:\n        \"\"\"Return a new version of this control-flow operations with the :attr:`blocks` mapped to\n        the given new ones.\n\n        Typically this is used in a workflow such as::\n\n            existing_op = ...\n\n            def map_block(block: QuantumCircuit) -> QuantumCircuit:\n                new_block = block.copy_empty_like()\n                # ... do something to `new_block` ...\n                return new_block\n\n            new_op = existing_op.replace_blocks(\n                map_block(block) for block in existing_op.blocks\n            )\n\n        It is the caller's responsibility to ensure that the mapped blocks are defined over a\n        unified set of circuit resources, much like constructing a :class:`ControlFlowOp` using its\n        default constructor.\n\n        Args:\n            blocks: the new subcircuit blocks to use.\n\n        Returns:\n            New :class:`ControlFlowOp` with replaced blocks.\n        \"\"\"\n\n    def iter_captured_vars(self) -> typing.Iterable[expr.Var]:\n        \"\"\"Get an iterator over the unique captured variables in all blocks of this construct.\"\"\"\n        seen = set()\n        for block in self.blocks:\n            for var in block.iter_captured_vars():\n                if var not in seen:\n                    seen.add(var)\n                    yield var\n\n    def iter_captured_stretches(self) -> typing.Iterable[expr.Stretch]:\n        \"\"\"Get an iterator over the unique captured stretch variables in all blocks of this\n        construct.\"\"\"\n        seen = set()\n        for block in self.blocks:\n            for stretch in block.iter_captured_stretches():\n                if stretch not in seen:\n                    seen.add(stretch)\n                    yield stretch\n",
    "line_count": 95
  },
  {
    "filename": "for_loop.py",
    "path": "qiskit/circuit/controlflow/for_loop.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Circuit operation representing a ``for`` loop.\"\"\"\n\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import Iterable, Optional, Union, TYPE_CHECKING\n\nfrom qiskit.circuit.parameter import Parameter\nfrom qiskit.circuit.exceptions import CircuitError\nfrom .control_flow import ControlFlowOp\n\nif TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n\n\nclass ForLoopOp(ControlFlowOp):\n    \"\"\"A circuit operation which repeatedly executes a subcircuit\n    (``body``) parameterized by a parameter ``loop_parameter`` through\n    the set of integer values provided in ``indexset``.\n    \"\"\"\n\n    def __init__(\n        self,\n        indexset: Iterable[int],\n        loop_parameter: Union[Parameter, None],\n        body: QuantumCircuit,\n        label: Optional[str] = None,\n    ):\n        \"\"\"\n        Args:\n            indexset: A collection of integers to loop over.\n            loop_parameter: The placeholder parameterizing ``body`` to which\n                the values from ``indexset`` will be assigned.\n            body: The loop body to be repeatedly executed.\n            label: An optional label for identifying the instruction.\n        \"\"\"\n        num_qubits = body.num_qubits\n        num_clbits = body.num_clbits\n        super().__init__(\n            \"for_loop\", num_qubits, num_clbits, [indexset, loop_parameter, body], label=label\n        )\n\n    @property\n    def params(self):\n        return self._params\n\n    @params.setter\n    def params(self, parameters):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        indexset, loop_parameter, body = parameters\n\n        if not isinstance(loop_parameter, (Parameter, type(None))):\n            raise CircuitError(\n                \"ForLoopOp expects a loop_parameter parameter to \"\n                \"be either of type Parameter or None, but received \"\n                f\"{type(loop_parameter)}.\"\n            )\n\n        if not isinstance(body, QuantumCircuit):\n            raise CircuitError(\n                \"ForLoopOp expects a body parameter to be of type \"\n                f\"QuantumCircuit, but received {type(body)}.\"\n            )\n\n        if body.num_qubits != self.num_qubits or body.num_clbits != self.num_clbits:\n            raise CircuitError(\n                \"Attempted to assign a body parameter with a num_qubits or \"\n                \"num_clbits different than that of the ForLoopOp. \"\n                f\"ForLoopOp num_qubits/clbits: {self.num_qubits}/{self.num_clbits} \"\n                f\"Supplied body num_qubits/clbits: {body.num_qubits}/{body.num_clbits}.\"\n            )\n\n        if (\n            loop_parameter is not None\n            and loop_parameter not in body.parameters\n            and loop_parameter.name in (p.name for p in body.parameters)\n        ):\n            warnings.warn(\n                \"The Parameter provided as a loop_parameter was not found \"\n                \"on the loop body and so no binding of the indexset to loop \"\n                \"parameter will occur. A different Parameter of the same name \"\n                f\"({loop_parameter.name}) was found. If you intended to loop \"\n                \"over that Parameter, please use that Parameter instance as \"\n                \"the loop_parameter.\",\n                stacklevel=2,\n            )\n\n        # Consume indexset into a tuple unless it was provided as a range.\n        # Preserve ranges so that they can be exported as OpenQASM 3 ranges.\n        indexset = indexset if isinstance(indexset, range) else tuple(indexset)\n\n        self._params = [indexset, loop_parameter, body]\n\n    @property\n    def blocks(self):\n        return (self._params[2],)\n\n    def replace_blocks(self, blocks):\n        (body,) = blocks\n        return ForLoopOp(self.params[0], self.params[1], body, label=self.label)\n\n\nclass ForLoopContext:\n    \"\"\"A context manager for building up ``for`` loops onto circuits in a natural order, without\n    having to construct the loop body first.\n\n    Within the block, a lot of the bookkeeping is done for you; you do not need to keep track of\n    which qubits and clbits you are using, for example, and a loop parameter will be allocated for\n    you, if you do not supply one yourself.  All normal methods of accessing the qubits on the\n    underlying :obj:`~QuantumCircuit` will work correctly, and resolve into correct accesses within\n    the interior block.\n\n    You generally should never need to instantiate this object directly.  Instead, use\n    :obj:`.QuantumCircuit.for_loop` in its context-manager form, i.e. by not supplying a ``body`` or\n    sets of qubits and clbits.\n\n    Example usage::\n\n        import math\n        from qiskit import QuantumCircuit\n        qc = QuantumCircuit(2, 1)\n\n        with qc.for_loop(range(5)) as i:\n            qc.rx(i * math.pi/4, 0)\n            qc.cx(0, 1)\n            qc.measure(0, 0)\n            with qc.if_test((0, True)):\n                qc.break_loop()\n\n    This context should almost invariably be created by a :meth:`.QuantumCircuit.for_loop` call, and\n    the resulting instance is a \"friend\" of the calling circuit.  The context will manipulate the\n    circuit's defined scopes when it is entered (by pushing a new scope onto the stack) and exited\n    (by popping its scope, building it, and appending the resulting :obj:`.ForLoopOp`).\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    # Class-level variable keep track of the number of auto-generated loop variables, so we don't\n    # get naming clashes.\n    _generated_loop_parameters = 0\n\n    __slots__ = (\n        \"_circuit\",\n        \"_generate_loop_parameter\",\n        \"_loop_parameter\",\n        \"_indexset\",\n        \"_label\",\n        \"_used\",\n    )\n\n    def __init__(\n        self,\n        circuit: QuantumCircuit,\n        indexset: Iterable[int],\n        loop_parameter: Optional[Parameter] = None,\n        *,\n        label: Optional[str] = None,\n    ):\n        self._circuit = circuit\n        self._generate_loop_parameter = loop_parameter is None\n        self._loop_parameter = loop_parameter\n        # We can pass through `range` instances because OpenQASM 3 has native support for this type\n        # of iterator set.\n        self._indexset = indexset if isinstance(indexset, range) else tuple(indexset)\n        self._label = label\n        self._used = False\n\n    def __enter__(self):\n        if self._used:\n            raise CircuitError(\"A for-loop context manager cannot be re-entered.\")\n        self._used = True\n        self._circuit._push_scope()\n        if self._generate_loop_parameter:\n            self._loop_parameter = Parameter(f\"_loop_i_{self._generated_loop_parameters}\")\n            type(self)._generated_loop_parameters += 1\n        return self._loop_parameter\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            # If we're leaving the context manager because an exception was raised, there's nothing\n            # to do except restore the circuit state.\n            self._circuit._pop_scope()\n            return False\n        scope = self._circuit._pop_scope()\n        # Loops do not need to pass any further resources in, because this scope itself defines the\n        # extent of ``break`` and ``continue`` statements.\n        body = scope.build(scope.qubits(), scope.clbits())\n        # We always bind the loop parameter if the user gave it to us, even if it isn't actually\n        # used, because they requested we do that by giving us a parameter.  However, if they asked\n        # us to auto-generate a parameter, then we only add it if they actually used it, to avoid\n        # using unnecessary resources.\n        if self._generate_loop_parameter and self._loop_parameter not in body.parameters:\n            loop_parameter = None\n        else:\n            loop_parameter = self._loop_parameter\n        self._circuit.append(\n            ForLoopOp(self._indexset, loop_parameter, body, label=self._label),\n            tuple(body.qubits),\n            tuple(body.clbits),\n        )\n        return False\n",
    "line_count": 219
  },
  {
    "filename": "if_else.py",
    "path": "qiskit/circuit/controlflow/if_else.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Circuit operation representing an ``if/else`` statement.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union, Iterable, TYPE_CHECKING\nimport itertools\n\nfrom qiskit.circuit import ClassicalRegister, Clbit  # pylint: disable=cyclic-import\nfrom qiskit.circuit.classical import expr\nfrom qiskit.circuit.instructionset import InstructionSet\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .builder import ControlFlowBuilderBlock, InstructionPlaceholder, InstructionResources\nfrom .control_flow import ControlFlowOp\nfrom ._builder_utils import (\n    partition_registers,\n    unify_circuit_resources,\n    validate_condition,\n    condition_resources,\n)\n\nif TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n\n\n# This is just an indication of what's actually meant to be the public API.\n__all__ = (\"IfElseOp\",)\n\n\nclass IfElseOp(ControlFlowOp):\n    \"\"\"A circuit operation which executes a program (``true_body``) if a\n    provided condition (``condition``) evaluates to true, and\n    optionally evaluates another program (``false_body``) otherwise.\n\n    If provided, ``false_body`` must be of the same ``num_qubits`` and\n    ``num_clbits`` as ``true_body``.\n\n    The classical bits used in ``condition`` must be a subset of those attached\n    to the circuit on which this ``IfElseOp`` will be appended.\n    \"\"\"\n\n    def __init__(\n        self,\n        condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr,\n        true_body: QuantumCircuit,\n        false_body: QuantumCircuit | None = None,\n        label: str | None = None,\n    ):\n        \"\"\"\n        Args:\n            condition: A condition to be evaluated in real time during circuit execution which,\n                if true, will trigger the evaluation of ``true_body``. Can be\n                specified as either a tuple of a ``ClassicalRegister`` to be\n                tested for equality with a given ``int``, or as a tuple of a\n                ``Clbit`` to be compared to either a ``bool`` or an ``int``.\n            true_body: A program to be executed if ``condition`` evaluates\n                to true.\n            false_body: A optional program to be executed if ``condition``\n                evaluates to false.\n            label: An optional label for identifying the instruction.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        # Type checking generally left to @params.setter, but required here for\n        # finding num_qubits and num_clbits.\n        if not isinstance(true_body, QuantumCircuit):\n            raise CircuitError(\n                \"IfElseOp expects a true_body parameter \"\n                f\"of type QuantumCircuit, but received {type(true_body)}.\"\n            )\n\n        num_qubits = true_body.num_qubits\n        num_clbits = true_body.num_clbits\n\n        super().__init__(\"if_else\", num_qubits, num_clbits, [true_body, false_body], label=label)\n\n        self._condition = validate_condition(condition)\n\n    @property\n    def params(self):\n        return self._params\n\n    @property\n    def condition(self):\n        \"\"\"The condition for the if else operation.\"\"\"\n        return self._condition\n\n    @condition.setter\n    def condition(self, value):\n        self._condition = value\n\n    @params.setter\n    def params(self, parameters):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        true_body, false_body = parameters\n\n        if not isinstance(true_body, QuantumCircuit):\n            raise CircuitError(\n                \"IfElseOp expects a true_body parameter of type \"\n                f\"QuantumCircuit, but received {type(true_body)}.\"\n            )\n\n        if true_body.num_qubits != self.num_qubits or true_body.num_clbits != self.num_clbits:\n            raise CircuitError(\n                \"Attempted to assign a true_body parameter with a num_qubits or \"\n                \"num_clbits different than that of the IfElseOp. \"\n                f\"IfElseOp num_qubits/clbits: {self.num_qubits}/{self.num_clbits} \"\n                f\"Supplied body num_qubits/clbits: {true_body.num_qubits}/{true_body.num_clbits}.\"\n            )\n\n        if false_body is not None:\n            if not isinstance(false_body, QuantumCircuit):\n                raise CircuitError(\n                    \"IfElseOp expects a false_body parameter of type \"\n                    f\"QuantumCircuit, but received {type(false_body)}.\"\n                )\n\n            if false_body.num_qubits != self.num_qubits or false_body.num_clbits != self.num_clbits:\n                raise CircuitError(\n                    \"Attempted to assign a false_body parameter with a num_qubits or \"\n                    \"num_clbits different than that of the IfElseOp. \"\n                    f\"IfElseOp num_qubits/clbits: {self.num_qubits}/{self.num_clbits} \"\n                    f\"Supplied body num_qubits/clbits: {false_body.num_qubits}/{false_body.num_clbits}.\"\n                )\n\n        self._params = [true_body, false_body]\n\n    @property\n    def blocks(self):\n        if self.params[1] is None:\n            return (self.params[0],)\n        else:\n            return (self.params[0], self.params[1])\n\n    def replace_blocks(self, blocks: Iterable[QuantumCircuit]) -> \"IfElseOp\":\n        \"\"\"Replace blocks and return new instruction.\n\n        Args:\n            blocks: Iterable of circuits for \"if\" and \"else\" condition. If there is no \"else\"\n                circuit it may be set to None or omitted.\n\n        Returns:\n            New IfElseOp with replaced blocks.\n        \"\"\"\n\n        true_body, false_body = (\n            ablock for ablock, _ in itertools.zip_longest(blocks, range(2), fillvalue=None)\n        )\n        return IfElseOp(self._condition, true_body, false_body=false_body, label=self.label)\n\n\nclass IfElsePlaceholder(InstructionPlaceholder):\n    \"\"\"A placeholder instruction to use in control-flow context managers, when calculating the\n    number of resources this instruction should block is deferred until the construction of the\n    outer loop.\n\n    This generally should not be instantiated manually; only :obj:`.IfContext` and\n    :obj:`.ElseContext` should do it when they need to defer creation of the concrete instruction.\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    def __init__(\n        self,\n        condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr,\n        true_block: ControlFlowBuilderBlock,\n        false_block: ControlFlowBuilderBlock | None = None,\n        *,\n        label: Optional[str] = None,\n    ):\n        \"\"\"\n        Args:\n            condition: the condition to execute the true block on.  This has the same semantics as\n                the ``condition`` argument to :obj:`.IfElseOp`.\n            true_block: the unbuilt scope block that will become the \"true\" branch at creation time.\n            false_block: if given, the unbuilt scope block that will become the \"false\" branch at\n                creation time.\n            label: the label to give the operator when it is created.\n        \"\"\"\n        # These are protected names because we're not trying to clash with parent attributes.\n        self.__true_block = true_block\n        self.__false_block: Optional[ControlFlowBuilderBlock] = false_block\n        self.__resources = self._calculate_placeholder_resources()\n        super().__init__(\n            \"if_else\", len(self.__resources.qubits), len(self.__resources.clbits), [], label=label\n        )\n        # Set the condition after super().__init__() has initialized it to None.\n        self._condition = validate_condition(condition)\n\n    def with_false_block(self, false_block: ControlFlowBuilderBlock) -> \"IfElsePlaceholder\":\n        \"\"\"Return a new placeholder instruction, with the false block set to the given value,\n        updating the bits used by both it and the true body, if necessary.\n\n        It is an error to try and set the false block on a placeholder that already has one.\n\n        Args:\n            false_block: The (unbuilt) instruction scope to set the false body to.\n\n        Returns:\n            A new placeholder, with ``false_block`` set to the given input, and both true and false\n            blocks expanded to account for all resources.\n\n        Raises:\n            CircuitError: if the false block of this placeholder instruction is already set.\n        \"\"\"\n        if self.__false_block is not None:\n            raise CircuitError(f\"false block is already set to {self.__false_block}\")\n        true_block = self.__true_block.copy()\n        true_bits = true_block.qubits() | true_block.clbits()\n        false_bits = false_block.qubits() | false_block.clbits()\n        true_block.add_bits(false_bits - true_bits)\n        false_block.add_bits(true_bits - false_bits)\n        return type(self)(self._condition, true_block, false_block, label=self.label)\n\n    def registers(self):\n        \"\"\"Get the registers used by the interior blocks.\"\"\"\n        if self.__false_block is None:\n            return self.__true_block.registers.copy()\n        return self.__true_block.registers | self.__false_block.registers\n\n    def _calculate_placeholder_resources(self) -> InstructionResources:\n        \"\"\"Get the placeholder resources (see :meth:`.placeholder_resources`).\n\n        This is a separate function because we use the resources during the initialization to\n        determine how we should set our ``num_qubits`` and ``num_clbits``, so we implement the\n        public version as a cache access for efficiency.\n        \"\"\"\n        if self.__false_block is None:\n            qregs, cregs = partition_registers(self.__true_block.registers)\n            return InstructionResources(\n                qubits=tuple(self.__true_block.qubits()),\n                clbits=tuple(self.__true_block.clbits()),\n                qregs=tuple(qregs),\n                cregs=tuple(cregs),\n            )\n        true_qregs, true_cregs = partition_registers(self.__true_block.registers)\n        false_qregs, false_cregs = partition_registers(self.__false_block.registers)\n        return InstructionResources(\n            qubits=tuple(self.__true_block.qubits() | self.__false_block.qubits()),\n            clbits=tuple(self.__true_block.clbits() | self.__false_block.clbits()),\n            qregs=tuple(true_qregs) + tuple(false_qregs),\n            cregs=tuple(true_cregs) + tuple(false_cregs),\n        )\n\n    def placeholder_resources(self):\n        # All the elements of our InstructionResources are immutable (tuple, Bit and Register).\n        return self.__resources\n\n    def concrete_instruction(self, qubits, clbits):\n        current_qubits = self.__true_block.qubits()\n        current_clbits = self.__true_block.clbits()\n        if self.__false_block is not None:\n            current_qubits = current_qubits | self.__false_block.qubits()\n            current_clbits = current_clbits | self.__false_block.clbits()\n        all_bits = qubits | clbits\n        current_bits = current_qubits | current_clbits\n        if current_bits - all_bits:\n            # This _shouldn't_ trigger if the context managers are being used correctly, but is here\n            # to make any potential logic errors noisy.\n            raise CircuitError(\n                \"This block contains bits that are not in the operands sets:\"\n                f\" {current_bits - all_bits!r}\"\n            )\n        true_body = self.__true_block.build(qubits, clbits)\n        if self.__false_block is None:\n            false_body = None\n        else:\n            # The bodies are not compelled to use all the resources that the\n            # ControlFlowBuilderBlock.build calls get passed, but they do need to be as wide as each\n            # other.  Now we ensure that they are.\n            true_body, false_body = unify_circuit_resources(\n                (true_body, self.__false_block.build(qubits, clbits))\n            )\n        return (\n            IfElseOp(self._condition, true_body, false_body, label=self.label),\n            InstructionResources(\n                qubits=tuple(true_body.qubits),\n                clbits=tuple(true_body.clbits),\n                qregs=tuple(true_body.qregs),\n                cregs=tuple(true_body.cregs),\n            ),\n        )\n\n\nclass IfContext:\n    \"\"\"A context manager for building up ``if`` statements onto circuits in a natural order, without\n    having to construct the statement body first.\n\n    The return value of this context manager can be used immediately following the block to create\n    an attached ``else`` statement.\n\n    This context should almost invariably be created by a :meth:`.QuantumCircuit.if_test` call, and\n    the resulting instance is a \"friend\" of the calling circuit.  The context will manipulate the\n    circuit's defined scopes when it is entered (by pushing a new scope onto the stack) and exited\n    (by popping its scope, building it, and appending the resulting :obj:`.IfElseOp`).\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    __slots__ = (\"_appended_instructions\", \"_circuit\", \"_condition\", \"_in_loop\", \"_label\")\n\n    def __init__(\n        self,\n        circuit: QuantumCircuit,\n        condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr,\n        *,\n        in_loop: bool,\n        label: str | None = None,\n    ):\n        self._circuit = circuit\n        self._condition = validate_condition(condition)\n        self._label = label\n        self._appended_instructions = None\n        self._in_loop = in_loop\n\n    # Only expose the necessary public interface, and make it read-only.  If Python had friend\n    # classes, or a \"protected\" access modifier, that's what we'd use (since these are only\n    # necessary for ElseContext), but alas.\n\n    @property\n    def circuit(self) -> QuantumCircuit:\n        \"\"\"Get the circuit that this context manager is attached to.\"\"\"\n        return self._circuit\n\n    @property\n    def condition(self) -> tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr:\n        \"\"\"Get the expression that this statement is conditioned on.\"\"\"\n        return self._condition\n\n    @property\n    def appended_instructions(self) -> Union[InstructionSet, None]:\n        \"\"\"Get the instruction set that was created when this block finished.  If the block has not\n        yet finished, then this will be ``None``.\"\"\"\n        return self._appended_instructions\n\n    @property\n    def in_loop(self) -> bool:\n        \"\"\"Whether this context manager is enclosed within a loop.\"\"\"\n        return self._in_loop\n\n    def __enter__(self):\n        resources = condition_resources(self._condition)\n        self._circuit._push_scope(\n            clbits=resources.clbits,\n            registers=resources.cregs,\n            allow_jumps=self._in_loop,\n        )\n        return ElseContext(self)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            # If we're leaving the context manager because an exception was raised, there's nothing\n            # to do except restore the circuit state.\n            self._circuit._pop_scope()\n            return False\n        true_block = self._circuit._pop_scope()\n        if self._in_loop:\n            # It's possible that we don't actually have any placeholder instructions in our scope,\n            # but we still need to emit a placeholder instruction here in case we get an ``else``\n            # attached which _does_ gain them.  We emit a placeholder to defer defining the\n            # resources we use until the containing loop concludes, to support ``break``.\n            operation = IfElsePlaceholder(self._condition, true_block, label=self._label)\n            resources = operation.placeholder_resources()\n            self._appended_instructions = self._circuit.append(\n                operation, resources.qubits, resources.clbits\n            )\n        else:\n            # If we're not in a loop, we don't need to be worried about passing in any outer-scope\n            # resources because there can't be anything that will consume them.\n            true_body = true_block.build(true_block.qubits(), true_block.clbits())\n            self._appended_instructions = self._circuit.append(\n                IfElseOp(self._condition, true_body=true_body, false_body=None, label=self._label),\n                tuple(true_body.qubits),\n                tuple(true_body.clbits),\n            )\n        return False\n\n\nclass ElseContext:\n    \"\"\"A context manager for building up an ``else`` statements onto circuits in a natural order,\n    without having to construct the statement body first.\n\n    Instances of this context manager should only ever be gained as the output of the\n    :obj:`.IfContext` manager, so they know what they refer to.  Instances of this context are\n    \"friends\" of the circuit that created the :obj:`.IfContext` that in turn created this object.\n    The context will manipulate the circuit's defined scopes when it is entered (by popping the old\n    :obj:`.IfElseOp` if it exists and pushing a new scope onto the stack) and exited (by popping its\n    scope, building it, and appending the resulting :obj:`.IfElseOp`).\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    __slots__ = (\"_if_instruction\", \"_if_registers\", \"_if_context\", \"_used\")\n\n    def __init__(self, if_context: IfContext):\n        # We want to avoid doing any processing until we're actually used, because the `if` block\n        # likely isn't finished yet, and we want to have as small a penalty a possible if you don't\n        # use an `else` branch.\n        self._if_instruction = None\n        self._if_registers = None\n        self._if_context = if_context\n        self._used = False\n\n    def __enter__(self):\n        if self._used:\n            raise CircuitError(\"Cannot re-use an 'else' context.\")\n        self._used = True\n        appended_instructions = self._if_context.appended_instructions\n        circuit = self._if_context.circuit\n        if appended_instructions is None:\n            raise CircuitError(\"Cannot attach an 'else' branch to an incomplete 'if' block.\")\n        if len(appended_instructions) != 1:\n            # I'm not even sure how you'd get this to trigger, but just in case...\n            raise CircuitError(\"Cannot attach an 'else' to a broadcasted 'if' block.\")\n        appended = appended_instructions[0]\n        instruction = circuit._peek_previous_instruction_in_scope()\n        if appended.operation is not instruction.operation:\n            raise CircuitError(\n                \"The 'if' block is not the most recent instruction in the circuit.\"\n                f\" Expected to find: {appended!r}, but instead found: {instruction!r}.\"\n            )\n        self._if_instruction = circuit._pop_previous_instruction_in_scope()\n        if isinstance(self._if_instruction.operation, IfElseOp):\n            self._if_registers = set(self._if_instruction.operation.blocks[0].cregs).union(\n                self._if_instruction.operation.blocks[0].qregs\n            )\n        else:\n            self._if_registers = self._if_instruction.operation.registers()\n        circuit._push_scope(\n            self._if_instruction.qubits,\n            self._if_instruction.clbits,\n            registers=self._if_registers,\n            allow_jumps=self._if_context.in_loop,\n        )\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        circuit = self._if_context.circuit\n        if exc_type is not None:\n            # If we're leaving the context manager because an exception was raised, we need to\n            # restore the \"if\" block we popped off.  At that point, it's safe to re-use this context\n            # manager, assuming nothing else untoward happened to the circuit, but that's checked by\n            # the __enter__ method.\n            circuit._pop_scope()\n            circuit._append(self._if_instruction)\n            self._used = False\n            return False\n\n        false_block = circuit._pop_scope()\n        # `if_block` is a placeholder if this context is in a loop, and a concrete instruction if it\n        # is not.\n        if isinstance(self._if_instruction.operation, IfElsePlaceholder):\n            if_operation = self._if_instruction.operation.with_false_block(false_block)\n            resources = if_operation.placeholder_resources()\n            circuit.append(if_operation, resources.qubits, resources.clbits)\n        else:\n            # In this case, we need to update both true_body and false_body to have exactly the same\n            # widths.  Passing extra resources to `ControlFlowBuilderBlock.build` doesn't _compel_\n            # the resulting object to use them (because it tries to be minimal), so it's best to\n            # pass it nothing extra (allows some fast path constructions), and add all necessary\n            # bits onto the circuits at the end.\n            true_body = self._if_instruction.operation.blocks[0]\n            false_body = false_block.build(false_block.qubits(), false_block.clbits())\n            true_body, false_body = unify_circuit_resources((true_body, false_body))\n            circuit.append(\n                IfElseOp(\n                    self._if_context.condition,\n                    true_body,\n                    false_body,\n                    label=self._if_instruction.operation.label,\n                ),\n                tuple(true_body.qubits),\n                tuple(true_body.clbits),\n            )\n        return False\n",
    "line_count": 499
  },
  {
    "filename": "switch_case.py",
    "path": "qiskit/circuit/controlflow/switch_case.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Circuit operation representing an ``switch/case`` statement.\"\"\"\n\nfrom __future__ import annotations\n\n__all__ = (\"SwitchCaseOp\", \"CASE_DEFAULT\")\n\nimport contextlib\nfrom typing import Union, Iterable, Any, Tuple, Optional, List, Literal, TYPE_CHECKING\n\nfrom qiskit.circuit import ClassicalRegister, Clbit  # pylint: disable=cyclic-import\nfrom qiskit.circuit.classical import expr, types\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .builder import InstructionPlaceholder, InstructionResources, ControlFlowBuilderBlock\nfrom .control_flow import ControlFlowOp\nfrom ._builder_utils import unify_circuit_resources, partition_registers, node_resources\n\nif TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n\n\nclass _DefaultCaseType:\n    # Note: Sphinx uses the docstring of this singleton class object as the documentation of the\n    # `CASE_DEFAULT` object.\n\n    \"\"\"A special object that represents the \"default\" case of a switch statement.  If you use this\n    as a case target, it must be the last case, and will match anything that wasn't already matched.\n    When using the builder interface of :meth:`.QuantumCircuit.switch`, this can also be accessed as\n    the ``DEFAULT`` attribute of the bound case-builder object.\"\"\"\n\n    def __repr__(self):\n        return \"<default case>\"\n\n\nCASE_DEFAULT = _DefaultCaseType()\n\n\nclass SwitchCaseOp(ControlFlowOp):\n    \"\"\"A circuit operation that executes one particular circuit block based on matching a given\n    ``target`` against an ordered list of ``values``.  The special value :data:`.CASE_DEFAULT` can\n    be used to represent a default condition.\n    \"\"\"\n\n    def __init__(\n        self,\n        target: Clbit | ClassicalRegister | expr.Expr,\n        cases: Iterable[Tuple[Any, QuantumCircuit]],\n        *,\n        label: Optional[str] = None,\n    ):\n        \"\"\"\n        Args:\n            target: the real-time value to switch on.\n            cases: an ordered iterable of the corresponding value of the ``target`` and the circuit\n                block that should be executed if this is matched.  There is no fall-through between\n                blocks, and the order matters.\n        \"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        if isinstance(target, expr.Expr):\n            if target.type.kind not in (types.Uint, types.Bool):\n                raise CircuitError(\n                    \"the switch target must be an expression with type 'Uint(n)' or 'Bool()',\"\n                    f\" not '{target.type}'\"\n                )\n        elif not isinstance(target, (Clbit, ClassicalRegister)):\n            raise CircuitError(\"the switch target must be a classical bit or register\")\n\n        if isinstance(target, expr.Expr):\n            target_bits = 1 if target.type.kind is types.Bool else target.type.width\n        else:\n            target_bits = 1 if isinstance(target, Clbit) else len(target)\n        target_max = (1 << target_bits) - 1\n\n        case_ids = set()\n        num_qubits, num_clbits = None, None\n        self.target = target\n        self._case_map = {}\n        \"\"\"Mapping of individual jump values to block indices.  This level of indirection is to let\n        us more easily track the case of multiple labels pointing to the same circuit object, so\n        it's easier for things like `assign_parameters`, which need to touch each circuit object\n        exactly once, to function.\"\"\"\n        self._label_spec: List[Tuple[Union[int, Literal[CASE_DEFAULT]], ...]] = []\n        \"\"\"List of the normalized jump value specifiers.  This is a list of tuples, where each tuple\n        contains the values, and the indexing is the same as the values of `_case_map` and\n        `_params`.\"\"\"\n        self._params = []\n        \"\"\"List of the circuit bodies used.  This form makes it simpler for things like\n        :meth:`.replace_blocks` and :class:`.QuantumCircuit.assign_parameters` to do their jobs\n        without accidentally mutating the same circuit instance more than once.\"\"\"\n        for i, (value_spec, case_) in enumerate(cases):\n            values = tuple(value_spec) if isinstance(value_spec, (tuple, list)) else (value_spec,)\n            for value in values:\n                if value in self._case_map:\n                    raise CircuitError(f\"duplicate case value {value}\")\n                if CASE_DEFAULT in self._case_map:\n                    raise CircuitError(\"cases after the default are unreachable\")\n                if value is not CASE_DEFAULT:\n                    if not isinstance(value, int) or value < 0:\n                        raise CircuitError(\"case values must be Booleans or non-negative integers\")\n                    if value > target_max:\n                        raise CircuitError(\n                            f\"switch target '{target}' has {target_bits} bit(s) of precision,\"\n                            f\" but case {value} is larger than the maximum of {target_max}.\"\n                        )\n                self._case_map[value] = i\n            self._label_spec.append(values)\n            if not isinstance(case_, QuantumCircuit):\n                raise CircuitError(\"case blocks must be QuantumCircuit instances\")\n            if id(case_) in case_ids:\n                raise CircuitError(\"ungrouped cases cannot point to the same block\")\n            case_ids.add(id(case_))\n            if num_qubits is None:\n                num_qubits, num_clbits = case_.num_qubits, case_.num_clbits\n            if case_.num_qubits != num_qubits or case_.num_clbits != num_clbits:\n                raise CircuitError(\"incompatible bits between cases\")\n            self._params.append(case_)\n        if not self._params:\n            # This condition also implies that `num_qubits` and `num_clbits` must be non-None.\n            raise CircuitError(\"must have at least one case to run\")\n\n        super().__init__(\"switch_case\", num_qubits, num_clbits, self._params, label=label)\n\n    def __eq__(self, other):\n        # The general __eq__ will compare the blocks in the right order, so we just need to ensure\n        # that all the labels point the right way as well.\n        return (\n            super().__eq__(other)\n            and self.target == other.target\n            and all(\n                set(labels_self) == set(labels_other)\n                for labels_self, labels_other in zip(self._label_spec, other._label_spec)\n            )\n        )\n\n    def cases_specifier(self) -> Iterable[Tuple[Tuple, QuantumCircuit]]:\n        \"\"\"Return an iterable where each element is a 2-tuple whose first element is a tuple of\n        jump values, and whose second is the single circuit block that is associated with those\n        values.\n\n        This is an abstract specification of the jump table suitable for creating new\n        :class:`.SwitchCaseOp` instances.\n\n        .. seealso::\n            :meth:`.SwitchCaseOp.cases`\n                Create a lookup table that you can use for your own purposes to jump from values to\n                the circuit that would be executed.\"\"\"\n        return zip(self._label_spec, self._params)\n\n    def cases(self):\n        \"\"\"Return a lookup table from case labels to the circuit that would be executed in that\n        case.  This object is not generally suitable for creating a new :class:`.SwitchCaseOp`\n        because any keys that point to the same object will not be grouped.\n\n        .. seealso::\n            :meth:`.SwitchCaseOp.cases_specifier`\n                An alternate method that produces its output in a suitable format for creating new\n                :class:`.SwitchCaseOp` instances.\n        \"\"\"\n        return {key: self._params[index] for key, index in self._case_map.items()}\n\n    @property\n    def blocks(self):\n        return tuple(self._params)\n\n    def replace_blocks(self, blocks: Iterable[QuantumCircuit]) -> \"SwitchCaseOp\":\n        blocks = tuple(blocks)\n        if len(blocks) != len(self._params):\n            raise CircuitError(f\"needed {len(self._case_map)} blocks but received {len(blocks)}\")\n        return SwitchCaseOp(self.target, zip(self._label_spec, blocks))\n\n\nclass SwitchCasePlaceholder(InstructionPlaceholder):\n    \"\"\"A placeholder instruction to use in control-flow context managers, when calculating the\n    number of resources this instruction should block is deferred until the construction of the\n    outer loop.\n\n    This generally should not be instantiated manually; only :obj:`.SwitchContext` should do it when\n    it needs to defer creation of the concrete instruction.\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    def __init__(\n        self,\n        target: Clbit | ClassicalRegister | expr.Expr,\n        cases: List[Tuple[Any, ControlFlowBuilderBlock]],\n        *,\n        label: Optional[str] = None,\n    ):\n        self.__target = target\n        self.__cases = cases\n        self.__resources = self._calculate_placeholder_resources()\n        super().__init__(\n            \"switch_case\",\n            len(self.__resources.qubits),\n            len(self.__resources.clbits),\n            [],\n            label=label,\n        )\n\n    def _calculate_placeholder_resources(self):\n        qubits = set()\n        clbits = set()\n        qregs = set()\n        cregs = set()\n        if isinstance(self.__target, Clbit):\n            clbits.add(self.__target)\n        elif isinstance(self.__target, ClassicalRegister):\n            clbits.update(self.__target)\n            cregs.add(self.__target)\n        else:\n            resources = node_resources(self.__target)\n            clbits.update(resources.clbits)\n            cregs.update(resources.cregs)\n        for _, body in self.__cases:\n            qubits |= body.qubits()\n            clbits |= body.clbits()\n            body_qregs, body_cregs = partition_registers(body.registers)\n            qregs |= body_qregs\n            cregs |= body_cregs\n        return InstructionResources(\n            qubits=tuple(qubits),\n            clbits=tuple(clbits),\n            qregs=tuple(qregs),\n            cregs=tuple(cregs),\n        )\n\n    def placeholder_resources(self):\n        return self.__resources\n\n    def concrete_instruction(self, qubits, clbits):\n        cases = [\n            (labels, unified_body)\n            for (labels, _), unified_body in zip(\n                self.__cases,\n                unify_circuit_resources(body.build(qubits, clbits) for _, body in self.__cases),\n            )\n        ]\n        if cases:\n            resources = InstructionResources(\n                qubits=tuple(cases[0][1].qubits),\n                clbits=tuple(cases[0][1].clbits),\n                qregs=tuple(cases[0][1].qregs),\n                cregs=tuple(cases[0][1].cregs),\n            )\n        else:\n            resources = self.__resources\n        return (\n            SwitchCaseOp(self.__target, cases, label=self.label),\n            resources,\n        )\n\n\nclass SwitchContext:\n    \"\"\"A context manager for building up ``switch`` statements onto circuits in a natural order,\n    without having to construct the case bodies first.\n\n    The return value of this context manager can be used within the created context to build up the\n    individual ``case`` statements.  No other instructions should be appended to the circuit during\n    the `switch` context.\n\n    This context should almost invariably be created by a :meth:`.QuantumCircuit.switch_case` call,\n    and the resulting instance is a \"friend\" of the calling circuit.  The context will manipulate\n    the circuit's defined scopes when it is entered (by pushing a new scope onto the stack) and\n    exited (by popping its scope, building it, and appending the resulting :obj:`.SwitchCaseOp`).\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    def __init__(\n        self,\n        circuit: QuantumCircuit,\n        target: Clbit | ClassicalRegister | expr.Expr,\n        *,\n        in_loop: bool,\n        label: Optional[str] = None,\n    ):\n        self.circuit = circuit\n        self._target = target\n        if isinstance(target, Clbit):\n            self.target_clbits: tuple[Clbit, ...] = (target,)\n            self.target_cregs: tuple[ClassicalRegister, ...] = ()\n        elif isinstance(target, ClassicalRegister):\n            self.target_clbits = tuple(target)\n            self.target_cregs = (target,)\n        else:\n            resources = node_resources(target)\n            self.target_clbits = resources.clbits\n            self.target_cregs = resources.cregs\n        self.in_loop = in_loop\n        self.complete = False\n        self._op_label = label\n        self._cases: List[Tuple[Tuple[Any, ...], ControlFlowBuilderBlock]] = []\n        self._label_set = set()\n\n    def label_in_use(self, label):\n        \"\"\"Return whether a case label is already accounted for in the switch statement.\"\"\"\n        return label in self._label_set\n\n    def add_case(\n        self, labels: Tuple[Union[int, Literal[CASE_DEFAULT]], ...], block: ControlFlowBuilderBlock\n    ):\n        \"\"\"Add a sequence of conditions and the single block that should be run if they are\n        triggered to the context.  The labels are assumed to have already been validated using\n        :meth:`label_in_use`.\"\"\"\n        # The labels were already validated when the case scope was entered, so we don't need to do\n        # it again.\n        self._label_set.update(labels)\n        self._cases.append((labels, block))\n\n    def __enter__(self):\n        self.circuit._push_scope(forbidden_message=\"Cannot have instructions outside a case\")\n        return CaseBuilder(self)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.complete = True\n        # The popped scope should be the forbidden scope.\n        self.circuit._pop_scope()\n        if exc_type is not None:\n            return False\n        # If we're in a loop-builder context, we need to emit a placeholder so that any `break` or\n        # `continue`s in any of our cases can be expanded when the loop-builder.  If we're not, we\n        # need to emit a concrete instruction immediately.\n        placeholder = SwitchCasePlaceholder(self._target, self._cases, label=self._op_label)\n        initial_resources = placeholder.placeholder_resources()\n        if self.in_loop:\n            self.circuit.append(placeholder, initial_resources.qubits, initial_resources.clbits)\n        else:\n            operation, resources = placeholder.concrete_instruction(\n                set(initial_resources.qubits), set(initial_resources.clbits)\n            )\n            self.circuit.append(operation, resources.qubits, resources.clbits)\n        return False\n\n\nclass CaseBuilder:\n    \"\"\"A child context manager for building up the ``case`` blocks of ``switch`` statements onto\n    circuits in a natural order, without having to construct the case bodies first.\n\n    This context should never need to be created manually by a user; it is the return value of the\n    :class:`.SwitchContext` context manager, which in turn should only be created by suitable\n    :meth:`.QuantumCircuit.switch_case` calls.\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    DEFAULT = CASE_DEFAULT\n    \"\"\"Convenient re-exposure of the :data:`.CASE_DEFAULT` constant.\"\"\"\n\n    def __init__(self, parent: SwitchContext):\n        self.switch = parent\n        self.entered = False\n\n    @contextlib.contextmanager\n    def __call__(self, *values):\n        if self.entered:\n            raise CircuitError(\n                \"Cannot enter more than one case at once.\"\n                \" If you want multiple labels to point to the same block,\"\n                \" pass them all to a single case context,\"\n                \" such as `with case(1, 2, 3):`.\"\n            )\n        if self.switch.complete:\n            raise CircuitError(\"Cannot add a new case to a completed switch statement.\")\n        if not all(value is CASE_DEFAULT or isinstance(value, int) for value in values):\n            raise CircuitError(\"Case values must be integers or `CASE_DEFAULT`\")\n        seen = set()\n        for value in values:\n            if self.switch.label_in_use(value) or value in seen:\n                raise CircuitError(f\"duplicate case label: '{value}'\")\n            seen.add(value)\n        self.switch.circuit._push_scope(\n            clbits=self.switch.target_clbits,\n            registers=self.switch.target_cregs,\n            allow_jumps=self.switch.in_loop,\n        )\n\n        try:\n            self.entered = True\n            yield\n        finally:\n            self.entered = False\n            block = self.switch.circuit._pop_scope()\n\n        # This is outside the `finally` because we only want to add the case to the switch if we're\n        # leaving it under normal circumstances.  If there was an exception in the case block, we\n        # should discard anything happened during its construction.\n        self.switch.add_case(values, block)\n",
    "line_count": 412
  },
  {
    "filename": "while_loop.py",
    "path": "qiskit/circuit/controlflow/while_loop.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Circuit operation representing a ``while`` loop.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom qiskit.circuit import ClassicalRegister, Clbit  # pylint: disable=cyclic-import\nfrom qiskit.circuit.classical import expr\nfrom qiskit.circuit.exceptions import CircuitError\nfrom ._builder_utils import validate_condition, condition_resources\nfrom .control_flow import ControlFlowOp\n\nif TYPE_CHECKING:\n    from qiskit.circuit import QuantumCircuit\n\n\nclass WhileLoopOp(ControlFlowOp):\n    \"\"\"A circuit operation which repeatedly executes a subcircuit (``body``) until\n    a condition (``condition``) evaluates as False.\n\n    The classical bits used in ``condition`` must be a subset of those attached\n    to ``body``.\n    \"\"\"\n\n    def __init__(\n        self,\n        condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr,\n        body: QuantumCircuit,\n        label: str | None = None,\n    ):\n        \"\"\"\n        Args:\n            condition: A condition to be checked prior to executing ``body``. Can be\n                specified as either a tuple of a ``ClassicalRegister`` to be tested\n                for equality with a given ``int``, or as a tuple of a ``Clbit`` to\n                be compared to either a ``bool`` or an ``int``.\n            body: The loop body to be repeatedly executed.\n            label: An optional label for identifying the instruction.\n        \"\"\"\n        num_qubits = body.num_qubits\n        num_clbits = body.num_clbits\n\n        super().__init__(\"while_loop\", num_qubits, num_clbits, [body], label=label)\n        self._condition = validate_condition(condition)\n\n    @property\n    def params(self):\n        return self._params\n\n    @property\n    def condition(self):\n        \"\"\"The condition for the while loop.\"\"\"\n        return self._condition\n\n    @condition.setter\n    def condition(self, value):\n        self._condition = value\n\n    @params.setter\n    def params(self, parameters):\n        # pylint: disable=cyclic-import\n        from qiskit.circuit import QuantumCircuit\n\n        (body,) = parameters\n\n        if not isinstance(body, QuantumCircuit):\n            raise CircuitError(\n                \"WhileLoopOp expects a body parameter of type \"\n                f\"QuantumCircuit, but received {type(body)}.\"\n            )\n\n        if body.num_qubits != self.num_qubits or body.num_clbits != self.num_clbits:\n            raise CircuitError(\n                \"Attempted to assign a body parameter with a num_qubits or \"\n                \"num_clbits different than that of the WhileLoopOp. \"\n                f\"WhileLoopOp num_qubits/clbits: {self.num_qubits}/{self.num_clbits} \"\n                f\"Supplied body num_qubits/clbits: {body.num_qubits}/{body.num_clbits}.\"\n            )\n\n        self._params = [body]\n\n    @property\n    def blocks(self):\n        return (self._params[0],)\n\n    def replace_blocks(self, blocks):\n        (body,) = blocks\n        return WhileLoopOp(self._condition, body, label=self.label)\n\n\nclass WhileLoopContext:\n    \"\"\"A context manager for building up while loops onto circuits in a natural order, without\n    having to construct the loop body first.\n\n    Within the block, a lot of the bookkeeping is done for you; you do not need to keep track of\n    which qubits and clbits you are using, for example.  All normal methods of accessing the qubits\n    on the underlying :obj:`~QuantumCircuit` will work correctly, and resolve into correct accesses\n    within the interior block.\n\n    You generally should never need to instantiate this object directly.  Instead, use\n    :obj:`.QuantumCircuit.while_loop` in its context-manager form, i.e. by not supplying a ``body``\n    or sets of qubits and clbits.\n\n    Example usage::\n\n        from qiskit.circuit import QuantumCircuit, Clbit, Qubit\n        bits = [Qubit(), Qubit(), Clbit()]\n        qc = QuantumCircuit(bits)\n\n        with qc.while_loop((bits[2], 0)):\n            qc.h(0)\n            qc.cx(0, 1)\n            qc.measure(0, 0)\n\n    .. warning::\n\n        This is an internal interface and no part of it should be relied upon outside of Qiskit\n        Terra.\n    \"\"\"\n\n    __slots__ = (\"_circuit\", \"_condition\", \"_label\")\n\n    def __init__(\n        self,\n        circuit: QuantumCircuit,\n        condition: tuple[ClassicalRegister, int] | tuple[Clbit, int] | expr.Expr,\n        *,\n        label: str | None = None,\n    ):\n\n        self._circuit = circuit\n        self._condition = validate_condition(condition)\n        self._label = label\n\n    def __enter__(self):\n        resources = condition_resources(self._condition)\n        self._circuit._push_scope(clbits=resources.clbits, registers=resources.cregs)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            # If we're leaving the context manager because an exception was raised, there's nothing\n            # to do except restore the circuit state.\n            self._circuit._pop_scope()\n            return False\n        scope = self._circuit._pop_scope()\n        # Loops do not need to pass any further resources in, because this scope itself defines the\n        # extent of ``break`` and ``continue`` statements.\n        body = scope.build(scope.qubits(), scope.clbits())\n        self._circuit.append(\n            WhileLoopOp(self._condition, body, label=self._label),\n            body.qubits,\n            body.clbits,\n        )\n        return False\n",
    "line_count": 167
  },
  {
    "filename": "bit_flip_oracle.py",
    "path": "qiskit/circuit/library/bit_flip_oracle.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2025.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Bit-flip Oracle object.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import Gate\n\nfrom qiskit.synthesis.boolean.boolean_expression import BooleanExpression\n\n\nclass BitFlipOracleGate(Gate):\n    r\"\"\"Implements a bit-flip oracle\n\n    The Bit-flip Oracle Gate object constructs circuits for any arbitrary\n    input logical expressions. A logical expression is composed of logical operators\n    `&` (logical `AND`), `|` (logical  `OR`),\n    `~` (logical  `NOT`), and `^` (logical  `XOR`).\n    as well as symbols for literals (variables).\n    For example, `'a & b'`, and `(v0 | ~v1) & (~v2 & v3)`\n    are both valid string representation of boolean logical expressions.\n\n    A bit-flip oracle for a boolean function `f(x)` performs the following\n    quantum operation:\n\n    .. math::\n\n            |x\\rangle|y\\rangle \\mapsto |x\\rangle|f(x)\\oplus y\\rangle\n\n    For convenience, this oracle, in addition to parsing arbitrary logical expressions,\n    also supports input strings in the `DIMACS CNF format\n    <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n    which is the standard format for specifying SATisfiability (SAT) problem instances in\n    `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n    which is a conjunction of one or more clauses, where a clause is a disjunction of one\n    or more literals.\n    See :meth:`qiskit.circuit.library.bit_flip_oracle.BitFlipOracleGate.from_dimacs_file`.\n\n    From 16 variables on, possible performance issues should be expected when using the\n    default synthesizer.\n    \"\"\"\n\n    def __init__(\n        self,\n        expression: str,\n        var_order: list[str] | None = None,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            expression: A Python-like boolean expression.\n            var_order: A list with the order in which variables will be created.\n               (default: by appearance)\n            label: A label for the gate to display in visualizations. Per default, the label is\n                set to display the textual represntation of the boolean expression (truncated if needed)\n        \"\"\"\n        self.boolean_expression = BooleanExpression(expression, var_order=var_order)\n\n        if label is None:\n            short_expr_for_name = (expression[:15] + \"...\") if len(expression) > 15 else expression\n            label = short_expr_for_name\n\n        super().__init__(\n            name=\"Bit-flip Oracle\",\n            num_qubits=self.boolean_expression.num_bits + 1,\n            params=[],\n            label=label,\n        )\n\n    def _define(self):\n        \"\"\"Defined by the synthesized bit-flip oracle\"\"\"\n        self.definition = self.boolean_expression.synth(circuit_type=\"bit\")\n\n    @classmethod\n    def from_dimacs_file(cls, filename: str) -> BitFlipOracleGate:\n        r\"\"\"Create a BitFlipOracleGate from the string in the DIMACS format.\n\n        It is possible to build a BitFlipOracleGate from a file in `DIMACS CNF format\n        <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n        which is the standard format for specifying SATisfiability (SAT) problem instances in\n        `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n        which is a conjunction of one or more clauses, where a clause is a disjunction of one\n        or more literals.\n\n        The following is an example of a CNF expressed in the DIMACS format:\n\n        .. code:: text\n\n          c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.\n          p cnf 3 5\n          -1 -2 -3 0\n          1 -2 3 0\n          1 2 -3 0\n          1 -2 -3 0\n          -1 2 3 0\n\n        The first line, following the `c` character, is a comment. The second line specifies that\n        the CNF is over three boolean variables --- let us call them  :math:`x_1, x_2, x_3`, and\n        contains five clauses.  The five clauses, listed afterwards, are implicitly joined by the\n        logical `AND` operator, :math:`\\land`, while the variables in each clause, represented by\n        their indices, are implicitly disjoined by the logical `OR` operator, :math:`\\lor`. The\n        :math:`-` symbol preceding a boolean variable index corresponds to the logical `NOT`\n        operator, :math:`\\lnot`. Character `0` (zero) marks the end of each clause.  Essentially,\n        the code above corresponds to the following CNF:\n\n        :math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor x_3)\n        \\land (x_1 \\lor x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (\\lnot x_1 \\lor x_2 \\lor x_3)`.\n\n\n        Args:\n            filename: A file in DIMACS format.\n\n        Returns:\n            BitFlipOracleGate: A quantum gate with a bit-flip oracle.\n        \"\"\"\n        expr = BooleanExpression.from_dimacs_file(filename)\n        return cls(expr)\n",
    "line_count": 131
  },
  {
    "filename": "blueprintcircuit.py",
    "path": "qiskit/circuit/library/blueprintcircuit.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Blueprint circuit object.\"\"\"\n\nfrom __future__ import annotations\nfrom abc import ABC, abstractmethod\nimport copy as _copy\n\nfrom qiskit._accelerate.circuit import CircuitData\nfrom qiskit.circuit import QuantumRegister, ClassicalRegister\nfrom qiskit.circuit.parametertable import ParameterView\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit, _copy_metadata\n\n\nclass BlueprintCircuit(QuantumCircuit, ABC):\n    \"\"\"Blueprint circuit object.\n\n    In many applications it is necessary to pass around the structure a circuit will have without\n    explicitly knowing e.g. its number of qubits, or other missing information. This can be solved\n    by having a circuit that knows how to construct itself, once all information is available.\n\n    This class provides an interface for such circuits. Before internal data of the circuit is\n    accessed, the ``_build`` method is called. There the configuration of the circuit is checked.\n    \"\"\"\n\n    def __init__(self, *regs, name: str | None = None) -> None:\n        \"\"\"Create a new blueprint circuit.\"\"\"\n        self._is_initialized = False\n        super().__init__(*regs, name=name)\n        self._qregs: list[QuantumRegister] = []\n        self._cregs: list[ClassicalRegister] = []\n        self._is_built = False\n        self._is_initialized = True\n\n    @abstractmethod\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration allows the circuit to be built.\n\n        Args:\n            raise_on_failure: If True, raise if the configuration is invalid. If False, return\n                False if the configuration is invalid.\n\n        Returns:\n            True, if the configuration is valid. Otherwise, depending on the value of\n            ``raise_on_failure`` an error is raised or False is returned.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def _build(self) -> None:\n        \"\"\"Build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        # check whether the configuration is valid\n        self._check_configuration()\n        self._is_built = True\n\n    def _invalidate(self) -> None:\n        \"\"\"Invalidate the current circuit build.\"\"\"\n        # Take out the registers before invalidating\n        qregs = self._data.qregs\n        cregs = self._data.cregs\n        self._data = CircuitData(self._data.qubits, self._data.clbits)\n        # Re-add the registers\n        for qreg in qregs:\n            self._data.add_qreg(qreg)\n        for creg in cregs:\n            self._data.add_creg(creg)\n        self.global_phase = 0\n        self._is_built = False\n\n    @property\n    def qregs(self):\n        \"\"\"A list of the quantum registers associated with the circuit.\"\"\"\n        if not self._is_initialized:\n            return self._qregs\n        return super().qregs\n\n    @qregs.setter\n    def qregs(self, qregs):\n        \"\"\"Set the quantum registers associated with the circuit.\"\"\"\n        if not self._is_initialized:\n            # Workaround to ignore calls from QuantumCircuit.__init__() which\n            # doesn't expect 'qregs' to be an overridden property!\n            return\n        self._qregs = []\n        self._ancillas = []\n        self._data = CircuitData(clbits=self._data.clbits)\n        self.global_phase = 0\n        self._is_built = False\n\n        self.add_register(*qregs)\n\n    @property\n    def data(self):\n        \"\"\"The circuit data (instructions and context).\n\n        Returns:\n            QuantumCircuitData: a list-like object containing the :class:`.CircuitInstruction`\\\\ s\n            for each instruction.\n        \"\"\"\n        if not self._is_built:\n            self._build()\n        return super().data\n\n    def decompose(self, gates_to_decompose=None, reps=1):\n        if not self._is_built:\n            self._build()\n        return super().decompose(gates_to_decompose, reps)\n\n    def draw(self, *args, **kwargs):\n        if not self._is_built:\n            self._build()\n        return super().draw(*args, **kwargs)\n\n    @property\n    def num_parameters(self) -> int:\n        \"\"\"The number of parameter objects in the circuit.\"\"\"\n        if not self._is_built:\n            self._build()\n        return super().num_parameters\n\n    @property\n    def parameters(self) -> ParameterView:\n        \"\"\"The parameters defined in the circuit.\n\n        This attribute returns the :class:`.Parameter` objects in the circuit sorted\n        alphabetically. Note that parameters instantiated with a :class:`.ParameterVector`\n        are still sorted numerically.\n\n        Examples:\n\n            The snippet below shows that insertion order of parameters does not matter.\n\n            .. code-block:: python\n\n                >>> from qiskit.circuit import QuantumCircuit, Parameter\n                >>> a, b, elephant = Parameter(\"a\"), Parameter(\"b\"), Parameter(\"elephant\")\n                >>> circuit = QuantumCircuit(1)\n                >>> circuit.rx(b, 0)\n                >>> circuit.rz(elephant, 0)\n                >>> circuit.ry(a, 0)\n                >>> circuit.parameters  # sorted alphabetically!\n                ParameterView([Parameter(a), Parameter(b), Parameter(elephant)])\n\n            Bear in mind that alphabetical sorting might be unintuitive when it comes to numbers.\n            The literal \"10\" comes before \"2\" in strict alphabetical sorting.\n\n            .. code-block:: python\n\n                >>> from qiskit.circuit import QuantumCircuit, Parameter\n                >>> angles = [Parameter(\"angle_1\"), Parameter(\"angle_2\"), Parameter(\"angle_10\")]\n                >>> circuit = QuantumCircuit(1)\n                >>> circuit.u(*angles, 0)\n                >>> circuit.draw()\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                q: \u2524 U(angle_1,angle_2,angle_10) \u251c\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                >>> circuit.parameters\n                ParameterView([Parameter(angle_1), Parameter(angle_10), Parameter(angle_2)])\n\n            To respect numerical sorting, a :class:`.ParameterVector` can be used.\n\n            .. code-block:: python\n\n                >>> from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector\n                >>> x = ParameterVector(\"x\", 12)\n                >>> circuit = QuantumCircuit(1)\n                >>> for x_i in x:\n                ...     circuit.rx(x_i, 0)\n                >>> circuit.parameters\n                ParameterView([\n                    ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n                    ParameterVectorElement(x[2]), ParameterVectorElement(x[3]),\n                    ..., ParameterVectorElement(x[11])\n                ])\n\n\n        Returns:\n            The sorted :class:`.Parameter` objects in the circuit.\n        \"\"\"\n        if not self._is_built:\n            self._build()\n        return super().parameters\n\n    def _append(self, instruction, _qargs=None, _cargs=None, *, _standard_gate=False):\n        if not self._is_built:\n            self._build()\n        return super()._append(instruction, _qargs, _cargs, _standard_gate=_standard_gate)\n\n    def compose(\n        self,\n        other,\n        qubits=None,\n        clbits=None,\n        front=False,\n        inplace=False,\n        wrap=False,\n        *,\n        copy=True,\n        var_remap=None,\n        inline_captures=False,\n    ):\n        if not self._is_built:\n            self._build()\n        return super().compose(\n            other,\n            qubits,\n            clbits,\n            front,\n            inplace,\n            wrap,\n            copy=copy,\n            var_remap=var_remap,\n            inline_captures=False,\n        )\n\n    def inverse(self, annotated: bool = False):\n        if not self._is_built:\n            self._build()\n        return super().inverse(annotated=annotated)\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, item):\n        return self.data[item]\n\n    def size(self, *args, **kwargs):\n        if not self._is_built:\n            self._build()\n        return super().size(*args, **kwargs)\n\n    def to_instruction(self, parameter_map=None, label=None):\n        if not self._is_built:\n            self._build()\n        return super().to_instruction(parameter_map, label=label)\n\n    def to_gate(self, parameter_map=None, label=None):\n        if not self._is_built:\n            self._build()\n        return super().to_gate(parameter_map, label=label)\n\n    def depth(self, *args, **kwargs):\n        if not self._is_built:\n            self._build()\n        return super().depth(*args, **kwargs)\n\n    def count_ops(self):\n        if not self._is_built:\n            self._build()\n        return super().count_ops()\n\n    def num_nonlocal_gates(self):\n        if not self._is_built:\n            self._build()\n        return super().num_nonlocal_gates()\n\n    def num_connected_components(self, unitary_only=False):\n        if not self._is_built:\n            self._build()\n        return super().num_connected_components(unitary_only=unitary_only)\n\n    def copy_empty_like(\n        self, name: str | None = None, *, vars_mode: str = \"alike\"\n    ) -> QuantumCircuit:\n        \"\"\"Return an empty :class:`.QuantumCircuit` of same size and metadata.\n\n        See also :meth:`.QuantumCircuit.copy_empty_like` for more details on copied metadata.\n\n        Args:\n            name: Name for the copied circuit. If None, then the name stays the same.\n            vars_mode: The mode to handle realtime variables in.\n\n        Returns:\n            An empty circuit of same dimensions. Note that the result is no longer a\n            :class:`.BlueprintCircuit`.\n        \"\"\"\n\n        cpy = QuantumCircuit(*self.qregs, *self.cregs, name=name, global_phase=self.global_phase)\n        _copy_metadata(self, cpy, vars_mode)\n        return cpy\n\n    def copy(self, name: str | None = None) -> BlueprintCircuit:\n        \"\"\"Copy the blueprint circuit.\n\n        Args:\n            name: Name to be given to the copied circuit. If None, then the name stays the same.\n\n        Returns:\n            A deepcopy of the current blueprint circuit, with the specified name.\n        \"\"\"\n        if not self._is_built:\n            self._build()\n\n        cpy = _copy.copy(self)\n        _copy_metadata(self, cpy, \"alike\")\n\n        cpy._is_built = self._is_built\n        cpy._data = self._data.copy()\n\n        if name is not None:\n            cpy.name = name\n\n        return cpy\n",
    "line_count": 317
  },
  {
    "filename": "fourier_checking.py",
    "path": "qiskit/circuit/library/fourier_checking.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Fourier checking circuit.\"\"\"\n\nfrom collections.abc import Sequence\nimport math\n\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.utils.deprecation import deprecate_func\n\nfrom .generalized_gates.diagonal import Diagonal, DiagonalGate\n\n\nclass FourierChecking(QuantumCircuit):\n    \"\"\"Fourier checking circuit.\n\n    The circuit for the Fourier checking algorithm, introduced in [1],\n    involves a layer of Hadamards, the function :math:`f`, another layer of\n    Hadamards, the function :math:`g`, followed by a final layer of Hadamards.\n    The functions :math:`f` and :math:`g` are classical functions realized\n    as phase oracles (diagonal operators with {-1, 1} on the diagonal).\n\n    The probability of observing the all-zeros string is :math:`p(f,g)`.\n    The algorithm solves the promise Fourier checking problem,\n    which decides if f is correlated with the Fourier transform\n    of g, by testing if :math:`p(f,g) <= 0.01` or :math:`p(f,g) >= 0.05`,\n    promised that one or the other of these is true.\n\n    The functions :math:`f` and :math:`g` are currently implemented\n    from their truth tables but could be represented concisely and\n    implemented efficiently for special classes of functions.\n\n    Fourier checking is a special case of :math:`k`-fold forrelation [2].\n\n    **Reference:**\n\n    [1] S. Aaronson, BQP and the Polynomial Hierarchy, 2009 (Section 3.2).\n    `arXiv:0910.4698 <https://arxiv.org/abs/0910.4698>`_\n\n    [2] S. Aaronson, A. Ambainis, Forrelation: a problem that\n    optimally separates quantum from classical computing, 2014.\n    `arXiv:1411.5729 <https://arxiv.org/abs/1411.5729>`_\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.fourier_checking instead.\",\n        pending=True,\n    )\n    def __init__(self, f: Sequence[int], g: Sequence[int]) -> None:\n        \"\"\"Create Fourier checking circuit.\n\n        Args:\n            f: truth table for f, length 2**n list of {1,-1}.\n            g: truth table for g, length 2**n list of {1,-1}.\n\n        Raises:\n            CircuitError: if the inputs f and g are not valid.\n\n        Reference Circuit:\n            .. plot::\n               :alt: Diagram illustrating the previously described circuit.\n\n               from qiskit.circuit.library import FourierChecking\n               from qiskit.visualization.library import _generate_circuit_library_visualization\n               f = [1, -1, -1, -1]\n               g = [1, 1, -1, -1]\n               circuit = FourierChecking(f, g)\n               _generate_circuit_library_visualization(circuit)\n        \"\"\"\n        num_qubits = math.log2(len(f))\n\n        if len(f) != len(g) or num_qubits == 0 or not num_qubits.is_integer():\n            raise CircuitError(\n                \"The functions f and g must be given as truth \"\n                \"tables, each as a list of 2**n entries of \"\n                \"{1, -1}.\"\n            )\n\n        # This definition circuit is not replaced by the circuit produced by fourier_checking,\n        # as the latter produces a slightly different circuit, with DiagonalGates instead\n        # of Diagonal circuits.\n        circuit = QuantumCircuit(int(num_qubits), name=f\"fc: {f}, {g}\")\n        circuit.h(circuit.qubits)\n        circuit.compose(Diagonal(f), inplace=True)\n        circuit.h(circuit.qubits)\n        circuit.compose(Diagonal(g), inplace=True)\n        circuit.h(circuit.qubits)\n        super().__init__(*circuit.qregs, name=circuit.name)\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\ndef fourier_checking(f: Sequence[int], g: Sequence[int]) -> QuantumCircuit:\n    \"\"\"Fourier checking circuit.\n\n    The circuit for the Fourier checking algorithm, introduced in [1],\n    involves a layer of Hadamards, the function :math:`f`, another layer of\n    Hadamards, the function :math:`g`, followed by a final layer of Hadamards.\n    The functions :math:`f` and :math:`g` are classical functions realized\n    as phase oracles (diagonal operators with {-1, 1} on the diagonal).\n\n    The probability of observing the all-zeros string is :math:`p(f,g)`.\n    The algorithm solves the promise Fourier checking problem,\n    which decides if f is correlated with the Fourier transform\n    of g, by testing if :math:`p(f,g) <= 0.01` or :math:`p(f,g) >= 0.05`,\n    promised that one or the other of these is true.\n\n    The functions :math:`f` and :math:`g` are currently implemented\n    from their truth tables but could be represented concisely and\n    implemented efficiently for special classes of functions.\n\n    Fourier checking is a special case of :math:`k`-fold forrelation [2].\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Circuit diagram output by the previous code.\n       :include-source:\n\n       from qiskit.circuit.library import fourier_checking\n       circuit = fourier_checking([1, -1, -1, -1], [1, 1, -1, -1])\n       circuit.draw('mpl')\n\n    **Reference:**\n\n    [1] S. Aaronson, BQP and the Polynomial Hierarchy, 2009 (Section 3.2).\n    `arXiv:0910.4698 <https://arxiv.org/abs/0910.4698>`_\n\n    [2] S. Aaronson, A. Ambainis, Forrelation: a problem that\n    optimally separates quantum from classical computing, 2014.\n    `arXiv:1411.5729 <https://arxiv.org/abs/1411.5729>`_\n    \"\"\"\n    num_qubits = math.log2(len(f))\n\n    if len(f) != len(g) or num_qubits == 0 or not num_qubits.is_integer():\n        raise CircuitError(\n            \"The functions f and g must be given as truth \"\n            \"tables, each as a list of 2**n entries of \"\n            \"{1, -1}.\"\n        )\n    num_qubits = int(num_qubits)\n\n    circuit = QuantumCircuit(num_qubits, name=f\"fc: {f}, {g}\")\n    circuit.h(circuit.qubits)\n    circuit.append(DiagonalGate(f), range(num_qubits))\n    circuit.h(circuit.qubits)\n    circuit.append(DiagonalGate(g), range(num_qubits))\n    circuit.h(circuit.qubits)\n    return circuit\n",
    "line_count": 161
  },
  {
    "filename": "graph_state.py",
    "path": "qiskit/circuit/library/graph_state.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Graph State circuit and gate.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass GraphState(QuantumCircuit):\n    r\"\"\"Circuit to prepare a graph state.\n\n    Given a graph G = (V, E), with the set of vertices V and the set of edges E,\n    the corresponding graph state is defined as\n\n    .. math::\n\n        |G\\rangle = \\prod_{(a,b) \\in E} CZ_{(a,b)} {|+\\rangle}^{\\otimes V}\n\n    Such a state can be prepared by first preparing all qubits in the :math:`+`\n    state, then applying a :math:`CZ` gate for each corresponding graph edge.\n\n    Graph state preparation circuits are Clifford circuits, and thus\n    easy to simulate classically. However, by adding a layer of measurements\n    in a product basis at the end, there is evidence that the circuit becomes\n    hard to simulate [2].\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GraphState\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import rustworkx as rx\n       G = rx.generators.cycle_graph(5)\n       circuit = GraphState(rx.adjacency_matrix(G))\n       circuit.name = \"Graph state\"\n       _generate_circuit_library_visualization(circuit)\n\n    **References:**\n\n    [1] M. Hein, J. Eisert, H.J. Briegel, Multi-party Entanglement in Graph States,\n        `arXiv:0307130 <https://arxiv.org/pdf/quant-ph/0307130.pdf>`_\n    [2] D. Koh, Further Extensions of Clifford Circuits & their Classical Simulation Complexities.\n        `arXiv:1512.07892 <https://arxiv.org/pdf/1512.07892.pdf>`_\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.GraphStateGate instead.\",\n        pending=True,\n    )\n    def __init__(self, adjacency_matrix: list | np.ndarray) -> None:\n        \"\"\"Create graph state preparation circuit.\n\n        Args:\n            adjacency_matrix: input graph as n-by-n list of 0-1 lists\n\n        Raises:\n            CircuitError: If adjacency_matrix is not symmetric.\n\n        The circuit prepares a graph state with the given adjacency\n        matrix.\n        \"\"\"\n\n        adjacency_matrix = np.asarray(adjacency_matrix)\n        if not np.allclose(adjacency_matrix, adjacency_matrix.transpose()):\n            raise CircuitError(\"The adjacency matrix must be symmetric.\")\n\n        graph_state_gate = GraphStateGate(adjacency_matrix)\n        super().__init__(graph_state_gate.num_qubits, name=f\"graph: {adjacency_matrix}\")\n        self.compose(graph_state_gate, qubits=self.qubits, inplace=True)\n\n\nclass GraphStateGate(Gate):\n    r\"\"\"A gate representing a graph state.\n\n    Given a graph G = (V, E), with the set of vertices V and the set of edges E,\n    the corresponding graph state is defined as\n\n    .. math::\n\n        |G\\rangle = \\prod_{(a,b) \\in E} CZ_{(a,b)} {|+\\rangle}^{\\otimes V}\n\n    Such a state can be prepared by first preparing all qubits in the :math:`+`\n    state, then applying a :math:`CZ` gate for each corresponding graph edge.\n\n    Graph state preparation circuits are Clifford circuits, and thus\n    easy to simulate classically. However, by adding a layer of measurements\n    in a product basis at the end, there is evidence that the circuit becomes\n    hard to simulate [2].\n\n    **Reference Circuit:**\n\n    .. plot::\n        :alt: Circuit diagram output by the previous code.\n        :include-source:\n\n        from qiskit.circuit import QuantumCircuit\n        from qiskit.circuit.library import GraphStateGate\n        import rustworkx as rx\n\n        G = rx.generators.cycle_graph(5)\n        circuit = QuantumCircuit(5)\n        circuit.append(GraphStateGate(rx.adjacency_matrix(G)), [0, 1, 2, 3, 4])\n        circuit.decompose().draw('mpl')\n\n    **References:**\n\n    [1] M. Hein, J. Eisert, H.J. Briegel, Multi-party Entanglement in Graph States,\n        `arXiv:0307130 <https://arxiv.org/pdf/quant-ph/0307130.pdf>`_\n    [2] D. Koh, Further Extensions of Clifford Circuits & their Classical Simulation Complexities.\n        `arXiv:1512.07892 <https://arxiv.org/pdf/1512.07892.pdf>`_\n    \"\"\"\n\n    def __init__(self, adjacency_matrix: list | np.ndarray) -> None:\n        \"\"\"\n        Args:\n            adjacency_matrix: input graph as n-by-n list of 0-1 lists\n\n        Raises:\n            CircuitError: If adjacency_matrix is not symmetric.\n\n        The gate represents a graph state with the given adjacency matrix.\n        \"\"\"\n\n        adjacency_matrix = np.asarray(adjacency_matrix)\n        if not np.allclose(adjacency_matrix, adjacency_matrix.transpose()):\n            raise CircuitError(\"The adjacency matrix must be symmetric.\")\n        num_qubits = len(adjacency_matrix)\n\n        super().__init__(name=\"graph_state\", num_qubits=num_qubits, params=[adjacency_matrix])\n\n    def _define(self):\n        adjacency_matrix = self.adjacency_matrix\n        circuit = QuantumCircuit(self.num_qubits, name=self.name)\n        circuit.h(range(self.num_qubits))\n        for i in range(self.num_qubits):\n            for j in range(i + 1, self.num_qubits):\n                if adjacency_matrix[i][j] == 1:\n                    circuit.cz(i, j)\n        self.definition = circuit\n\n    def validate_parameter(self, parameter):\n        \"\"\"Parameter validation\"\"\"\n        return parameter\n\n    @property\n    def adjacency_matrix(self):\n        \"\"\"Returns the adjacency matrix.\"\"\"\n        return self.params[0]\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, GraphStateGate)\n            and self.num_qubits == other.num_qubits\n            and np.all(self.adjacency_matrix == other.adjacency_matrix)\n        )\n",
    "line_count": 173
  },
  {
    "filename": "hamiltonian_gate.py",
    "path": "qiskit/circuit/library/hamiltonian_gate.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nGate described by the time evolution of a Hermitian Hamiltonian operator.\n\"\"\"\n\nfrom __future__ import annotations\nimport math\nimport typing\n\nfrom numbers import Number\nimport numpy as np\n\nfrom qiskit import _numpy_compat\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterExpression\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.quantum_info.operators.predicates import matrix_equal\nfrom qiskit.quantum_info.operators.predicates import is_hermitian_matrix\n\nfrom .generalized_gates.unitary import UnitaryGate\n\nif typing.TYPE_CHECKING:\n    from qiskit.quantum_info.operators.base_operator import BaseOperator\n\n\nclass HamiltonianGate(Gate):\n    r\"\"\"Class for representing evolution by a Hamiltonian operator as a gate.\n\n    This gate resolves to a :class:`~.library.UnitaryGate` as :math:`U(t) = \\exp(-i t H)`,\n    which can be decomposed into basis gates if it is 2 qubits or less, or\n    simulated directly in Aer for more qubits.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: np.ndarray | Gate | BaseOperator,\n        time: float | ParameterExpression,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            data: A hermitian operator.\n            time: Time evolution parameter.\n            label: Unitary name for backend [Default: ``None``].\n\n        Raises:\n            ValueError: if input data is not an N-qubit unitary operator.\n        \"\"\"\n        if hasattr(data, \"to_matrix\"):\n            # If input is Gate subclass or some other class object that has\n            # a to_matrix method this will call that method.\n            data = data.to_matrix()\n        elif hasattr(data, \"to_operator\"):\n            # If input is a BaseOperator subclass this attempts to convert\n            # the object to an Operator so that we can extract the underlying\n            # numpy matrix from `Operator.data`.\n            data = data.to_operator().data\n        # Convert to np array in case not already an array\n        data = np.asarray(data, dtype=complex)\n        # Check input is unitary\n        if not is_hermitian_matrix(data):\n            raise ValueError(\"Input matrix is not Hermitian.\")\n        if isinstance(time, Number) and time != np.real(time):\n            raise ValueError(\"Evolution time is not real.\")\n        # Check input is N-qubit matrix\n        input_dim, output_dim = data.shape\n        num_qubits = int(math.log2(input_dim))\n        if input_dim != output_dim or 2**num_qubits != input_dim:\n            raise ValueError(\"Input matrix is not an N-qubit operator.\")\n\n        # Store instruction params\n        super().__init__(\"hamiltonian\", num_qubits, [data, time], label=label)\n\n    def __eq__(self, other):\n        if not isinstance(other, HamiltonianGate):\n            return False\n        if self.label != other.label:\n            return False\n        operators_eq = matrix_equal(self.params[0], other.params[0], ignore_phase=False)\n        times_eq = self.params[1] == other.params[1]\n        return operators_eq and times_eq\n\n    def __array__(self, dtype=None, copy=None):\n        \"\"\"Return matrix for the unitary.\"\"\"\n        import scipy.linalg\n\n        if copy is False:\n            raise ValueError(\"unable to avoid copy while creating an array as requested\")\n        try:\n            time = float(self.params[1])\n        except TypeError as ex:\n            raise TypeError(\n                f\"Unable to generate Unitary matrix for unbound t parameter {self.params[1]}\"\n            ) from ex\n        arr = scipy.linalg.expm(-1j * self.params[0] * time)\n        dtype = complex if dtype is None else dtype\n        return np.array(arr, dtype=dtype, copy=_numpy_compat.COPY_ONLY_IF_NEEDED)\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return self.adjoint()\n\n    def conjugate(self):\n        \"\"\"Return the conjugate of the Hamiltonian.\"\"\"\n        return HamiltonianGate(np.conj(self.params[0]), -self.params[1])\n\n    def adjoint(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        return HamiltonianGate(self.params[0], -self.params[1])\n\n    def transpose(self):\n        \"\"\"Return the transpose of the Hamiltonian.\"\"\"\n        return HamiltonianGate(np.transpose(self.params[0]), self.params[1])\n\n    def _define(self):\n        \"\"\"Calculate a subcircuit that implements this unitary.\"\"\"\n        q = QuantumRegister(self.num_qubits, \"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        qc._append(UnitaryGate(self.to_matrix()), q[:], [])\n        self.definition = qc\n\n    def validate_parameter(self, parameter):\n        \"\"\"Hamiltonian parameter has to be an ndarray, operator or float.\"\"\"\n        if isinstance(parameter, (float, int, np.ndarray)):\n            return parameter\n        elif isinstance(parameter, ParameterExpression) and len(parameter.parameters) == 0:\n            return float(parameter)\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} for gate {self.name}\")\n",
    "line_count": 143
  },
  {
    "filename": "hidden_linear_function.py",
    "path": "qiskit/circuit/library/hidden_linear_function.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Hidden Linear Function circuit.\"\"\"\n\nfrom __future__ import annotations\n\nimport numpy as np\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass HiddenLinearFunction(QuantumCircuit):\n    r\"\"\"Circuit to solve the hidden linear function problem.\n\n    The 2D Hidden Linear Function problem is determined by a 2D adjacency\n    matrix A, where only elements that are nearest-neighbor on a grid have\n    non-zero entries. Each row/column corresponds to one binary variable\n    :math:`x_i`.\n\n    The hidden linear function problem is as follows:\n\n    Consider the quadratic form\n\n    .. math::\n\n        q(x) = \\sum_{i,j=1}^{n}{x_i x_j} ~(\\mathrm{mod}~ 4)\n\n    and restrict :math:`q(x)` onto the nullspace of A. This results in a linear\n    function.\n\n    .. math::\n\n        2 \\sum_{i=1}^{n}{z_i x_i} ~(\\mathrm{mod}~ 4)  \\forall  x \\in \\mathrm{Ker}(A)\n\n    and the goal is to recover this linear function (equivalently a vector\n    :math:`[z_0, ..., z_{n-1}]`). There can be multiple solutions.\n\n    In [1] it is shown that the present circuit solves this problem\n    on a quantum computer in constant depth, whereas any corresponding\n    solution on a classical computer would require circuits that grow\n    logarithmically with :math:`n`. Thus this circuit is an example\n    of quantum advantage with shallow circuits.\n\n    **Reference Circuit:**\n\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit.library import HiddenLinearFunction\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           A = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n           circuit = HiddenLinearFunction(A)\n           _generate_circuit_library_visualization(circuit)\n\n    **Reference:**\n\n    [1] S. Bravyi, D. Gosset, R. Koenig, Quantum Advantage with Shallow Circuits, 2017.\n    `arXiv:1704.00690 <https://arxiv.org/abs/1704.00690>`_\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.hidden_linear_function instead.\",\n        pending=True,\n    )\n    def __init__(self, adjacency_matrix: list | np.ndarray) -> None:\n        \"\"\"Create new HLF circuit.\n\n        Args:\n            adjacency_matrix: a symmetric n-by-n list of 0-1 lists.\n                n will be the number of qubits.\n\n        Raises:\n            CircuitError: If A is not symmetric.\n        \"\"\"\n        circuit = hidden_linear_function(adjacency_matrix)\n        super().__init__(*circuit.qregs, name=circuit.name)\n        self.append(circuit.to_gate(), self.qubits)\n\n\ndef hidden_linear_function(adjacency_matrix: list | np.ndarray) -> QuantumCircuit:\n    r\"\"\"Circuit to solve the hidden linear function problem.\n\n    The 2D Hidden Linear Function problem is determined by a 2D adjacency\n    matrix A, where only elements that are nearest-neighbor on a grid have\n    non-zero entries. Each row/column corresponds to one binary variable\n    :math:`x_i`.\n\n    The hidden linear function problem is as follows:\n\n    Consider the quadratic form\n\n    .. math::\n\n        q(x) = \\sum_{i,j=1}^{n}{x_i x_j} ~(\\mathrm{mod}~ 4)\n\n    and restrict :math:`q(x)` onto the nullspace of A. This results in a linear\n    function.\n\n    .. math::\n\n        2 \\sum_{i=1}^{n}{z_i x_i} ~(\\mathrm{mod}~ 4)  \\forall  x \\in \\mathrm{Ker}(A)\n\n    and the goal is to recover this linear function (equivalently a vector\n    :math:`[z_0, ..., z_{n-1}]`). There can be multiple solutions.\n\n    In [1] it is shown that the present circuit solves this problem\n    on a quantum computer in constant depth, whereas any corresponding\n    solution on a classical computer would require circuits that grow\n    logarithmically with :math:`n`. Thus this circuit is an example\n    of quantum advantage with shallow circuits.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Circuit diagram output by the previous code.\n       :include-source:\n\n       from qiskit.circuit.library import hidden_linear_function\n       A = [[1, 1, 0], [1, 0, 1], [0, 1, 1]]\n       circuit = hidden_linear_function(A)\n       circuit.draw('mpl')\n\n    Args:\n        adjacency_matrix: a symmetric n-by-n list of 0-1 lists.\n            n will be the number of qubits.\n\n    Raises:\n        CircuitError: If A is not symmetric.\n\n    **Reference:**\n\n    [1] S. Bravyi, D. Gosset, R. Koenig, Quantum Advantage with Shallow Circuits, 2017.\n    `arXiv:1704.00690 <https://arxiv.org/abs/1704.00690>`_\n    \"\"\"\n    adjacency_matrix = np.asarray(adjacency_matrix)\n    if not np.allclose(adjacency_matrix, adjacency_matrix.transpose()):\n        raise CircuitError(\"The adjacency matrix must be symmetric.\")\n\n    num_qubits = len(adjacency_matrix)\n    circuit = QuantumCircuit(num_qubits, name=f\"hlf: {adjacency_matrix}\")\n\n    circuit.h(range(num_qubits))\n    for i in range(num_qubits):\n        for j in range(i + 1, num_qubits):\n            if adjacency_matrix[i][j]:\n                circuit.cz(i, j)\n    for i in range(num_qubits):\n        if adjacency_matrix[i][i]:\n            circuit.s(i)\n    circuit.h(range(num_qubits))\n    return circuit\n",
    "line_count": 164
  },
  {
    "filename": "iqp.py",
    "path": "qiskit/circuit/library/iqp.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Instantaneous quantum polynomial circuit.\"\"\"\n\nfrom __future__ import annotations\nfrom collections.abc import Sequence\n\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.utils.deprecation import deprecate_func\nfrom qiskit._accelerate.circuit_library import py_iqp, py_random_iqp\n\n\nclass IQP(QuantumCircuit):\n    r\"\"\"Instantaneous quantum polynomial (IQP) circuit.\n\n    The circuit consists of a column of Hadamard gates,\n    a column of powers of T gates,\n    a sequence of powers of CS gates (up to\n    :math:`\\frac{n^2-n}{2}` of them),\n    and a final column of Hadamard gates, as introduced in [1].\n\n    The circuit is parameterized by an n x n interactions matrix.\n    The powers of each T gate are given by the diagonal elements\n    of the interactions matrix. The powers of the CS gates are\n    given by the upper triangle of the interactions matrix.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import IQP\n       A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n       circuit = IQP(A)\n       circuit.draw('mpl')\n\n    **Expanded Circuit:**\n\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit.library import IQP\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n           circuit = IQP(A)\n           _generate_circuit_library_visualization(circuit.decompose())\n\n    **References:**\n\n    [1] M. J. Bremner et al. Average-case complexity versus approximate\n    simulation of commuting quantum computations,\n    Phys. Rev. Lett. 117, 080501 (2016).\n    `arXiv:1504.07999 <https://arxiv.org/abs/1504.07999>`_\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use the qiskit.circuit.library.iqp function instead.\",\n        pending=True,\n    )\n    def __init__(self, interactions: list | np.ndarray) -> None:\n        \"\"\"Create IQP circuit.\n\n        Args:\n            interactions: input n-by-n symmetric matrix.\n\n        Raises:\n            CircuitError: if the inputs is not as symmetric matrix.\n        \"\"\"\n        circuit = iqp(interactions)\n        super().__init__(*circuit.qregs, name=circuit.name)\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\ndef iqp(\n    interactions: Sequence[Sequence[int]],\n) -> QuantumCircuit:\n    r\"\"\"Instantaneous quantum polynomial time (IQP) circuit.\n\n    The circuit consists of a column of Hadamard gates, a column of powers of T gates,\n    a sequence of powers of CS gates (up to :math:`\\frac{n^2-n}{2}` of them), and a final column of\n    Hadamard gates, as introduced in [1].\n\n    The circuit is parameterized by an :math:`n \\times n` interactions matrix. The powers of each\n    T gate are given by the diagonal elements of the interactions matrix. The powers of the CS gates\n    are given by the upper triangle of the interactions matrix.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import iqp\n       A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n       circuit = iqp(A)\n       circuit.draw(\"mpl\")\n\n    **Expanded Circuit:**\n\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit.library import iqp\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           A = [[6, 5, 3], [5, 4, 5], [3, 5, 1]]\n           circuit = iqp(A)\n           _generate_circuit_library_visualization(circuit)\n\n    **References:**\n\n    [1] M. J. Bremner et al. Average-case complexity versus approximate\n    simulation of commuting quantum computations,\n    Phys. Rev. Lett. 117, 080501 (2016).\n    `arXiv:1504.07999 <https://arxiv.org/abs/1504.07999>`_\n\n    Args:\n        interactions: The interactions as symmetric square matrix. If ``None``, then the\n            ``num_qubits`` argument must be set and a random IQP circuit will be generated.\n\n    Returns:\n        An IQP circuit.\n    \"\"\"\n    # if no interactions are given, generate them\n    num_qubits = len(interactions)\n    interactions = np.asarray(interactions).astype(np.int64)\n\n    # set the label -- if the number of qubits is too large, do not show the interactions matrix\n    if num_qubits < 5 and interactions is not None:\n        label = np.array_str(interactions)\n        name = \"iqp:\" + label.replace(\"\\n\", \";\")\n    else:\n        name = \"iqp\"\n\n    circuit = QuantumCircuit._from_circuit_data(py_iqp(interactions), add_regs=True)\n    circuit.name = name\n    return circuit\n\n\ndef random_iqp(\n    num_qubits: int,\n    seed: int | None = None,\n) -> QuantumCircuit:\n    r\"\"\"A random instantaneous quantum polynomial time (IQP) circuit.\n\n    See :func:`iqp` for more details on the IQP circuit.\n\n    Example:\n\n    .. plot::\n       :alt: Circuit diagram output by the previous code.\n       :include-source:\n\n       from qiskit.circuit.library import random_iqp\n\n       circuit = random_iqp(3)\n       circuit.draw(\"mpl\")\n\n    Args:\n        num_qubits: The number of qubits in the circuit.\n        seed: A seed for the random number generator, in case the interactions matrix is\n            randomly generated.\n\n    Returns:\n        An IQP circuit.\n    \"\"\"\n    # set the label -- if the number of qubits is too large, do not show the interactions matrix\n    circuit = QuantumCircuit._from_circuit_data(py_random_iqp(num_qubits, seed), add_regs=True)\n    circuit.name = \"iqp\"\n    return circuit\n",
    "line_count": 181
  },
  {
    "filename": "overlap.py",
    "path": "qiskit/circuit/library/overlap.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2023.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Unitary overlap circuit.\"\"\"\n\nfrom qiskit.circuit import QuantumCircuit, Gate\nfrom qiskit.circuit.parametervector import ParameterVector\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit import Barrier\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass UnitaryOverlap(QuantumCircuit):\n    r\"\"\"Circuit that returns the overlap between two unitaries :math:`U_2^{\\dag} U_1`.\n\n    The input quantum circuits must represent unitary operations, since they must be invertible.\n    If the inputs will have parameters, they are replaced by :class:`.ParameterVector`\\s with\n    names `\"p1\"` (for circuit ``unitary1``) and `\"p2\"` (for circuit ``unitary_2``) in the output\n    circuit.\n\n    This circuit is usually employed in computing the fidelity:\n\n    .. math::\n\n        \\left|\\langle 0| U_2^{\\dag} U_1|0\\rangle\\right|^{2}\n\n    by computing the probability of being in the all-zeros bit-string, or equivalently,\n    the expectation value of projector :math:`|0\\rangle\\langle 0|`.\n\n    Example::\n\n        import numpy as np\n        from qiskit.circuit.library import EfficientSU2, UnitaryOverlap\n        from qiskit.primitives import Sampler\n\n        # get two circuit to prepare states of which we compute the overlap\n        circuit = EfficientSU2(2, reps=1)\n        unitary1 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n        unitary2 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n\n        # create the overlap circuit\n        overlap = UnitaryOverlap(unitary1, unitary2)\n\n        # sample from the overlap\n        sampler = Sampler(options={\"shots\": 100})\n        result = sampler.run(overlap).result()\n\n        # the fidelity is the probability to measure 0\n        fidelity = result.quasi_dists[0].get(0, 0)\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.unitary_overlap instead.\",\n        pending=True,\n    )\n    def __init__(\n        self,\n        unitary1: QuantumCircuit,\n        unitary2: QuantumCircuit,\n        prefix1: str = \"p1\",\n        prefix2: str = \"p2\",\n        insert_barrier: bool = False,\n    ):\n        \"\"\"\n        Args:\n            unitary1: Unitary acting on the ket vector.\n            unitary2: Unitary whose inverse operates on the bra vector.\n            prefix1: The name of the parameter vector associated to ``unitary1``,\n                if it is parameterized. Defaults to ``\"p1\"``.\n            prefix2: The name of the parameter vector associated to ``unitary2``,\n                if it is parameterized. Defaults to ``\"p2\"``.\n            insert_barrier: Whether to insert a barrier between the two unitaries.\n\n        Raises:\n            CircuitError: Number of qubits in ``unitary1`` and ``unitary2`` does not match.\n            CircuitError: Inputs contain measurements and/or resets.\n        \"\"\"\n        circuit = unitary_overlap(unitary1, unitary2, prefix1, prefix2, insert_barrier)\n        super().__init__(*circuit.qregs, name=circuit.name)\n        self.compose(circuit, qubits=self.qubits, inplace=True)\n\n\ndef _check_unitary(circuit):\n    \"\"\"Check a circuit is unitary by checking if all operations are of type ``Gate``.\"\"\"\n\n    for instruction in circuit.data:\n        if not isinstance(instruction.operation, (Gate, Barrier)):\n            raise CircuitError(\n                \"One or more instructions cannot be converted to\"\n                f' a gate. \"{instruction.operation.name}\" is not a gate instruction'\n            )\n\n\ndef unitary_overlap(\n    unitary1: QuantumCircuit,\n    unitary2: QuantumCircuit,\n    prefix1: str = \"p1\",\n    prefix2: str = \"p2\",\n    insert_barrier: bool = False,\n) -> QuantumCircuit:\n    r\"\"\"Circuit that returns the overlap between two unitaries :math:`U_2^{\\dag} U_1`.\n\n    The input quantum circuits must represent unitary operations, since they must be invertible.\n    If the inputs will have parameters, they are replaced by :class:`.ParameterVector`\\s with\n    names `\"p1\"` (for circuit ``unitary1``) and `\"p2\"` (for circuit ``unitary_2``) in the output\n    circuit.\n\n    This circuit is usually employed in computing the fidelity:\n\n    .. math::\n\n        \\left|\\langle 0| U_2^{\\dag} U_1|0\\rangle\\right|^{2}\n\n    by computing the probability of being in the all-zeros bit-string, or equivalently,\n    the expectation value of projector :math:`|0\\rangle\\langle 0|`.\n\n    **Reference Circuit:**\n\n    .. plot::\n        :alt: Circuit diagram output by the previous code.\n        :include-source:\n\n        import numpy as np\n        from qiskit.circuit.library import efficient_su2, unitary_overlap\n\n        # get two circuit to prepare states of which we compute the overlap\n        circuit = efficient_su2(2, reps=1)\n        unitary1 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n        unitary2 = circuit.assign_parameters(np.random.random(circuit.num_parameters))\n\n        # create the overlap circuit\n        overlap = unitary_overlap(unitary1, unitary2)\n        overlap.draw('mpl')\n\n    Args:\n        unitary1: Unitary acting on the ket vector.\n        unitary2: Unitary whose inverse operates on the bra vector.\n        prefix1: The name of the parameter vector associated to ``unitary1``,\n            if it is parameterized. Defaults to ``\"p1\"``.\n        prefix2: The name of the parameter vector associated to ``unitary2``,\n            if it is parameterized. Defaults to ``\"p2\"``.\n        insert_barrier: Whether to insert a barrier between the two unitaries.\n\n    Raises:\n        CircuitError: Number of qubits in ``unitary1`` and ``unitary2`` does not match.\n        CircuitError: Inputs contain measurements and/or resets.\n    \"\"\"\n    # check inputs are valid\n    if unitary1.num_qubits != unitary2.num_qubits:\n        raise CircuitError(\n            f\"Number of qubits in unitaries does \"\n            f\"not match: {unitary1.num_qubits} != {unitary2.num_qubits}.\"\n        )\n\n    unitaries = [unitary1, unitary2]\n    for unitary in unitaries:\n        _check_unitary(unitary)\n\n    # Vectors of new parameters, if any. Need the unitaries in a list here to ensure\n    # we can overwrite them.\n    for i, prefix in enumerate([prefix1, prefix2]):\n        if unitaries[i].num_parameters > 0:\n            new_params = ParameterVector(prefix, unitaries[i].num_parameters)\n            unitaries[i] = unitaries[i].assign_parameters(new_params)\n\n    # Generate the actual overlap circuit\n    circuit = QuantumCircuit(unitaries[0].num_qubits, name=\"UnitaryOverlap\")\n    circuit.compose(unitaries[0], inplace=True)\n    if insert_barrier:\n        circuit.barrier()\n    circuit.compose(unitaries[1].inverse(), inplace=True)\n    return circuit\n",
    "line_count": 184
  },
  {
    "filename": "pauli_evolution.py",
    "path": "qiskit/circuit/library/pauli_evolution.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"A gate to implement time-evolution of operators.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\nimport numpy as np\n\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumcircuit import ParameterValueType\nfrom qiskit.circuit.parameterexpression import ParameterExpression\nfrom qiskit.quantum_info import Pauli, SparsePauliOp, SparseObservable\n\nif TYPE_CHECKING:\n    from qiskit.synthesis.evolution import EvolutionSynthesis\n\n\nclass PauliEvolutionGate(Gate):\n    r\"\"\"Time-evolution of an operator consisting of Paulis.\n\n    For an operator :math:`H` consisting of Pauli terms and (real) evolution time :math:`t`\n    this gate implements\n\n    .. math::\n\n        U(t) = e^{-itH}.\n\n    This gate serves as a high-level definition of the evolution and can be synthesized into\n    a circuit using different algorithms.\n\n    The evolution gates are related to the Pauli rotation gates by a factor of 2. For example\n    the time evolution of the Pauli :math:`X` operator is connected to the Pauli :math:`X` rotation\n    :math:`R_X` by\n\n    .. math::\n\n        U(t) = e^{-itX} = R_X(2t).\n\n    **Examples:**\n\n    .. plot::\n       :include-source:\n       :nofigs:\n\n        from qiskit.circuit import QuantumCircuit\n        from qiskit.circuit.library import PauliEvolutionGate\n        from qiskit.quantum_info import SparsePauliOp\n\n        X = SparsePauliOp(\"X\")\n        Z = SparsePauliOp(\"Z\")\n        I = SparsePauliOp(\"I\")\n\n        # build the evolution gate\n        operator = (Z ^ Z) - 0.1 * (X ^ I)\n        evo = PauliEvolutionGate(operator, time=0.2)\n\n        # plug it into a circuit\n        circuit = QuantumCircuit(2)\n        circuit.append(evo, range(2))\n        print(circuit.draw())\n\n    The above will print (note that the ``-0.1`` coefficient is not printed!):\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240                         \u251c\n             \u2502  exp(-it (ZZ + XI))(0.2) \u2502\n        q_1: \u25241                         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    **References:**\n\n    [1] G. Li et al. Paulihedral: A Generalized Block-Wise Compiler Optimization\n    Framework For Quantum Simulation Kernels (2021).\n    [`arXiv:2109.03371 <https://arxiv.org/abs/2109.03371>`_]\n    \"\"\"\n\n    def __init__(\n        self,\n        operator: (\n            Pauli\n            | SparsePauliOp\n            | SparseObservable\n            | list[Pauli | SparsePauliOp | SparseObservable]\n        ),\n        time: ParameterValueType = 1.0,\n        label: str | None = None,\n        synthesis: EvolutionSynthesis | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            operator: The operator to evolve. Can also be provided as list of non-commuting\n                operators where the elements are sums of commuting operators.\n                For example: ``[XY + YX, ZZ + ZI + IZ, YY]``.\n            time: The evolution time.\n            label: A label for the gate to display in visualizations. Per default, the label is\n                set to ``exp(-it <operators>)`` where ``<operators>`` is the sum of the Paulis.\n                Note that the label does not include any coefficients of the Paulis. See the\n                class docstring for an example.\n            synthesis: A synthesis strategy. If None, the default synthesis is the Lie-Trotter\n                product formula with a single repetition.\n        \"\"\"\n        if isinstance(operator, list):\n            operator = [_to_sparse_op(op) for op in operator]\n        else:\n            operator = _to_sparse_op(operator)\n\n        if label is None:\n            label = _get_default_label(operator)\n\n        num_qubits = operator[0].num_qubits if isinstance(operator, list) else operator.num_qubits\n        super().__init__(name=\"PauliEvolution\", num_qubits=num_qubits, params=[time], label=label)\n        self.operator = operator\n\n        if synthesis is None:\n            # pylint: disable=cyclic-import\n            from qiskit.synthesis.evolution import LieTrotter\n\n            synthesis = LieTrotter()\n\n        self.synthesis = synthesis\n\n    @property\n    def time(self) -> ParameterValueType:\n        \"\"\"Return the evolution time as stored in the gate parameters.\n\n        Returns:\n            The evolution time.\n        \"\"\"\n        return self.params[0]\n\n    @time.setter\n    def time(self, time: ParameterValueType) -> None:\n        \"\"\"Set the evolution time.\n\n        Args:\n            time: The evolution time.\n        \"\"\"\n        self.params = [time]\n\n    def _define(self):\n        \"\"\"Unroll, where the default synthesis is matrix based.\"\"\"\n        self.definition = self.synthesis.synthesize(self)\n\n    def validate_parameter(self, parameter: ParameterValueType) -> ParameterValueType:\n        \"\"\"Gate parameters should be int, float, or ParameterExpression\"\"\"\n        if isinstance(parameter, int):\n            parameter = float(parameter)\n\n        return super().validate_parameter(parameter)\n\n\ndef _to_sparse_op(\n    operator: Pauli | SparsePauliOp | SparseObservable,\n) -> SparsePauliOp | SparseObservable:\n    \"\"\"Cast the operator to a SparsePauliOp.\"\"\"\n\n    if isinstance(operator, Pauli):\n        sparse = SparsePauliOp(operator)\n    elif isinstance(operator, (SparseObservable, SparsePauliOp)):\n        sparse = operator\n    else:\n        raise ValueError(f\"Unsupported operator type for evolution: {type(operator)}.\")\n\n    if any(np.iscomplex(sparse.coeffs)):\n        raise ValueError(\"Operator contains complex coefficients, which are not supported.\")\n    if any(isinstance(coeff, ParameterExpression) for coeff in sparse.coeffs):\n        raise ValueError(\"Operator contains ParameterExpression, which are not supported.\")\n\n    return sparse\n\n\ndef _operator_label(operator):\n    if isinstance(operator, SparseObservable):\n        if len(operator) == 1:\n            return operator[0].bit_labels()[::-1]\n        return \"(\" + \" + \".join(term.bit_labels()[::-1] for term in operator) + \")\"\n\n    # else: is a SparsePauliOp\n    if len(operator.paulis) == 1:\n        return operator.paulis.to_labels()[0]\n    return \"(\" + \" + \".join(operator.paulis.to_labels()) + \")\"\n\n\ndef _get_default_label(operator):\n    if isinstance(operator, list):\n        return f\"exp(-it ({[_operator_label(op) for op in operator]}))\"\n    return f\"exp(-it {_operator_label(operator)})\"\n",
    "line_count": 202
  },
  {
    "filename": "phase_estimation.py",
    "path": "qiskit/circuit/library/phase_estimation.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Phase estimation circuit.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister\nfrom qiskit.utils.deprecation import deprecate_func\nfrom qiskit.circuit.library import QFT\n\n\nclass PhaseEstimation(QuantumCircuit):\n    r\"\"\"Phase Estimation circuit.\n\n    In the Quantum Phase Estimation (QPE) algorithm [1, 2, 3], the Phase Estimation circuit is used\n    to estimate the phase :math:`\\phi` of an eigenvalue :math:`e^{2\\pi i\\phi}` of a unitary operator\n    :math:`U`, provided with the corresponding eigenstate :math:`|\\psi\\rangle`.\n    That is\n\n    .. math::\n\n        U|\\psi\\rangle = e^{2\\pi i\\phi} |\\psi\\rangle\n\n    This estimation (and thereby this circuit) is a central routine to several well-known\n    algorithms, such as Shor's algorithm or Quantum Amplitude Estimation.\n\n    **References:**\n\n    [1]: Kitaev, A. Y. (1995). Quantum measurements and the Abelian Stabilizer Problem. 1\u201322.\n        `quant-ph/9511026 <http://arxiv.org/abs/quant-ph/9511026>`_\n\n    [2]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    [3]: Qiskit\n        `textbook <https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/\n        quantum-phase-estimation.ipynb>`_\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.phase_estimation instead.\",\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_evaluation_qubits: int,\n        unitary: QuantumCircuit,\n        iqft: QuantumCircuit | None = None,\n        name: str = \"QPE\",\n    ) -> None:\n        \"\"\"\n        Args:\n            num_evaluation_qubits: The number of evaluation qubits.\n            unitary: The unitary operation :math:`U` which will be repeated and controlled.\n            iqft: A inverse Quantum Fourier Transform, per default the inverse of\n                :class:`~qiskit.circuit.library.QFT` is used. Note that the QFT should not include\n                the usual swaps!\n            name: The name of the circuit.\n\n        .. note::\n\n            The inverse QFT should not include a swap of the qubit order.\n\n        Reference Circuit:\n            .. plot::\n               :alt: Diagram illustrating the previously described circuit.\n\n               from qiskit.circuit import QuantumCircuit\n               from qiskit.circuit.library import PhaseEstimation\n               from qiskit.visualization.library import _generate_circuit_library_visualization\n               unitary = QuantumCircuit(2)\n               unitary.x(0)\n               unitary.y(1)\n               circuit = PhaseEstimation(3, unitary)\n               _generate_circuit_library_visualization(circuit)\n        \"\"\"\n        qr_eval = QuantumRegister(num_evaluation_qubits, \"eval\")\n        qr_state = QuantumRegister(unitary.num_qubits, \"q\")\n        circuit = QuantumCircuit(qr_eval, qr_state, name=name)\n\n        if iqft is None:\n            iqft = QFT(num_evaluation_qubits, inverse=True, do_swaps=False).reverse_bits()\n\n        circuit.h(qr_eval)  # hadamards on evaluation qubits\n\n        for j in range(num_evaluation_qubits):  # controlled powers\n            circuit.compose(unitary.power(2**j).control(), qubits=[j] + qr_state[:], inplace=True)\n\n        circuit.compose(iqft, qubits=qr_eval[:], inplace=True)  # final QFT\n\n        super().__init__(*circuit.qregs, name=circuit.name)\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\ndef phase_estimation(\n    num_evaluation_qubits: int,\n    unitary: QuantumCircuit,\n    name: str = \"QPE\",\n) -> QuantumCircuit:\n    r\"\"\"Phase Estimation circuit.\n\n    In the Quantum Phase Estimation (QPE) algorithm [1, 2, 3], the Phase Estimation circuit is used\n    to estimate the phase :math:`\\phi` of an eigenvalue :math:`e^{2\\pi i\\phi}` of a unitary operator\n    :math:`U`, provided with the corresponding eigenstate :math:`|\\psi\\rangle`.\n    That is\n\n    .. math::\n\n        U|\\psi\\rangle = e^{2\\pi i\\phi} |\\psi\\rangle\n\n    This estimation (and thereby this circuit) is a central routine to several well-known\n    algorithms, such as Shor's algorithm or Quantum Amplitude Estimation.\n\n    Args:\n        num_evaluation_qubits: The number of evaluation qubits.\n        unitary: The unitary operation :math:`U` which will be repeated and controlled.\n        name: The name of the circuit.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Circuit diagram output by the previous code.\n       :include-source:\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import phase_estimation\n       unitary = QuantumCircuit(2)\n       unitary.x(0)\n       unitary.y(1)\n       circuit = phase_estimation(3, unitary)\n       circuit.draw('mpl')\n\n    **References:**\n\n    [1]: Kitaev, A. Y. (1995). Quantum measurements and the Abelian Stabilizer Problem. 1\u201322.\n        `quant-ph/9511026 <http://arxiv.org/abs/quant-ph/9511026>`_\n\n    [2]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    [3]: Qiskit\n        `textbook <https://github.com/Qiskit/textbook/blob/main/notebooks/ch-algorithms/\n        quantum-phase-estimation.ipynb>`_\n\n    \"\"\"\n    # pylint: disable=cyclic-import\n    from qiskit.circuit.library import PermutationGate, QFTGate\n\n    qr_eval = QuantumRegister(num_evaluation_qubits, \"eval\")\n    qr_state = QuantumRegister(unitary.num_qubits, \"q\")\n    circuit = QuantumCircuit(qr_eval, qr_state, name=name)\n\n    circuit.h(qr_eval)  # hadamards on evaluation qubits\n\n    for j in range(num_evaluation_qubits):  # controlled powers\n        circuit.compose(unitary.power(2**j).control(), qubits=[j] + qr_state[:], inplace=True)\n\n    circuit.append(QFTGate(num_evaluation_qubits).inverse(), qr_eval[:])\n\n    reversal_pattern = list(reversed(range(num_evaluation_qubits)))\n    circuit.append(PermutationGate(reversal_pattern), qr_eval[:])\n\n    return circuit\n",
    "line_count": 178
  },
  {
    "filename": "phase_oracle.py",
    "path": "qiskit/circuit/library/phase_oracle.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Phase Oracle object.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumCircuit, Gate\n\nfrom qiskit.synthesis.boolean.boolean_expression import BooleanExpression\n\n\nclass PhaseOracle(QuantumCircuit):\n    r\"\"\"Phase Oracle.\n\n    The Phase Oracle object constructs circuits for any arbitrary\n    input logical expressions. A logical expression is composed of logical operators\n    `&` (logical `AND`), `|` (logical  `OR`),\n    `~` (logical  `NOT`), and `^` (logical  `XOR`).\n    as well as symbols for literals (variables).\n    For example, `'a & b'`, and `(v0 | ~v1) & (~v2 & v3)`\n    are both valid string representation of boolean logical expressions.\n\n    A phase oracle for a boolean function `f(x)` performs the following\n    quantum operation:\n\n    .. math::\n\n            |x\\rangle \\mapsto (-1)^{f(x)}|x\\rangle\n\n    For convenience, this oracle, in addition to parsing arbitrary logical expressions,\n    also supports input strings in the `DIMACS CNF format\n    <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n    which is the standard format for specifying SATisfiability (SAT) problem instances in\n    `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n    which is a conjunction of one or more clauses, where a clause is a disjunction of one\n    or more literals. See :meth:`qiskit.circuit.library.phase_oracle.PhaseOracle.from_dimacs_file`.\n\n    From 16 variables on, possible performance issues should be expected when using the\n    default synthesizer.\n    \"\"\"\n\n    def __init__(\n        self,\n        expression: str,\n        var_order: list[str] | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            expression: A Python-like boolean expression.\n            var_order: A list with the order in which variables will be created.\n               (default: by appearance)\n        \"\"\"\n        self.boolean_expression = BooleanExpression(expression, var_order=var_order)\n        oracle = self.boolean_expression.synth(circuit_type=\"phase\")\n\n        super().__init__(oracle.num_qubits, name=\"Phase Oracle\")\n\n        self.compose(oracle, inplace=True, copy=False)\n\n    def evaluate_bitstring(self, bitstring: str) -> bool:\n        \"\"\"Evaluate the oracle on a bitstring.\n        This evaluation is done classically without any quantum circuit.\n\n        Args:\n            bitstring: The bitstring for which to evaluate. The input bitstring is expected to be\n                in little-endian order.\n\n        Returns:\n            True if the bitstring is a good state, False otherwise.\n        \"\"\"\n        return self.boolean_expression.simulate(bitstring[::-1])\n\n    @classmethod\n    def from_dimacs_file(cls, filename: str):\n        r\"\"\"Create a PhaseOracle from the string in the DIMACS format.\n\n        It is possible to build a PhaseOracle from a file in `DIMACS CNF format\n        <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n        which is the standard format for specifying SATisfiability (SAT) problem instances in\n        `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n        which is a conjunction of one or more clauses, where a clause is a disjunction of one\n        or more literals.\n\n        The following is an example of a CNF expressed in the DIMACS format:\n\n        .. code:: text\n\n          c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.\n          p cnf 3 5\n          -1 -2 -3 0\n          1 -2 3 0\n          1 2 -3 0\n          1 -2 -3 0\n          -1 2 3 0\n\n        The first line, following the `c` character, is a comment. The second line specifies that\n        the CNF is over three boolean variables --- let us call them  :math:`x_1, x_2, x_3`, and\n        contains five clauses.  The five clauses, listed afterwards, are implicitly joined by the\n        logical `AND` operator, :math:`\\land`, while the variables in each clause, represented by\n        their indices, are implicitly disjoined by the logical `OR` operator, :math:`lor`. The\n        :math:`-` symbol preceding a boolean variable index corresponds to the logical `NOT`\n        operator, :math:`lnot`. Character `0` (zero) marks the end of each clause.  Essentially,\n        the code above corresponds to the following CNF:\n\n        :math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor x_3)\n        \\land (x_1 \\lor x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (\\lnot x_1 \\lor x_2 \\lor x_3)`.\n\n\n        Args:\n            filename: A file in DIMACS format.\n\n        Returns:\n            PhaseOracle: A quantum circuit with a phase oracle.\n        \"\"\"\n        expr = BooleanExpression.from_dimacs_file(filename)\n        return cls(expr)\n\n\nclass PhaseOracleGate(Gate):\n    r\"\"\"Implements a phase oracle.\n\n    The Phase Oracle Gate object constructs circuits for any arbitrary\n    input logical expressions. A logical expression is composed of logical operators\n    `&` (logical `AND`), `|` (logical  `OR`),\n    `~` (logical  `NOT`), and `^` (logical  `XOR`).\n    as well as symbols for literals (variables).\n    For example, `'a & b'`, and `(v0 | ~v1) & (~v2 & v3)`\n    are both valid string representation of boolean logical expressions.\n\n    A phase oracle for a boolean function `f(x)` performs the following\n    quantum operation:\n\n    .. math::\n\n            |x\\rangle \\mapsto (-1)^{f(x)}|x\\rangle\n\n    For convenience, this oracle, in addition to parsing arbitrary logical expressions,\n    also supports input strings in the `DIMACS CNF format\n    <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n    which is the standard format for specifying SATisfiability (SAT) problem instances in\n    `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n    which is a conjunction of one or more clauses, where a clause is a disjunction of one\n    or more literals. See :meth:`qiskit.circuit.library.phase_oracle.PhaseOracleGate.from_dimacs_file`.\n\n    From 16 variables on, possible performance issues should be expected when using the\n    default synthesizer.\n    \"\"\"\n\n    def __init__(\n        self,\n        expression: str,\n        var_order: list[str] | None = None,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            expression: A Python-like boolean expression.\n            var_order: A list with the order in which variables will be created.\n               (default: by appearance)\n            label: A label for the gate to display in visualizations. Per default, the label is\n                set to display the textual represntation of the boolean expression (truncated if needed)\n        \"\"\"\n        self.boolean_expression = BooleanExpression(expression, var_order=var_order)\n\n        if label is None:\n            short_expr_for_name = (expression[:15] + \"...\") if len(expression) > 15 else expression\n            label = short_expr_for_name\n\n        super().__init__(\n            name=\"Phase Oracle\",\n            num_qubits=self.boolean_expression.num_bits,\n            params=[],\n            label=label,\n        )\n\n    def _define(self):\n        \"\"\"Defined by the synthesized phase oracle\"\"\"\n        self.definition = self.boolean_expression.synth(circuit_type=\"phase\")\n\n    @classmethod\n    def from_dimacs_file(cls, filename: str) -> PhaseOracleGate:\n        r\"\"\"Create a PhaseOracle from the string in the DIMACS format.\n\n        It is possible to build a PhaseOracle from a file in `DIMACS CNF format\n        <https://web.archive.org/web/20190325181937/https://www.satcompetition.org/2009/format-benchmarks2009.html>`__,\n        which is the standard format for specifying SATisfiability (SAT) problem instances in\n        `Conjunctive Normal Form (CNF) <https://en.wikipedia.org/wiki/Conjunctive_normal_form>`__,\n        which is a conjunction of one or more clauses, where a clause is a disjunction of one\n        or more literals.\n\n        The following is an example of a CNF expressed in the DIMACS format:\n\n        .. code:: text\n\n          c DIMACS CNF file with 3 satisfying assignments: 1 -2 3, -1 -2 -3, 1 2 -3.\n          p cnf 3 5\n          -1 -2 -3 0\n          1 -2 3 0\n          1 2 -3 0\n          1 -2 -3 0\n          -1 2 3 0\n\n        The first line, following the `c` character, is a comment. The second line specifies that\n        the CNF is over three boolean variables --- let us call them  :math:`x_1, x_2, x_3`, and\n        contains five clauses.  The five clauses, listed afterwards, are implicitly joined by the\n        logical `AND` operator, :math:`\\land`, while the variables in each clause, represented by\n        their indices, are implicitly disjoined by the logical `OR` operator, :math:`\\lor`. The\n        :math:`-` symbol preceding a boolean variable index corresponds to the logical `NOT`\n        operator, :math:`\\lnot`. Character `0` (zero) marks the end of each clause.  Essentially,\n        the code above corresponds to the following CNF:\n\n        :math:`(\\lnot x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor x_3)\n        \\land (x_1 \\lor x_2 \\lor \\lnot x_3)\n        \\land (x_1 \\lor \\lnot x_2 \\lor \\lnot x_3)\n        \\land (\\lnot x_1 \\lor x_2 \\lor x_3)`.\n\n\n        Args:\n            filename: A file in DIMACS format.\n\n        Returns:\n            PhaseOracleGate: A quantum circuit with a phase oracle.\n        \"\"\"\n        expr = BooleanExpression.from_dimacs_file(filename)\n        return cls(expr)\n",
    "line_count": 240
  },
  {
    "filename": "quantum_volume.py",
    "path": "qiskit/circuit/library/quantum_volume.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Quantum Volume model circuit.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Optional, Union\n\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit, CircuitInstruction\nfrom qiskit.circuit.library.generalized_gates import PermutationGate, UnitaryGate\nfrom qiskit._accelerate.circuit_library import quantum_volume as qv_rs\n\n\nclass QuantumVolume(QuantumCircuit):\n    \"\"\"A quantum volume model circuit.\n\n    The model circuits are random instances of circuits used to measure\n    the Quantum Volume metric, as introduced in [1].\n\n    The model circuits consist of layers of Haar random\n    elements of SU(4) applied between corresponding pairs\n    of qubits in a random bipartition.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       circuit = QuantumVolume(5, 6, seed=10)\n       circuit.draw('mpl')\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QuantumVolume\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumVolume(5, 6, seed=10, classical_permutation=False)\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    **References:**\n\n    [1] A. Cross et al. Validating quantum computers using\n    randomized model circuits, Phys. Rev. A 100, 032328 (2019).\n    [`arXiv:1811.12926 <https://arxiv.org/abs/1811.12926>`_]\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits: int,\n        depth: Optional[int] = None,\n        seed: Optional[Union[int, np.random.Generator]] = None,\n        classical_permutation: bool = True,\n        *,\n        flatten: bool = False,\n    ) -> None:\n        \"\"\"Create quantum volume model circuit of size num_qubits x depth.\n\n        Args:\n            num_qubits: number of active qubits in model circuit.\n            depth: layers of SU(4) operations in model circuit.\n            seed: Random number generator or generator seed.\n            classical_permutation: use classical permutations at every layer,\n                rather than quantum.\n            flatten: If ``False`` (the default), construct a circuit that contains a single\n                instruction, which in turn has the actual volume structure.  If ``True``, construct\n                the volume structure directly.\n        \"\"\"\n        import scipy.stats\n\n        # Parameters\n        depth = depth or num_qubits  # how many layers of SU(4)\n        width = num_qubits // 2  # how many SU(4)s fit in each layer\n        rng = seed if isinstance(seed, np.random.Generator) else np.random.default_rng(seed)\n        seed_name = seed\n        if seed_name is None:\n            # Get the internal entropy used to seed the default RNG, if no seed was given.  This\n            # stays in the output name, so effectively stores a way of regenerating the circuit.\n            # This is just best-effort only, for backwards compatibility, and isn't critical (if\n            # someone needs full reproducibility, they should be manually controlling the seeding).\n            seed_name = getattr(getattr(rng.bit_generator, \"seed_seq\", None), \"entropy\", None)\n\n        super().__init__(\n            num_qubits,\n            name=\"quantum_volume_\" + str([num_qubits, depth, seed_name]).replace(\" \", \"\"),\n        )\n        if classical_permutation:\n            if seed is not None:\n                max_value = np.iinfo(np.int64).max\n                seed = rng.integers(max_value, dtype=np.int64)\n            qv_circ = quantum_volume(num_qubits, depth, seed)\n            qv_circ.name = self.name\n            if flatten:\n                self.compose(qv_circ, inplace=True)\n            else:\n                self._append(CircuitInstruction(qv_circ.to_instruction(), tuple(self.qubits)))\n        else:\n            if seed is None:\n                seed = seed_name\n\n            base = self if flatten else QuantumCircuit(num_qubits, name=self.name)\n\n            # For each layer, generate a permutation of qubits\n            # Then generate and apply a Haar-random SU(4) to each pair\n            unitaries = scipy.stats.unitary_group.rvs(4, depth * width, rng).reshape(\n                depth, width, 4, 4\n            )\n            qubits = tuple(base.qubits)\n            for row in unitaries:\n                perm = rng.permutation(num_qubits)\n                base._append(CircuitInstruction(PermutationGate(perm), qubits))\n                for w, unitary in enumerate(row):\n                    gate = UnitaryGate(unitary, check_input=False, num_qubits=2)\n                    qubit = 2 * w\n                    base._append(CircuitInstruction(gate, qubits[qubit : qubit + 2]))\n            if not flatten:\n                self._append(CircuitInstruction(base.to_instruction(), tuple(self.qubits)))\n\n\ndef quantum_volume(\n    num_qubits: int,\n    depth: int | None = None,\n    seed: int | np.random.Generator | None = None,\n) -> QuantumCircuit:\n    \"\"\"A quantum volume model circuit.\n\n    The model circuits are random instances of circuits used to measure\n    the Quantum Volume metric, as introduced in [1].\n\n    The model circuits consist of layers of Haar random\n    elements of SU(4) applied between corresponding pairs\n    of qubits in a random bipartition.\n\n    This function is multithreaded and will launch a thread pool with threads equal to the number\n    of CPUs by default. You can tune the number of threads with the ``RAYON_NUM_THREADS``\n    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would limit the thread pool\n    to 4 threads.\n\n    Args:\n        num_qubits: The number qubits to use for the generated circuit.\n        depth: The number of layers for the generated circuit. If this\n            is not specified it will default to ``num_qubits`` layers.\n        seed: An optional RNG seed used for generating the random SU(4)\n            matrices used in the output circuit. This can be either an\n            integer or a numpy generator. If an integer is specfied it must\n            be an value between 0 and 2**64 - 1.\n\n    **Reference Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import quantum_volume\n       circuit = quantum_volume(5, 6, seed=10)\n       circuit.draw('mpl')\n\n    **References:**\n\n    [1] A. Cross et al. Validating quantum computers using\n    randomized model circuits, Phys. Rev. A 100, 032328 (2019).\n    `arXiv:1811.12926 <https://arxiv.org/abs/1811.12926>`__\n    \"\"\"\n    if isinstance(seed, np.random.Generator):\n        seed = seed.integers(0, dtype=np.uint64)\n    depth = depth or num_qubits\n    return QuantumCircuit._from_circuit_data(qv_rs(num_qubits, depth, seed))\n",
    "line_count": 180
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/arithmetic/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The arithmetic circuit library.\"\"\"\n\nfrom .functional_pauli_rotations import FunctionalPauliRotations\nfrom .integer_comparator import IntegerComparator, IntegerComparatorGate\nfrom .linear_pauli_rotations import LinearPauliRotations, LinearPauliRotationsGate\nfrom .piecewise_linear_pauli_rotations import (\n    PiecewiseLinearPauliRotations,\n    PiecewiseLinearPauliRotationsGate,\n)\nfrom .piecewise_polynomial_pauli_rotations import (\n    PiecewisePolynomialPauliRotations,\n    PiecewisePolynomialPauliRotationsGate,\n)\nfrom .polynomial_pauli_rotations import PolynomialPauliRotations, PolynomialPauliRotationsGate\nfrom .weighted_adder import WeightedAdder, WeightedSumGate\nfrom .quadratic_form import QuadraticForm, QuadraticFormGate\nfrom .linear_amplitude_function import LinearAmplitudeFunction, LinearAmplitudeFunctionGate\nfrom .piecewise_chebyshev import PiecewiseChebyshev, PiecewiseChebyshevGate\nfrom .exact_reciprocal import ExactReciprocal, ExactReciprocalGate\nfrom .adders import (\n    VBERippleCarryAdder,\n    CDKMRippleCarryAdder,\n    DraperQFTAdder,\n    ModularAdderGate,\n    HalfAdderGate,\n    FullAdderGate,\n)\nfrom .multipliers import HRSCumulativeMultiplier, RGQFTMultiplier, MultiplierGate\n",
    "line_count": 41
  },
  {
    "filename": "exact_reciprocal.py",
    "path": "qiskit/circuit/library/arithmetic/exact_reciprocal.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\"\"\"Exact reciprocal rotation.\"\"\"\n\nfrom math import isclose\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, Gate\nfrom qiskit.circuit.library.generalized_gates import UCRYGate\n\n\nclass ExactReciprocal(QuantumCircuit):\n    r\"\"\"Exact reciprocal\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(1/x)|x\\rangle|0\\rangle + \\sin(1/x)|x\\rangle |1\\rangle\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, scaling: float, neg_vals: bool = False, name: str = \"1/x\"\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits representing the value to invert.\n            scaling: Scaling factor :math:`s` of the reciprocal function, i.e. to compute\n                :math:`s / x`.\n            neg_vals: Whether :math:`x` might represent negative values. In this case the first\n                qubit is the sign, with :math:`|1\\rangle` for negative and :math:`|0\\rangle` for\n                positive.  For the negative case it is assumed that the remaining string represents\n                :math:`1 - x`. This is because :math:`e^{-2 \\pi i x} = e^{2 \\pi i (1 - x)}` for\n                :math:`x \\in [0,1)`.\n            name: The name of the object.\n\n        .. note::\n\n            It is assumed that the binary string :math:`x` represents a number < 1.\n        \"\"\"\n        qr_state = QuantumRegister(num_state_qubits, \"state\")\n        qr_flag = QuantumRegister(1, \"flag\")\n        super().__init__(qr_state, qr_flag, name=name)\n\n        reciprocal = ExactReciprocalGate(num_state_qubits, scaling, neg_vals, label=name)\n        self.append(reciprocal, self.qubits)\n\n\nclass ExactReciprocalGate(Gate):\n    r\"\"\"Implements an exact reciprocal function.\n\n    For a state :math:`|x\\rangle` and a scaling factor :math:`s`, this gate implements the operation\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto\n            \\cos\\left(\\arcsin\\left(s\\frac{2^n}{x}\\right)\\right)|x\\rangle|0\\rangle +\n            \\left(s\\frac{2^n}{x}\\right)|x\\rangle|1\\rangle.\n\n    States representing :math:`x = 0` or :math:`s 2^n / x \\geq 1` are left unchanged, since\n    this function would not be defined.\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, scaling: float, neg_vals: bool = False, label: str = \"1/x\"\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits representing the value to invert.\n            scaling: Scaling factor :math:`s` of the reciprocal function, i.e. to compute\n                :math:`s / x`.\n            neg_vals: Whether :math:`x` might represent negative values. In this case the first\n                qubit is the sign, with :math:`|1\\rangle` for negative and :math:`|0\\rangle` for\n                positive.  For the negative case it is assumed that the remaining string represents\n                :math:`1 - x`. This is because :math:`e^{-2 \\pi i x} = e^{2 \\pi i (1 - x)}` for\n                :math:`x \\in [0,1)`.\n            label: The label of the object.\n\n        .. note::\n\n            It is assumed that the binary string :math:`x` represents a number < 1.\n        \"\"\"\n        super().__init__(\"ExactReciprocal\", num_state_qubits + 1, [], label=label)\n\n        self.scaling = scaling\n        self.neg_vals = neg_vals\n\n    def _define(self):\n        num_state_qubits = self.num_qubits - 1\n        qr_state = QuantumRegister(num_state_qubits, \"state\")\n        qr_flag = QuantumRegister(1, \"flag\")\n        circuit = QuantumCircuit(qr_state, qr_flag)\n\n        angles = [0.0]\n        nl = 2 ** (num_state_qubits - 1) if self.neg_vals else 2**num_state_qubits\n\n        # Angles to rotate by scaling / x, where x = i / nl\n        for i in range(1, nl):\n            if isclose(self.scaling * nl / i, 1, abs_tol=1e-5):\n                angles.append(np.pi)\n            elif self.scaling * nl / i < 1:\n                angles.append(2 * np.arcsin(self.scaling * nl / i))\n            else:\n                angles.append(0.0)\n\n        circuit.append(UCRYGate(angles), [qr_flag[0]] + qr_state[: len(qr_state) - self.neg_vals])\n\n        if self.neg_vals:\n            circuit.append(\n                UCRYGate([-theta for theta in angles]).control(),\n                [qr_state[-1]] + [qr_flag[0]] + qr_state[:-1],\n            )\n            angles_neg = [0.0]\n            for i in range(1, nl):\n                if isclose(self.scaling * (-1) / (1 - i / nl), -1, abs_tol=1e-5):\n                    angles_neg.append(-np.pi)\n                elif np.abs(self.scaling * (-1) / (1 - i / nl)) < 1:\n                    angles_neg.append(2 * np.arcsin(self.scaling * (-1) / (1 - i / nl)))\n                else:\n                    angles_neg.append(0.0)\n            circuit.append(\n                UCRYGate(angles_neg).control(), [qr_state[-1]] + [qr_flag[0]] + qr_state[:-1]\n            )\n\n        self.definition = circuit\n",
    "line_count": 132
  },
  {
    "filename": "functional_pauli_rotations.py",
    "path": "qiskit/circuit/library/arithmetic/functional_pauli_rotations.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Base class for functional Pauli rotations.\"\"\"\n\nfrom typing import Optional\n\nfrom abc import ABC, abstractmethod\nfrom ..blueprintcircuit import BlueprintCircuit\n\n\nclass FunctionalPauliRotations(BlueprintCircuit, ABC):\n    \"\"\"Base class for functional Pauli rotations.\"\"\"\n\n    def __init__(\n        self, num_state_qubits: Optional[int] = None, basis: str = \"Y\", name: str = \"F\"\n    ) -> None:\n        r\"\"\"Create a new functional Pauli rotation circuit.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n            basis: The kind of Pauli rotation to use. Must be 'X', 'Y' or 'Z'.\n            name: The name of the circuit object.\n        \"\"\"\n        super().__init__(name=name)\n\n        # define internal parameters\n        self._num_state_qubits = None\n        self._basis = None\n\n        # store parameters\n        self.num_state_qubits = num_state_qubits\n        self.basis = basis\n\n    @property\n    def basis(self) -> str:\n        \"\"\"The kind of Pauli rotation to be used.\n\n        Set the basis to 'X', 'Y' or 'Z' for controlled-X, -Y, or -Z rotations respectively.\n\n        Returns:\n            The kind of Pauli rotation used in controlled rotation.\n        \"\"\"\n        return self._basis\n\n    @basis.setter\n    def basis(self, basis: str) -> None:\n        \"\"\"Set the kind of Pauli rotation to be used.\n\n        Args:\n            basis: The Pauli rotation to be used.\n\n        Raises:\n            ValueError: The provided basis in not X, Y or Z.\n        \"\"\"\n        basis = basis.lower()\n        if self._basis is None or basis != self._basis:\n            if basis not in [\"x\", \"y\", \"z\"]:\n                raise ValueError(f\"The provided basis must be X, Y or Z, not {basis}\")\n            self._invalidate()\n            self._basis = basis\n\n    @property\n    def num_state_qubits(self) -> int:\n        r\"\"\"The number of state qubits representing the state :math:`|x\\rangle`.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    @num_state_qubits.setter\n    def num_state_qubits(self, num_state_qubits: Optional[int]) -> None:\n        \"\"\"Set the number of state qubits.\n\n        Note that this may change the underlying quantum register, if the number of state qubits\n        changes.\n\n        Args:\n            num_state_qubits: The new number of qubits.\n        \"\"\"\n        if self._num_state_qubits is None or num_state_qubits != self._num_state_qubits:\n            self._invalidate()\n            self._num_state_qubits = num_state_qubits\n\n            self._reset_registers(num_state_qubits)\n\n    @abstractmethod\n    def _reset_registers(self, num_state_qubits: Optional[int]) -> None:\n        \"\"\"Reset the registers according to the new number of state qubits.\n\n        Args:\n            num_state_qubits: The new number of qubits.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def num_ancilla_qubits(self) -> int:\n        \"\"\"The minimum number of ancilla qubits in the circuit.\n\n        Returns:\n            The minimal number of ancillas required.\n        \"\"\"\n        return 0\n",
    "line_count": 115
  },
  {
    "filename": "integer_comparator.py",
    "path": "qiskit/circuit/library/arithmetic/integer_comparator.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Integer Comparator.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumRegister, AncillaRegister, Gate\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.synthesis.arithmetic.comparators import (\n    synth_integer_comparator_2s,\n    synth_integer_comparator_greedy,\n)\nfrom ..blueprintcircuit import BlueprintCircuit\n\n\nclass IntegerComparator(BlueprintCircuit):\n    r\"\"\"Integer Comparator.\n\n    Operator compares basis states :math:`|i\\rangle_n` against a classically given integer\n    :math:`L` of fixed value and flips a target qubit if :math:`i \\geq L`\n    (or :math:`<` depending on the parameter ``geq``):\n\n    .. math::\n\n        |i\\rangle_n |0\\rangle \\mapsto |i\\rangle_n |i \\geq L\\rangle\n\n    This operation is based on two's complement implementation of binary subtraction but only\n    uses carry bits and no actual result bits. If the most significant carry bit\n    (the results bit) is 1, the :math:`\\geq` condition is ``True`` otherwise it is ``False``.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int | None = None,\n        value: int | None = None,\n        geq: bool = True,\n        name: str = \"cmp\",\n    ) -> None:\n        \"\"\"Create a new fixed value comparator circuit.\n\n        Args:\n            num_state_qubits: Number of state qubits. If this is set it will determine the number\n                of qubits required for the circuit.\n            value: The fixed value to compare with.\n            geq: If True, evaluate a ``>=`` condition, else ``<``.\n            name: Name of the circuit.\n        \"\"\"\n        super().__init__(name=name)\n\n        self._value = None\n        self._geq = None\n        self._num_state_qubits = None\n\n        self.value = value\n        self.geq = geq\n        self.num_state_qubits = num_state_qubits\n\n    @property\n    def value(self) -> int:\n        \"\"\"The value to compare the qubit register to.\n\n        Returns:\n            The value against which the value of the qubit register is compared.\n        \"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, value: int) -> None:\n        if value != self._value:\n            self._invalidate()\n            self._value = value\n\n    @property\n    def geq(self) -> bool:\n        \"\"\"Return whether the comparator compares greater or less equal.\n\n        Returns:\n            True, if the comparator compares ``>=``, False if ``<``.\n        \"\"\"\n        return self._geq\n\n    @geq.setter\n    def geq(self, geq: bool) -> None:\n        \"\"\"Set whether the comparator compares greater or less equal.\n\n        Args:\n            geq: If True, the comparator compares ``>=``, if False ``<``.\n        \"\"\"\n        if geq != self._geq:\n            self._invalidate()\n            self._geq = geq\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of qubits encoding the state for the comparison.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    @num_state_qubits.setter\n    def num_state_qubits(self, num_state_qubits: int | None) -> None:\n        \"\"\"Set the number of state qubits.\n\n        Note that this will change the quantum registers.\n\n        Args:\n            num_state_qubits: The new number of state qubits.\n        \"\"\"\n        if self._num_state_qubits is None or num_state_qubits != self._num_state_qubits:\n            self._invalidate()  # reset data\n            self._num_state_qubits = num_state_qubits\n\n            if num_state_qubits is not None:\n                # set the new qubit registers\n                qr_state = QuantumRegister(num_state_qubits, name=\"state\")\n                q_compare = QuantumRegister(1, name=\"compare\")\n\n                self.qregs = [qr_state, q_compare]\n\n                # add ancillas is required\n                num_ancillas = num_state_qubits - 1\n                if num_ancillas > 0:\n                    qr_ancilla = AncillaRegister(num_ancillas)\n                    self.add_register(qr_ancilla)\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n\n        if self._num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"Number of state qubits is not set.\")\n\n        if self._value is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"No comparison value set.\")\n\n        required_num_qubits = 2 * self.num_state_qubits\n        if self.num_qubits != required_num_qubits:\n            valid = False\n            if raise_on_failure:\n                raise CircuitError(\"Number of qubits does not match required number of qubits.\")\n\n        return valid\n\n    def _build(self) -> None:\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        circuit = synth_integer_comparator_2s(self.num_state_qubits, self.value, self.geq)\n        self.append(circuit.to_gate(), self.qubits)\n\n\nclass IntegerComparatorGate(Gate):\n    r\"\"\"Perform a :math:`\\geq` (or :math:`<`) on a qubit register against a classical integer.\n\n    This operator compares basis states :math:`|i\\rangle_n` against a classically given integer\n    :math:`L` of fixed value and flips a target qubit if :math:`i \\geq L`\n    (or :math:`<` depending on the parameter ``geq``):\n\n    .. math::\n\n        |i\\rangle_n |0\\rangle \\mapsto |i\\rangle_n |i \\geq L\\rangle\n\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, value: int, geq: bool = True, label: str | None = None\n    ):\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits in the registers.\n            value: The value :math:`L` to compre to.\n            geq: If ``True`` compute :math:`i \\geq L`, otherwise compute :math:`i < L`.\n            label: An optional label for the gate.\n        \"\"\"\n        super().__init__(\"IntComp\", num_state_qubits + 1, [], label=label)\n        self.value = value\n        self.geq = geq\n\n    def _define(self):\n        self.definition = synth_integer_comparator_greedy(self.num_qubits - 1, self.value, self.geq)\n",
    "line_count": 201
  },
  {
    "filename": "linear_amplitude_function.py",
    "path": "qiskit/circuit/library/arithmetic/linear_amplitude_function.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"A class implementing a (piecewise-) linear function on qubit amplitudes.\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit, Gate\n\nfrom .piecewise_linear_pauli_rotations import (\n    PiecewiseLinearPauliRotations,\n    PiecewiseLinearPauliRotationsGate,\n)\n\n\nclass LinearAmplitudeFunction(QuantumCircuit):\n    r\"\"\"A circuit implementing a (piecewise) linear function on qubit amplitudes.\n\n    An amplitude function :math:`F` of a function :math:`f` is a mapping\n\n    .. math::\n\n        F|x\\rangle|0\\rangle = \\sqrt{1 - \\hat{f}(x)} |x\\rangle|0\\rangle + \\sqrt{\\hat{f}(x)}\n            |x\\rangle|1\\rangle.\n\n    for a function :math:`\\hat{f}: \\{ 0, ..., 2^n - 1 \\} \\rightarrow [0, 1]`, where\n    :math:`|x\\rangle` is a :math:`n` qubit state.\n\n    This circuit implements :math:`F` for piecewise linear functions :math:`\\hat{f}`.\n    In this case, the mapping :math:`F` can be approximately implemented using a Taylor expansion\n    and linearly controlled Pauli-Y rotations, see [1, 2] for more detail. This approximation\n    uses a ``rescaling_factor`` to determine the accuracy of the Taylor expansion.\n\n    In general, the function of interest :math:`f` is defined from some interval :math:`[a,b]`,\n    the ``domain`` to :math:`[c,d]`, the ``image``, instead of :math:`\\{ 1, ..., N \\}` to\n    :math:`[0, 1]`. Using an affine transformation we can rescale :math:`f` to :math:`\\hat{f}`:\n\n    .. math::\n\n        \\hat{f}(x) = \\frac{f(\\phi(x)) - c}{d - c}\n\n    with\n\n    .. math::\n\n        \\phi(x) = a + \\frac{b - a}{2^n - 1} x.\n\n    If :math:`f` is a piecewise linear function on :math:`m` intervals\n    :math:`[p_{i-1}, p_i], i \\in \\{1, ..., m\\}` with slopes :math:`\\alpha_i` and\n    offsets :math:`\\beta_i` it can be written as\n\n    .. math::\n\n        f(x) = \\sum_{i=1}^m 1_{[p_{i-1}, p_i]}(x) (\\alpha_i x + \\beta_i)\n\n    where :math:`1_{[a, b]}` is an indication function that is 1 if the argument is in the interval\n    :math:`[a, b]` and otherwise 0. The breakpoints :math:`p_i` can be specified by the\n    ``breakpoints`` argument.\n\n    References:\n\n        [1]: Woerner, S., & Egger, D. J. (2018).\n             Quantum Risk Analysis.\n             `arXiv:1806.06893 <http://arxiv.org/abs/1806.06893>`_\n\n        [2]: Gacon, J., Zoufal, C., & Woerner, S. (2020).\n             Quantum-Enhanced Simulation-Based Optimization.\n             `arXiv:2005.10780 <http://arxiv.org/abs/2005.10780>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        slope: float | list[float],\n        offset: float | list[float],\n        domain: tuple[float, float],\n        image: tuple[float, float],\n        rescaling_factor: float = 1,\n        breakpoints: list[float] | None = None,\n        name: str = \"F\",\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits used to encode the variable :math:`x`.\n            slope: The slope of the linear function. Can be a list of slopes if it is a piecewise\n                linear function.\n            offset: The offset of the linear function. Can be a list of offsets if it is a piecewise\n                linear function.\n            domain: The domain of the function as tuple :math:`(x_\\min{}, x_\\max{})`.\n            image: The image of the function as tuple :math:`(f_\\min{}, f_\\max{})`.\n            rescaling_factor: The rescaling factor to adjust the accuracy in the Taylor\n                approximation.\n            breakpoints: The breakpoints if the function is piecewise linear. If None, the function\n                is not piecewise.\n            name: Name of the circuit.\n        \"\"\"\n        if not hasattr(slope, \"__len__\"):\n            slope = [slope]\n        if not hasattr(offset, \"__len__\"):\n            offset = [offset]\n\n        # ensure that the breakpoints include the first point of the domain\n        if breakpoints is None:\n            breakpoints = [domain[0]]\n        else:\n            if not np.isclose(breakpoints[0], domain[0]):\n                breakpoints = [domain[0]] + breakpoints\n\n        _check_sizes_match(slope, offset, breakpoints)\n        _check_sorted_and_in_range(breakpoints, domain)\n\n        self._domain = domain\n        self._image = image\n        self._rescaling_factor = rescaling_factor\n\n        # do rescaling\n        a, b = domain\n        c, d = image\n\n        mapped_breakpoints = []\n        mapped_slope = []\n        mapped_offset = []\n        for i, point in enumerate(breakpoints):\n            mapped_breakpoint = (point - a) / (b - a) * (2**num_state_qubits - 1)\n            mapped_breakpoints += [mapped_breakpoint]\n\n            # factor (upper - lower) / (2^n - 1) is for the scaling of x to [l,u]\n            # note that the +l for mapping to [l,u] is already included in\n            # the offsets given as parameters\n            mapped_slope += [slope[i] * (b - a) / (2**num_state_qubits - 1)]\n            mapped_offset += [offset[i]]\n\n        # approximate linear behavior by scaling and contracting around pi/4\n        slope_angles = np.zeros(len(breakpoints))\n        offset_angles = np.pi / 4 * (1 - rescaling_factor) * np.ones(len(breakpoints))\n        for i in range(len(breakpoints)):\n            slope_angles[i] = np.pi * rescaling_factor * mapped_slope[i] / 2 / (d - c)\n            offset_angles[i] += np.pi * rescaling_factor * (mapped_offset[i] - c) / 2 / (d - c)\n\n        # use PWLPauliRotations to implement the function\n        pwl_pauli_rotation = PiecewiseLinearPauliRotations(\n            num_state_qubits, mapped_breakpoints, 2 * slope_angles, 2 * offset_angles, name=name\n        )\n\n        super().__init__(*pwl_pauli_rotation.qregs, name=name)\n        self.append(pwl_pauli_rotation.to_gate(), self.qubits)\n\n    def post_processing(self, scaled_value: float) -> float:\n        r\"\"\"Map the function value of the approximated :math:`\\hat{f}` to :math:`f`.\n\n        Args:\n            scaled_value: A function value from the Taylor expansion of :math:`\\hat{f}(x)`.\n\n        Returns:\n            The ``scaled_value`` mapped back to the domain of :math:`f`, by first inverting\n            the transformation used for the Taylor approximation and then mapping back from\n            :math:`[0, 1]` to the original domain.\n        \"\"\"\n        # revert the mapping applied in the Taylor approximation\n        value = scaled_value - 1 / 2 + np.pi / 4 * self._rescaling_factor\n        value *= 2 / np.pi / self._rescaling_factor\n\n        # map the value from [0, 1] back to the original domain\n        value *= self._image[1] - self._image[0]\n        value += self._image[0]\n\n        return value\n\n\nclass LinearAmplitudeFunctionGate(Gate):\n    r\"\"\"A circuit implementing a (piecewise) linear function on qubit amplitudes.\n\n    An amplitude function :math:`F` of a function :math:`f` is a mapping\n\n    .. math::\n\n        F|x\\rangle|0\\rangle = \\sqrt{1 - \\hat{f}(x)} |x\\rangle|0\\rangle + \\sqrt{\\hat{f}(x)}\n            |x\\rangle|1\\rangle.\n\n    for a function :math:`\\hat{f}: \\{ 0, ..., 2^n - 1 \\} \\rightarrow [0, 1]`, where\n    :math:`|x\\rangle` is a :math:`n` qubit state.\n\n    This circuit implements :math:`F` for piecewise linear functions :math:`\\hat{f}`.\n    In this case, the mapping :math:`F` can be approximately implemented using a Taylor expansion\n    and linearly controlled Pauli-Y rotations, see [1, 2] for more detail. This approximation\n    uses a ``rescaling_factor`` to determine the accuracy of the Taylor expansion.\n\n    In general, the function of interest :math:`f` is defined from some interval :math:`[a,b]`,\n    the ``domain`` to :math:`[c,d]`, the ``image``, instead of :math:`\\{ 1, ..., N \\}` to\n    :math:`[0, 1]`. Using an affine transformation we can rescale :math:`f` to :math:`\\hat{f}`:\n\n    .. math::\n\n        \\hat{f}(x) = \\frac{f(\\phi(x)) - c}{d - c}\n\n    with\n\n    .. math::\n\n        \\phi(x) = a + \\frac{b - a}{2^n - 1} x.\n\n    If :math:`f` is a piecewise linear function on :math:`m` intervals\n    :math:`[p_{i-1}, p_i], i \\in \\{1, ..., m\\}` with slopes :math:`\\alpha_i` and\n    offsets :math:`\\beta_i` it can be written as\n\n    .. math::\n\n        f(x) = \\sum_{i=1}^m 1_{[p_{i-1}, p_i]}(x) (\\alpha_i x + \\beta_i)\n\n    where :math:`1_{[a, b]}` is an indication function that is 1 if the argument is in the interval\n    :math:`[a, b]` and otherwise 0. The breakpoints :math:`p_i` can be specified by the\n    ``breakpoints`` argument.\n\n    References:\n\n        [1]: Woerner, S., & Egger, D. J. (2018).\n             Quantum Risk Analysis.\n             `arXiv:1806.06893 <http://arxiv.org/abs/1806.06893>`_\n\n        [2]: Gacon, J., Zoufal, C., & Woerner, S. (2020).\n             Quantum-Enhanced Simulation-Based Optimization.\n             `arXiv:2005.10780 <http://arxiv.org/abs/2005.10780>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        slope: float | list[float],\n        offset: float | list[float],\n        domain: tuple[float, float],\n        image: tuple[float, float],\n        rescaling_factor: float = 1,\n        breakpoints: list[float] | None = None,\n        label: str = \"F\",\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits used to encode the variable :math:`x`.\n            slope: The slope of the linear function. Can be a list of slopes if it is a piecewise\n                linear function.\n            offset: The offset of the linear function. Can be a list of offsets if it is a piecewise\n                linear function.\n            domain: The domain of the function as tuple :math:`(x_\\min{}, x_\\max{})`.\n            image: The image of the function as tuple :math:`(f_\\min{}, f_\\max{})`.\n            rescaling_factor: The rescaling factor to adjust the accuracy in the Taylor\n                approximation.\n            breakpoints: The breakpoints if the function is piecewise linear. If None, the function\n                is not piecewise.\n            label: A label for the gate.\n        \"\"\"\n        if not hasattr(slope, \"__len__\"):\n            slope = [slope]\n        if not hasattr(offset, \"__len__\"):\n            offset = [offset]\n\n        # ensure that the breakpoints include the first point of the domain\n        if breakpoints is None:\n            breakpoints = [domain[0]]\n        else:\n            if not np.isclose(breakpoints[0], domain[0]):\n                breakpoints = [domain[0]] + breakpoints\n\n        _check_sizes_match(slope, offset, breakpoints)\n        _check_sorted_and_in_range(breakpoints, domain)\n\n        self.slope = slope\n        self.offset = offset\n        self.domain = domain\n        self.image = image\n        self.rescaling_factor = rescaling_factor\n        self.breakpoints = breakpoints\n\n        num_compare = int(len(breakpoints) > 1)\n        super().__init__(\"LinFunction\", num_state_qubits + num_compare + 1, [], label=label)\n\n    def _define(self):\n        num_compare = int(len(self.breakpoints) > 1)\n        num_state_qubits = self.num_qubits - num_compare - 1\n\n        # do rescaling\n        a, b = self.domain\n        c, d = self.image\n\n        mapped_breakpoints = []\n        mapped_slope = []\n        mapped_offset = []\n        for i, point in enumerate(self.breakpoints):\n            mapped_breakpoint = (point - a) / (b - a) * (2**num_state_qubits - 1)\n            mapped_breakpoints += [mapped_breakpoint]\n\n            # factor (upper - lower) / (2^n - 1) is for the scaling of x to [l,u]\n            # note that the +l for mapping to [l,u] is already included in\n            # the offsets given as parameters\n            mapped_slope += [self.slope[i] * (b - a) / (2**num_state_qubits - 1)]\n            mapped_offset += [self.offset[i]]\n\n        # approximate linear behavior by scaling and contracting around pi/4\n        slope_angles = np.zeros(len(self.breakpoints))\n        offset_angles = np.pi / 4 * (1 - self.rescaling_factor) * np.ones_like(slope_angles)\n        for i, (slope_i, offset_i) in enumerate(zip(mapped_slope, mapped_offset)):\n            slope_angles[i] = np.pi * self.rescaling_factor * slope_i / 2 / (d - c)\n            offset_angles[i] += np.pi * self.rescaling_factor * (offset_i - c) / 2 / (d - c)\n\n        # use PWLPauliRotations to implement the function\n        pwl_pauli_rotation = PiecewiseLinearPauliRotationsGate(\n            num_state_qubits, mapped_breakpoints, 2 * slope_angles, 2 * offset_angles\n        )\n\n        self.definition = QuantumCircuit(pwl_pauli_rotation.num_qubits)\n        self.definition.append(pwl_pauli_rotation, self.definition.qubits)\n\n    def post_processing(self, scaled_value: float) -> float:\n        r\"\"\"Map the function value of the approximated :math:`\\hat{f}` to :math:`f`.\n\n        Args:\n            scaled_value: A function value from the Taylor expansion of :math:`\\hat{f}(x)`.\n\n        Returns:\n            The ``scaled_value`` mapped back to the domain of :math:`f`, by first inverting\n            the transformation used for the Taylor approximation and then mapping back from\n            :math:`[0, 1]` to the original domain.\n        \"\"\"\n        # revert the mapping applied in the Taylor approximation\n        value = scaled_value - 1 / 2 + np.pi / 4 * self.rescaling_factor\n        value *= 2 / np.pi / self.rescaling_factor\n\n        # map the value from [0, 1] back to the original domain\n        value *= self.image[1] - self.image[0]\n        value += self.image[0]\n\n        return value\n\n\ndef _check_sorted_and_in_range(breakpoints, domain):\n    if breakpoints is None:\n        return\n\n    # check if sorted\n    if not np.all(np.diff(breakpoints) > 0):\n        raise ValueError(\"Breakpoints must be unique and sorted.\")\n\n    if breakpoints[0] < domain[0] or breakpoints[-1] > domain[1]:\n        raise ValueError(\"Breakpoints must be included in domain.\")\n\n\ndef _check_sizes_match(slope, offset, breakpoints):\n    size = len(slope)\n    if len(offset) != size:\n        raise ValueError(f\"Size mismatch of slope ({size}) and offset ({len(offset)}).\")\n    if breakpoints is not None:\n        if len(breakpoints) != size:\n            raise ValueError(\n                f\"Size mismatch of slope ({size}) and breakpoints ({len(breakpoints)}).\"\n            )\n",
    "line_count": 364
  },
  {
    "filename": "linear_pauli_rotations.py",
    "path": "qiskit/circuit/library/arithmetic/linear_pauli_rotations.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Linearly-controlled X, Y or Z rotation.\"\"\"\n\nfrom __future__ import annotations\nfrom typing import Optional\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .functional_pauli_rotations import FunctionalPauliRotations\n\n\nclass LinearPauliRotations(FunctionalPauliRotations):\n    r\"\"\"Linearly-controlled X, Y or Z rotation.\n\n    For a register of state qubits :math:`|x\\rangle`, a target qubit :math:`|0\\rangle` and the\n    basis ``'Y'`` this circuit acts as:\n\n    .. code-block:: text\n\n            q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                          \u2502\n                                          .\n                                          \u2502\n        q_(n-1): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            q_n: \u2500\u2524 RY(offset) \u251c\u2500\u2500\u2524 RY(2^0 slope) \u251c  ...  \u2524 RY(2^(n-1) slope) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This can for example be used to approximate linear functions, with :math:`a =` ``slope``:math:`/2`\n    and :math:`b =` ``offset``:math:`/2` and the basis ``'Y'``:\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(ax + b)|x\\rangle|0\\rangle + \\sin(ax + b)|x\\rangle |1\\rangle\n\n    Since for small arguments :math:`\\sin(x) \\approx x` this operator can be used to approximate\n    linear functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: Optional[int] = None,\n        slope: float = 1,\n        offset: float = 0,\n        basis: str = \"Y\",\n        name: str = \"LinRot\",\n    ) -> None:\n        r\"\"\"Create a new linear rotation circuit.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n            slope: The slope of the controlled rotation.\n            offset: The offset of the controlled rotation.\n            basis: The type of Pauli rotation ('X', 'Y', 'Z').\n            name: The name of the circuit object.\n        \"\"\"\n        super().__init__(num_state_qubits=num_state_qubits, basis=basis, name=name)\n\n        # define internal parameters\n        self._slope = None\n        self._offset = None\n\n        # store parameters\n        self.slope = slope\n        self.offset = offset\n\n    @property\n    def slope(self) -> float:\n        \"\"\"The multiplicative factor in the rotation angle of the controlled rotations.\n\n        The rotation angles are ``slope * 2^0``, ``slope * 2^1``, ... , ``slope * 2^(n-1)`` where\n        ``n`` is the number of state qubits.\n\n        Returns:\n            The rotation angle common in all controlled rotations.\n        \"\"\"\n        return self._slope\n\n    @slope.setter\n    def slope(self, slope: float) -> None:\n        \"\"\"Set the multiplicative factor of the rotation angles.\n\n        Args:\n            The slope of the rotation angles.\n        \"\"\"\n        if self._slope is None or slope != self._slope:\n            self._invalidate()\n            self._slope = slope\n\n    @property\n    def offset(self) -> float:\n        \"\"\"The angle of the single qubit offset rotation on the target qubit.\n\n        Before applying the controlled rotations, a single rotation of angle ``offset`` is\n        applied to the target qubit.\n\n        Returns:\n            The offset angle.\n        \"\"\"\n        return self._offset\n\n    @offset.setter\n    def offset(self, offset: float) -> None:\n        \"\"\"Set the angle for the offset rotation on the target qubit.\n\n        Args:\n            offset: The offset rotation angle.\n        \"\"\"\n        if self._offset is None or offset != self._offset:\n            self._invalidate()\n            self._offset = offset\n\n    def _reset_registers(self, num_state_qubits: Optional[int]) -> None:\n        \"\"\"Set the number of state qubits.\n\n        Note that this changes the underlying quantum register, if the number of state qubits\n        changes.\n\n        Args:\n            num_state_qubits: The new number of qubits.\n        \"\"\"\n        self.qregs = []\n\n        if num_state_qubits:\n            # set new register of appropriate size\n            qr_state = QuantumRegister(num_state_qubits, name=\"state\")\n            qr_target = QuantumRegister(1, name=\"target\")\n            self.qregs = [qr_state, qr_target]\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n\n        if self.num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of qubits has not been set.\")\n\n        if self.num_qubits < self.num_state_qubits + 1:\n            valid = False\n            if raise_on_failure:\n                raise CircuitError(\n                    \"Not enough qubits in the circuit, need at least \"\n                    f\"{self.num_state_qubits + 1}.\"\n                )\n\n        return valid\n\n    def _build(self):\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n        gate = LinearPauliRotationsGate(self.num_state_qubits, self.slope, self.offset, self.basis)\n        self.append(gate, self.qubits)\n\n\nclass LinearPauliRotationsGate(Gate):\n    r\"\"\"Linearly-controlled X, Y or Z rotation.\n\n    For a register of state qubits :math:`|x\\rangle`, a target qubit :math:`|0\\rangle` and the\n    basis ``'Y'`` this circuit acts as:\n\n    .. parsed-literal::\n\n            q_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                          \u2502\n                                          .\n                                          \u2502\n        q_(n-1): \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            q_n: \u2500\u2524 RY(offset) \u251c\u2500\u2500\u2524 RY(2^0 slope) \u251c  ...  \u2524 RY(2^(n-1) slope) \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This can for example be used to approximate linear functions, with :math:`a =` ``slope``:math:`/2`\n    and :math:`b =` ``offset``:math:`/2` and the basis ``'Y'``:\n\n    .. math::\n\n        |x\\rangle |0\\rangle \\mapsto \\cos(ax + b)|x\\rangle|0\\rangle + \\sin(ax + b)|x\\rangle |1\\rangle\n\n    Since for small arguments :math:`\\sin(x) \\approx x` this operator can be used to approximate\n    linear functions.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        slope: float = 1,\n        offset: float = 0,\n        basis: str = \"Y\",\n        label: str | None = None,\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits representing the state :math:`|x\\rangle`.\n            slope: The slope of the controlled rotation.\n            offset: The offset of the controlled rotation.\n            basis: The type of Pauli rotation ('X', 'Y', 'Z').\n            label: The label of the gate.\n        \"\"\"\n        super().__init__(\"LinPauliRot\", num_state_qubits + 1, [], label=label)\n        self.slope = slope\n        self.offset = offset\n        self.basis = basis.lower()\n\n    def _define(self):\n        circuit = QuantumCircuit(self.num_qubits, name=self.name)\n\n        # build the circuit\n        qr_state = circuit.qubits[: self.num_qubits - 1]\n        qr_target = circuit.qubits[-1]\n\n        if self.basis == \"x\":\n            circuit.rx(self.offset, qr_target)\n        elif self.basis == \"y\":\n            circuit.ry(self.offset, qr_target)\n        else:  # 'Z':\n            circuit.rz(self.offset, qr_target)\n\n        for i, q_i in enumerate(qr_state):\n            if self.basis == \"x\":\n                circuit.crx(self.slope * pow(2, i), q_i, qr_target)\n            elif self.basis == \"y\":\n                circuit.cry(self.slope * pow(2, i), q_i, qr_target)\n            else:  # 'Z'\n                circuit.crz(self.slope * pow(2, i), q_i, qr_target)\n\n        self.definition = circuit\n",
    "line_count": 244
  },
  {
    "filename": "piecewise_linear_pauli_rotations.py",
    "path": "qiskit/circuit/library/arithmetic/piecewise_linear_pauli_rotations.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Piecewise-linearly-controlled rotation.\"\"\"\n\nfrom __future__ import annotations\nfrom collections.abc import Sequence\nimport numpy as np\n\nfrom qiskit.circuit import QuantumRegister, AncillaRegister, QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .functional_pauli_rotations import FunctionalPauliRotations\nfrom .linear_pauli_rotations import LinearPauliRotations, LinearPauliRotationsGate\nfrom .integer_comparator import IntegerComparator, IntegerComparatorGate\n\n\nclass PiecewiseLinearPauliRotations(FunctionalPauliRotations):\n    r\"\"\"Piecewise-linearly-controlled Pauli rotations.\n\n    For a piecewise linear (not necessarily continuous) function :math:`f(x)`, which is defined\n    through breakpoints, slopes and offsets as follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding slopes and\n    offsets by :math:`a_j` and :math:`b_j` respectively.\n    Then f(x) is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            a_j (x - x_j) + b_j, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where we implicitly assume :math:`x_{J+1} = 2^n`.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int | None = None,\n        breakpoints: list[int] | None = None,\n        slopes: list[float] | np.ndarray | None = None,\n        offsets: list[float] | np.ndarray | None = None,\n        basis: str = \"Y\",\n        name: str = \"pw_lin\",\n    ) -> None:\n        \"\"\"Construct piecewise-linearly-controlled Pauli rotations.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            breakpoints: The breakpoints to define the piecewise-linear function.\n                Defaults to ``[0]``.\n            slopes: The slopes for different segments of the piecewise-linear function.\n                Defaults to ``[1]``.\n            offsets: The offsets for different segments of the piecewise-linear function.\n                Defaults to ``[0]``.\n            basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n            name: The name of the circuit.\n        \"\"\"\n        # store parameters\n        self._breakpoints = breakpoints if breakpoints is not None else [0]\n        self._slopes = slopes if slopes is not None else [1]\n        self._offsets = offsets if offsets is not None else [0]\n\n        super().__init__(num_state_qubits=num_state_qubits, basis=basis, name=name)\n\n    @property\n    def breakpoints(self) -> list[int]:\n        \"\"\"The breakpoints of the piecewise linear function.\n\n        The function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\n        point implicitly is ``2**(num_state_qubits + 1)``.\n        \"\"\"\n        return self._breakpoints\n\n    @breakpoints.setter\n    def breakpoints(self, breakpoints: list[int]) -> None:\n        \"\"\"Set the breakpoints.\n\n        Args:\n            breakpoints: The new breakpoints.\n        \"\"\"\n        self._invalidate()\n        self._breakpoints = breakpoints\n\n        if self.num_state_qubits and breakpoints:\n            self._reset_registers(self.num_state_qubits)\n\n    @property\n    def slopes(self) -> list[float] | np.ndarray:\n        \"\"\"The breakpoints of the piecewise linear function.\n\n        The function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\n        point implicitly is ``2**(num_state_qubits + 1)``.\n        \"\"\"\n        return self._slopes\n\n    @slopes.setter\n    def slopes(self, slopes: list[float]) -> None:\n        \"\"\"Set the slopes.\n\n        Args:\n            slopes: The new slopes.\n        \"\"\"\n        self._invalidate()\n        self._slopes = slopes\n\n    @property\n    def offsets(self) -> list[float] | np.ndarray:\n        \"\"\"The breakpoints of the piecewise linear function.\n\n        The function is linear in the intervals ``[point_i, point_{i+1}]`` where the last\n        point implicitly is ``2**(num_state_qubits + 1)``.\n        \"\"\"\n        return self._offsets\n\n    @offsets.setter\n    def offsets(self, offsets: list[float]) -> None:\n        \"\"\"Set the offsets.\n\n        Args:\n            offsets: The new offsets.\n        \"\"\"\n        self._invalidate()\n        self._offsets = offsets\n\n    @property\n    def mapped_slopes(self) -> np.ndarray:\n        \"\"\"The slopes mapped to the internal representation.\n\n        Returns:\n            The mapped slopes.\n        \"\"\"\n        mapped_slopes = np.zeros_like(self.slopes)\n        for i, slope in enumerate(self.slopes):\n            mapped_slopes[i] = slope - sum(mapped_slopes[:i])\n\n        return mapped_slopes\n\n    @property\n    def mapped_offsets(self) -> np.ndarray:\n        \"\"\"The offsets mapped to the internal representation.\n\n        Returns:\n            The mapped offsets.\n        \"\"\"\n        mapped_offsets = np.zeros_like(self.offsets)\n        for i, (offset, slope, point) in enumerate(\n            zip(self.offsets, self.slopes, self.breakpoints)\n        ):\n            mapped_offsets[i] = offset - slope * point - sum(mapped_offsets[:i])\n\n        return mapped_offsets\n\n    @property\n    def contains_zero_breakpoint(self) -> bool | np.bool_:\n        \"\"\"Whether 0 is the first breakpoint.\n\n        Returns:\n            True, if 0 is the first breakpoint, otherwise False.\n        \"\"\"\n        return np.isclose(0, self.breakpoints[0])\n\n    def evaluate(self, x: float) -> float:\n        \"\"\"Classically evaluate the piecewise linear rotation.\n\n        Args:\n            x: Value to be evaluated at.\n\n        Returns:\n            Value of piecewise linear function at x.\n        \"\"\"\n\n        y = (x >= self.breakpoints[0]) * (x * self.mapped_slopes[0] + self.mapped_offsets[0])\n        for i in range(1, len(self.breakpoints)):\n            y = y + (x >= self.breakpoints[i]) * (\n                x * self.mapped_slopes[i] + self.mapped_offsets[i]\n            )\n\n        return y\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n\n        if self.num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of qubits has not been set.\")\n\n        if self.num_qubits < self.num_state_qubits + 1:\n            valid = False\n            if raise_on_failure:\n                raise CircuitError(\n                    \"Not enough qubits in the circuit, need at least \"\n                    f\"{self.num_state_qubits + 1}.\"\n                )\n\n        if len(self.breakpoints) != len(self.slopes) or len(self.breakpoints) != len(self.offsets):\n            valid = False\n            if raise_on_failure:\n                raise ValueError(\"Mismatching sizes of breakpoints, slopes and offsets.\")\n\n        return valid\n\n    def _reset_registers(self, num_state_qubits: int | None) -> None:\n        \"\"\"Reset the registers.\"\"\"\n        self.qregs = []\n\n        if num_state_qubits is not None:\n            qr_state = QuantumRegister(num_state_qubits)\n            qr_target = QuantumRegister(1)\n            self.qregs = [qr_state, qr_target]\n\n            # add ancillas if required\n            if len(self.breakpoints) > 1:\n                num_ancillas = num_state_qubits\n                qr_ancilla = AncillaRegister(num_ancillas)\n                self.add_register(qr_ancilla)\n\n    def _build(self):\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        circuit = QuantumCircuit(*self.qregs, name=self.name)\n\n        qr_state = circuit.qubits[: self.num_state_qubits]\n        qr_target = [circuit.qubits[self.num_state_qubits]]\n        qr_ancilla = circuit.ancillas\n\n        # apply comparators and controlled linear rotations\n        for i, point in enumerate(self.breakpoints):\n            if i == 0 and self.contains_zero_breakpoint:\n                # apply rotation\n                lin_r = LinearPauliRotations(\n                    num_state_qubits=self.num_state_qubits,\n                    slope=self.mapped_slopes[i],\n                    offset=self.mapped_offsets[i],\n                    basis=self.basis,\n                )\n                circuit.append(lin_r.to_gate(), qr_state[:] + qr_target)\n\n            else:\n                qr_compare = [qr_ancilla[0]]\n                qr_helper = qr_ancilla[1:]\n\n                # apply Comparator\n                comp = IntegerComparator(num_state_qubits=self.num_state_qubits, value=point)\n                qr = qr_state[:] + qr_compare[:]  # add ancilla as compare qubit\n\n                circuit.append(comp.to_gate(), qr[:] + qr_helper[: comp.num_ancillas])\n\n                # apply controlled rotation\n                lin_r = LinearPauliRotations(\n                    num_state_qubits=self.num_state_qubits,\n                    slope=self.mapped_slopes[i],\n                    offset=self.mapped_offsets[i],\n                    basis=self.basis,\n                )\n                circuit.append(lin_r.to_gate().control(), qr_compare[:] + qr_state[:] + qr_target)\n\n                # uncompute comparator\n                circuit.append(comp.to_gate(), qr[:] + qr_helper[: comp.num_ancillas])\n\n        self.append(circuit.to_gate(), self.qubits)\n\n\nclass PiecewiseLinearPauliRotationsGate(Gate):\n    r\"\"\"Piecewise-linearly-controlled Pauli rotations.\n\n    For a piecewise linear (not necessarily continuous) function :math:`f(x)`, which is defined\n    through breakpoints, slopes and offsets as follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding slopes and\n    offsets by :math:`a_j` and :math:`b_j` respectively.\n    Then f(x) is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            a_j (x - x_j) + b_j, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where we implicitly assume :math:`x_{J+1} = 2^n`.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int | None = None,\n        breakpoints: list[int] | None = None,\n        slopes: Sequence[float] | None = None,\n        offsets: Sequence[float] | None = None,\n        basis: str = \"Y\",\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Construct piecewise-linearly-controlled Pauli rotations.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            breakpoints: The breakpoints to define the piecewise-linear function.\n                Defaults to ``[0]``.\n            slopes: The slopes for different segments of the piecewise-linear function.\n                Defaults to ``[1]``.\n            offsets: The offsets for different segments of the piecewise-linear function.\n                Defaults to ``[0]``.\n            basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n            label: The label of the gate.\n        \"\"\"\n        self.breakpoints = breakpoints if breakpoints is not None else [0]\n        self.slopes = slopes if slopes is not None else [1]\n        self.offsets = offsets if offsets is not None else [0]\n        self.basis = basis\n\n        num_compare_bits = 1 if len(self.breakpoints) > 1 else 0\n        super().__init__(\"PwLinPauliRot\", num_state_qubits + 1 + num_compare_bits, [], label=label)\n\n    def _define(self):\n        circuit = QuantumCircuit(self.num_qubits, name=self.name)\n\n        if len(self.breakpoints) == 1:\n            qr_state = circuit.qubits[: self.num_qubits - 1]\n            qr_target = [circuit.qubits[-1]]\n            qr_compare = []\n        else:\n            qr_state = circuit.qubits[: self.num_qubits - 2]\n            qr_target = [circuit.qubits[-2]]\n            qr_compare = [circuit.qubits[-1]]\n\n        num_state_qubits = len(qr_state)\n\n        mapped_slopes = np.zeros_like(self.slopes)\n        for i, slope in enumerate(self.slopes):\n            mapped_slopes[i] = slope - sum(mapped_slopes[:i])\n\n        mapped_offsets = np.zeros_like(self.offsets)\n        for i, (offset, slope, point) in enumerate(\n            zip(self.offsets, self.slopes, self.breakpoints)\n        ):\n            mapped_offsets[i] = offset - slope * point - sum(mapped_offsets[:i])\n\n        # apply comparators and controlled linear rotations\n        contains_zero_breakpoint = np.isclose(self.breakpoints[0], 0)\n        for i, point in enumerate(self.breakpoints):\n            if i == 0 and contains_zero_breakpoint:\n                # apply rotation\n                lin_r = LinearPauliRotationsGate(\n                    num_state_qubits=num_state_qubits,\n                    slope=mapped_slopes[i],\n                    offset=mapped_offsets[i],\n                    basis=self.basis,\n                )\n                circuit.append(lin_r, qr_state[:] + qr_target)\n\n            else:\n                # apply Comparator\n                comp = IntegerComparatorGate(num_state_qubits=num_state_qubits, value=point)\n                qr = qr_state[:] + qr_compare[:]  # add ancilla as compare qubit\n\n                circuit.append(comp, qr[:])\n\n                # apply controlled rotation\n                lin_r = LinearPauliRotationsGate(\n                    num_state_qubits=num_state_qubits,\n                    slope=mapped_slopes[i],\n                    offset=mapped_offsets[i],\n                    basis=self.basis,\n                )\n                circuit.append(lin_r.control(), qr_compare[:] + qr_state[:] + qr_target)\n\n                # uncompute comparator (which is its self-inverse)\n                circuit.append(comp, qr[:])\n\n        self.definition = circuit\n",
    "line_count": 388
  },
  {
    "filename": "piecewise_polynomial_pauli_rotations.py",
    "path": "qiskit/circuit/library/arithmetic/piecewise_polynomial_pauli_rotations.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Piecewise-polynomially-controlled Pauli rotations.\"\"\"\n\nfrom __future__ import annotations\nfrom typing import List, Optional\nimport numpy as np\n\nfrom qiskit.circuit import QuantumRegister, AncillaRegister, QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .functional_pauli_rotations import FunctionalPauliRotations\nfrom .polynomial_pauli_rotations import PolynomialPauliRotations, PolynomialPauliRotationsGate\nfrom .integer_comparator import IntegerComparator, IntegerComparatorGate\n\n\nclass PiecewisePolynomialPauliRotations(FunctionalPauliRotations):\n    r\"\"\"Piecewise-polynomially-controlled Pauli rotations.\n\n    This class implements a piecewise polynomial (not necessarily continuous) function,\n    :math:`f(x)`, on qubit amplitudes, which is defined through breakpoints and coefficients as\n    follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding coefficients by\n    :math:`[a_{j,1},...,a_{j,d}]`, where :math:`d` is the highest degree among all polynomials.\n\n    Then :math:`f(x)` is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            \\sum_{i=0}^{i=d}a_{j,i}/2 x^i, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where if given the same number of breakpoints as polynomials, we implicitly assume\n    :math:`x_{J+1} = 2^n`.\n\n    .. note::\n\n        Note the :math:`1/2` factor in the coefficients of :math:`f(x)`, this is consistent with\n        Qiskit's Pauli rotations.\n\n    Examples:\n        >>> from qiskit import QuantumCircuit\n        >>> from qiskit.circuit.library.arithmetic.piecewise_polynomial_pauli_rotations import\\\n        ... PiecewisePolynomialPauliRotations\n        >>> qubits, breakpoints, coeffs = (2, [0, 2], [[0, -1.2],[-1, 1, 3]])\n        >>> poly_r = PiecewisePolynomialPauliRotations(num_state_qubits=qubits,\n        ...breakpoints=breakpoints, coeffs=coeffs)\n        >>>\n        >>> qc = QuantumCircuit(poly_r.num_qubits)\n        >>> qc.h(list(range(qubits)));\n        >>> qc.append(poly_r.to_instruction(), list(range(qc.num_qubits)));\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u25240         \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2502          \u2502\n        q_1: \u2524 H \u251c\u25241         \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2502          \u2502\n        q_2: \u2500\u2500\u2500\u2500\u2500\u25242         \u251c\n                  \u2502  pw_poly \u2502\n        q_3: \u2500\u2500\u2500\u2500\u2500\u25243         \u251c\n                  \u2502          \u2502\n        q_4: \u2500\u2500\u2500\u2500\u2500\u25244         \u251c\n                  \u2502          \u2502\n        q_5: \u2500\u2500\u2500\u2500\u2500\u25245         \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    References:\n        [1]: Haener, T., Roetteler, M., & Svore, K. M. (2018).\n             Optimizing Quantum Circuits for Arithmetic.\n             `arXiv:1805.12445 <http://arxiv.org/abs/1805.12445>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2022).\n             Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n             `ACM Transactions on Quantum Computing 3, 1, Article 2 <https://doi.org/10.1145/3490631>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: Optional[int] = None,\n        breakpoints: Optional[List[int]] = None,\n        coeffs: Optional[List[List[float]]] = None,\n        basis: str = \"Y\",\n        name: str = \"pw_poly\",\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            breakpoints: The breakpoints to define the piecewise-linear function.\n                Defaults to ``[0]``.\n            coeffs: The coefficients of the polynomials for different segments of the\n                piecewise-linear function. ``coeffs[j][i]`` is the coefficient of the i-th power of x\n                for the j-th polynomial.\n                Defaults to linear: ``[[1]]``.\n            basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n            name: The name of the circuit.\n        \"\"\"\n        # store parameters\n        self._breakpoints = breakpoints if breakpoints is not None else [0]\n        self._coeffs = coeffs if coeffs is not None else [[1]]\n\n        # store a list of coefficients as homogeneous polynomials adding 0's where necessary\n        self._hom_coeffs = []\n        self._degree = len(max(self._coeffs, key=len)) - 1\n        for poly in self._coeffs:\n            self._hom_coeffs.append(poly + [0] * (self._degree + 1 - len(poly)))\n\n        super().__init__(num_state_qubits=num_state_qubits, basis=basis, name=name)\n\n    @property\n    def breakpoints(self) -> List[int]:\n        \"\"\"The breakpoints of the piecewise polynomial function.\n\n        The function is polynomial in the intervals ``[point_i, point_{i+1}]`` where the last\n        point implicitly is ``2**(num_state_qubits + 1)``.\n\n        Returns:\n            The list of breakpoints.\n        \"\"\"\n        if (\n            self.num_state_qubits is not None\n            and len(self._breakpoints) == len(self.coeffs)\n            and self._breakpoints[-1] < 2**self.num_state_qubits\n        ):\n            return self._breakpoints + [2**self.num_state_qubits]\n\n        return self._breakpoints\n\n    @breakpoints.setter\n    def breakpoints(self, breakpoints: List[int]) -> None:\n        \"\"\"Set the breakpoints.\n\n        Args:\n            breakpoints: The new breakpoints.\n        \"\"\"\n        self._invalidate()\n        self._breakpoints = breakpoints\n\n        if self.num_state_qubits and breakpoints:\n            self._reset_registers(self.num_state_qubits)\n\n    @property\n    def coeffs(self) -> List[List[float]]:\n        \"\"\"The coefficients of the polynomials.\n\n        Returns:\n            The polynomial coefficients per interval as nested lists.\n        \"\"\"\n        return self._coeffs\n\n    @coeffs.setter\n    def coeffs(self, coeffs: List[List[float]]) -> None:\n        \"\"\"Set the polynomials.\n\n        Args:\n            coeffs: The new polynomials.\n        \"\"\"\n        self._invalidate()\n        self._coeffs = coeffs\n\n        # update the homogeneous polynomials and degree\n        self._hom_coeffs = []\n        self._degree = len(max(self._coeffs, key=len)) - 1\n        for poly in self._coeffs:\n            self._hom_coeffs.append(poly + [0] * (self._degree + 1 - len(poly)))\n\n        if self.num_state_qubits and coeffs:\n            self._reset_registers(self.num_state_qubits)\n\n    @property\n    def mapped_coeffs(self) -> List[List[float]]:\n        \"\"\"The coefficients mapped to the internal representation, since we only compare\n        x>=breakpoint.\n\n        Returns:\n            The mapped coefficients.\n        \"\"\"\n        return _map_coeffs(self._hom_coeffs)\n\n    @property\n    def contains_zero_breakpoint(self) -> bool | np.bool_:\n        \"\"\"Whether 0 is the first breakpoint.\n\n        Returns:\n            True, if 0 is the first breakpoint, otherwise False.\n        \"\"\"\n        return np.isclose(0, self.breakpoints[0])\n\n    def evaluate(self, x: float) -> float:\n        \"\"\"Classically evaluate the piecewise polynomial rotation.\n\n        Args:\n            x: Value to be evaluated at.\n\n        Returns:\n            Value of piecewise polynomial function at x.\n        \"\"\"\n\n        y = 0\n        for i, breakpt in enumerate(self.breakpoints):\n            y = y + (x >= breakpt) * (np.poly1d(self.mapped_coeffs[i][::-1])(x))\n\n        return y\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n\n        if self.num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of qubits has not been set.\")\n\n        if self.num_qubits < self.num_state_qubits + 1:\n            valid = False\n            if raise_on_failure:\n                raise CircuitError(\n                    \"Not enough qubits in the circuit, need at least \"\n                    f\"{self.num_state_qubits + 1}.\"\n                )\n\n        if len(self.breakpoints) != len(self.coeffs) + 1:\n            valid = False\n            if raise_on_failure:\n                raise ValueError(\"Mismatching number of breakpoints and polynomials.\")\n\n        return valid\n\n    def _reset_registers(self, num_state_qubits: Optional[int]) -> None:\n        \"\"\"Reset the registers.\"\"\"\n        self.qregs = []\n\n        if num_state_qubits:\n            qr_state = QuantumRegister(num_state_qubits)\n            qr_target = QuantumRegister(1)\n            self.qregs = [qr_state, qr_target]\n\n            # Calculate number of ancilla qubits required\n            num_ancillas = num_state_qubits + 1\n            if self.contains_zero_breakpoint:\n                num_ancillas -= 1\n            if num_ancillas > 0:\n                qr_ancilla = AncillaRegister(num_ancillas)\n                self.add_register(qr_ancilla)\n\n    def _build(self):\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        circuit = QuantumCircuit(*self.qregs, name=self.name)\n        qr_state = circuit.qubits[: self.num_state_qubits]\n        qr_target = [circuit.qubits[self.num_state_qubits]]\n        # Ancilla for the comparator circuit\n        qr_ancilla = circuit.qubits[self.num_state_qubits + 1 :]\n\n        # apply comparators and controlled linear rotations\n        for i, point in enumerate(self.breakpoints[:-1]):\n            if i == 0 and self.contains_zero_breakpoint:\n                # apply rotation\n                poly_r = PolynomialPauliRotations(\n                    num_state_qubits=self.num_state_qubits,\n                    coeffs=self.mapped_coeffs[i],\n                    basis=self.basis,\n                )\n                circuit.append(poly_r.to_gate(), qr_state[:] + qr_target)\n\n            else:\n                # apply Comparator\n                comp = IntegerComparator(num_state_qubits=self.num_state_qubits, value=point)\n                qr_state_full = qr_state[:] + [qr_ancilla[0]]  # add compare qubit\n                qr_remaining_ancilla = qr_ancilla[1:]  # take remaining ancillas\n\n                circuit.append(\n                    comp.to_gate(), qr_state_full[:] + qr_remaining_ancilla[: comp.num_ancillas]\n                )\n\n                # apply controlled rotation\n                poly_r = PolynomialPauliRotations(\n                    num_state_qubits=self.num_state_qubits,\n                    coeffs=self.mapped_coeffs[i],\n                    basis=self.basis,\n                )\n                circuit.append(\n                    poly_r.to_gate().control(), [qr_ancilla[0]] + qr_state[:] + qr_target\n                )\n\n                # uncompute comparator\n                circuit.append(\n                    comp.to_gate().inverse(),\n                    qr_state_full[:] + qr_remaining_ancilla[: comp.num_ancillas],\n                )\n\n        self.append(circuit.to_gate(), self.qubits)\n\n\nclass PiecewisePolynomialPauliRotationsGate(Gate):\n    r\"\"\"Piecewise-polynomially-controlled Pauli rotations.\n\n    This class implements a piecewise polynomial (not necessarily continuous) function,\n    :math:`f(x)`, on qubit amplitudes, which is defined through breakpoints and coefficients as\n    follows.\n    Suppose the breakpoints :math:`(x_0, ..., x_J)` are a subset of :math:`[0, 2^n-1]`, where\n    :math:`n` is the number of state qubits. Further on, denote the corresponding coefficients by\n    :math:`[a_{j,1},...,a_{j,d}]`, where :math:`d` is the highest degree among all polynomials.\n\n    Then :math:`f(x)` is defined as:\n\n    .. math::\n\n        f(x) = \\begin{cases}\n            0, x < x_0 \\\\\n            \\sum_{i=0}^{i=d}a_{j,i}/2 x^i, x_j \\leq x < x_{j+1}\n            \\end{cases}\n\n    where if given the same number of breakpoints as polynomials, we implicitly assume\n    :math:`x_{J+1} = 2^n`.\n\n    .. note::\n\n        Note the :math:`1/2` factor in the coefficients of :math:`f(x)`, this is consistent with\n        Qiskit's Pauli rotations.\n\n    Examples:\n        >>> from qiskit import QuantumCircuit\n        >>> from qiskit.circuit.library.arithmetic.piecewise_polynomial_pauli_rotations import\\\n        ... PiecewisePolynomialPauliRotations\n        >>> qubits, breakpoints, coeffs = (2, [0, 2], [[0, -1.2],[-1, 1, 3]])\n        >>> poly_r = PiecewisePolynomialPauliRotations(num_state_qubits=qubits,\n        ...breakpoints=breakpoints, coeffs=coeffs)\n        >>>\n        >>> qc = QuantumCircuit(poly_r.num_qubits)\n        >>> qc.h(list(range(qubits)));\n        >>> qc.append(poly_r.to_instruction(), list(range(qc.num_qubits)));\n        >>> qc.draw()\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u25240         \u251c\n             \u251c\u2500\u2500\u2500\u2524\u2502          \u2502\n        q_1: \u2524 H \u251c\u25241         \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2502          \u2502\n        q_2: \u2500\u2500\u2500\u2500\u2500\u25242         \u251c\n                  \u2502  pw_poly \u2502\n        q_3: \u2500\u2500\u2500\u2500\u2500\u25243         \u251c\n                  \u2502          \u2502\n        q_4: \u2500\u2500\u2500\u2500\u2500\u25244         \u251c\n                  \u2502          \u2502\n        q_5: \u2500\u2500\u2500\u2500\u2500\u25245         \u251c\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    References:\n        [1]: Haener, T., Roetteler, M., & Svore, K. M. (2018).\n             Optimizing Quantum Circuits for Arithmetic.\n             `arXiv:1805.12445 <http://arxiv.org/abs/1805.12445>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2022).\n             Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n             `ACM Transactions on Quantum Computing 3, 1, Article 2 <https://doi.org/10.1145/3490631>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        breakpoints: list[int] | None = None,\n        coeffs: list[list[float]] | None = None,\n        basis: str = \"Y\",\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            breakpoints: The breakpoints to define the piecewise-linear function.\n                Defaults to ``[0]``.\n            coeffs: The coefficients of the polynomials for different segments of the\n                piecewise-linear function. ``coeffs[j][i]`` is the coefficient of the i-th power of x\n                for the j-th polynomial.\n                Defaults to linear: ``[[1]]``.\n            basis: The type of Pauli rotation (``'X'``, ``'Y'``, ``'Z'``).\n            label: An optional label for the gate.\n        \"\"\"\n\n        if coeffs is None:\n            degree = 0\n            coeffs = [[1]]\n        else:\n            # store a list of coefficients as homogeneous polynomials adding 0's where necessary\n            degree = len(max(coeffs, key=len)) - 1\n            coeffs = [poly + [0] * (degree + 1 - len(poly)) for poly in coeffs]\n\n        # ensure the breakpoint contains 2 ** num_state_qubits\n        breakpoints = breakpoints.copy()\n        if breakpoints is None:\n            breakpoints = [0, 2**num_state_qubits]\n        elif breakpoints[-1] < 2**num_state_qubits:\n            breakpoints.append(2**num_state_qubits)\n\n        self.coeffs = coeffs\n        self.breakpoints = breakpoints\n        self.basis = basis\n\n        self.num_compare = int(len(self.breakpoints) > 2)\n        super().__init__(\n            \"PiecewisePolyPauli\", num_state_qubits + self.num_compare + 1, [], label=label\n        )\n\n    def evaluate(self, x: float) -> float:\n        \"\"\"Classically evaluate the piecewise polynomial rotation.\n\n        Args:\n            x: Value to be evaluated at.\n\n        Returns:\n            Value of piecewise polynomial function at x.\n        \"\"\"\n        mapped_coeffs = _map_coeffs(self.coeffs)\n\n        y = 0\n        for i, breakpt in enumerate(self.breakpoints):\n            y = y + (x >= breakpt) * (np.poly1d(mapped_coeffs[i][::-1])(x))\n\n        return y\n\n    def _define(self):\n        num_state_qubits = self.num_qubits - self.num_compare - 1\n        circuit = QuantumCircuit(self.num_qubits, name=self.name)\n        qr_state = circuit.qubits[:num_state_qubits]\n\n        if len(self.breakpoints) > 2:\n            qr_target = [circuit.qubits[-2]]\n            qr_compare = [circuit.qubits[-1]]\n        else:\n            qr_target = [circuit.qubits[-1]]\n            qr_compare = []\n\n        # apply comparators and controlled linear rotations\n        contains_zero_breakpoint = np.isclose(self.breakpoints[0], 0)\n        mapped_coeffs = _map_coeffs(self.coeffs)\n\n        for i, point in enumerate(self.breakpoints[:-1]):\n            if i == 0 and contains_zero_breakpoint:\n                # apply rotation\n                poly_r = PolynomialPauliRotationsGate(\n                    num_state_qubits=num_state_qubits,\n                    coeffs=mapped_coeffs[i],\n                    basis=self.basis,\n                )\n                circuit.append(poly_r, qr_state[:] + qr_target)\n\n            else:\n                # apply Comparator\n                comp = IntegerComparatorGate(num_state_qubits=num_state_qubits, value=point)\n                qr_state_full = qr_state[:] + qr_compare  # add compare qubit\n\n                circuit.append(comp, qr_state_full[:])\n\n                # apply controlled rotation\n                poly_r = PolynomialPauliRotationsGate(\n                    num_state_qubits=num_state_qubits,\n                    coeffs=mapped_coeffs[i],\n                    basis=self.basis,\n                )\n                circuit.append(poly_r.control(), qr_compare + qr_state[:] + qr_target)\n\n                # uncompute comparator\n                circuit.append(comp, qr_state_full[:])\n\n        self.definition = circuit\n\n\ndef _map_coeffs(coeffs):\n    mapped_coeffs = []\n    mapped_coeffs.append(coeffs[0])\n\n    degree = len(coeffs[0]) - 1  # all coeffs should have the same length by now\n    for i in range(1, len(coeffs)):\n        mapped_coeffs.append([])\n        for j in range(0, degree + 1):\n            mapped_coeffs[i].append(coeffs[i][j] - coeffs[i - 1][j])\n\n    return mapped_coeffs\n",
    "line_count": 494
  },
  {
    "filename": "polynomial_pauli_rotations.py",
    "path": "qiskit/circuit/library/arithmetic/polynomial_pauli_rotations.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Polynomially controlled Pauli-rotations.\"\"\"\n\nfrom __future__ import annotations\n\nfrom itertools import product\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\n\nfrom .functional_pauli_rotations import FunctionalPauliRotations\n\n\ndef _binomial_coefficients(n):\n    \"\"\"Return a dictionary of binomial coefficients\n\n    Based-on/forked from sympy's binomial_coefficients() function [#]\n\n    .. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py\n    \"\"\"\n\n    data = {(0, n): 1, (n, 0): 1}\n    temp = 1\n    for k in range(1, n // 2 + 1):\n        temp = (temp * (n - k + 1)) // k\n        data[k, n - k] = data[n - k, k] = temp\n    return data\n\n\ndef _large_coefficients_iter(m, n):\n    \"\"\"Return an iterator of multinomial coefficients\n\n    Based-on/forked from sympy's multinomial_coefficients_iterator() function [#]\n\n    .. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py\n    \"\"\"\n    if m < 2 * n or n == 1:\n        coefficients = _multinomial_coefficients(m, n)\n        for key, value in coefficients.items():\n            yield (key, value)\n    else:\n        coefficients = _multinomial_coefficients(n, n)\n        coefficients_dict = {}\n        for key, value in coefficients.items():\n            coefficients_dict[tuple(filter(None, key))] = value\n        coefficients = coefficients_dict\n\n        temp = [n] + [0] * (m - 1)\n        temp_a = tuple(temp)\n        b = tuple(filter(None, temp_a))\n        yield (temp_a, coefficients[b])\n        if n:\n            j = 0  # j will be the leftmost nonzero position\n        else:\n            j = m\n        # enumerate tuples in co-lex order\n        while j < m - 1:\n            # compute next tuple\n            temp_j = temp[j]\n            if j:\n                temp[j] = 0\n                temp[0] = temp_j\n            if temp_j > 1:\n                temp[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                temp[j] += 1\n\n            temp[0] -= 1\n            temp_a = tuple(temp)\n            b = tuple(filter(None, temp_a))\n            yield (temp_a, coefficients[b])\n\n\ndef _multinomial_coefficients(m, n):\n    \"\"\"Return an iterator of multinomial coefficients\n\n    Based-on/forked from sympy's multinomial_coefficients() function [#]\n\n    .. [#] https://github.com/sympy/sympy/blob/sympy-1.5.1/sympy/ntheory/multinomial.py\n    \"\"\"\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return _binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(_large_coefficients_iter(m, n))\n    if n:\n        j = 0\n    else:\n        j = m\n    temp = [n] + [0] * (m - 1)\n    res = {tuple(temp): 1}\n    while j < m - 1:\n        temp_j = temp[j]\n        if j:\n            temp[j] = 0\n            temp[0] = temp_j\n        if temp_j > 1:\n            temp[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = res[tuple(temp)]\n            temp[j] += 1\n        for k in range(start, m):\n            if temp[k]:\n                temp[k] -= 1\n                v += res[tuple(temp)]\n                temp[k] += 1\n        temp[0] -= 1\n        res[tuple(temp)] = (v * temp_j) // (n - temp[0])\n    return res\n\n\nclass PolynomialPauliRotations(FunctionalPauliRotations):\n    r\"\"\"A circuit implementing polynomial Pauli rotations.\n\n    For a polynomial :math:`p(x)`, a basis state :math:`|i\\rangle` and a target qubit\n    :math:`|0\\rangle` this operator acts as:\n\n    .. math::\n\n        |i\\rangle |0\\rangle \\mapsto \\cos\\left(\\frac{p(i)}{2}\\right) |i\\rangle |0\\rangle\n        + \\sin\\left(\\frac{p(i)}{2}\\right) |i\\rangle |1\\rangle\n\n    Let n be the number of qubits representing the state, d the degree of p(x) and q_i the qubits,\n    where q_0 is the least significant qubit. Then for\n\n    .. math::\n\n        x = \\sum_{i=0}^{n-1} 2^i q_i,\n\n    we can write\n\n    .. math::\n\n        p(x) = \\sum_{j=0}^{j=d} c_j x^j\n\n    where :math:`c` are the input coefficients, ``coeffs``.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int | None = None,\n        coeffs: list[float] | None = None,\n        basis: str = \"Y\",\n        name: str = \"poly\",\n    ) -> None:\n        \"\"\"Prepare an approximation to a state with amplitudes specified by a polynomial.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            coeffs: The coefficients of the polynomial. ``coeffs[i]`` is the coefficient of the\n                i-th power of x. Defaults to linear: [0, 1].\n            basis: The type of Pauli rotation ('X', 'Y', 'Z').\n            name: The name of the circuit.\n        \"\"\"\n        # set default internal parameters\n        self._coeffs = coeffs or [0, 1]\n\n        # initialize super (after setting coeffs)\n        super().__init__(num_state_qubits=num_state_qubits, basis=basis, name=name)\n\n    @property\n    def coeffs(self) -> list[float]:\n        \"\"\"The coefficients of the polynomial.\n\n        ``coeffs[i]`` is the coefficient of the i-th power of the function input :math:`x`,\n        that means that the rotation angles are based on the coefficients value,\n        following the formula\n\n        .. math::\n\n            c_j x^j ,  j=0, ..., d\n\n        where :math:`d` is the degree of the polynomial :math:`p(x)` and :math:`c` are the coefficients\n        ``coeffs``.\n\n        Returns:\n            The coefficients of the polynomial.\n        \"\"\"\n        return self._coeffs\n\n    @coeffs.setter\n    def coeffs(self, coeffs: list[float]) -> None:\n        \"\"\"Set the coefficients of the polynomial.\n\n        ``coeffs[i]`` is the coefficient of the i-th power of x.\n\n        Args:\n            The coefficients of the polynomial.\n        \"\"\"\n        self._invalidate()\n        self._coeffs = coeffs\n\n    @property\n    def degree(self) -> int:\n        \"\"\"Return the degree of the polynomial, equals to the number of coefficients minus 1.\n\n        Returns:\n            The degree of the polynomial. If the coefficients have not been set, return 0.\n        \"\"\"\n        if self.coeffs:\n            return len(self.coeffs) - 1\n        return 0\n\n    def _reset_registers(self, num_state_qubits):\n        \"\"\"Reset the registers.\"\"\"\n        if num_state_qubits is not None:\n            # set new register of appropriate size\n            qr_state = QuantumRegister(num_state_qubits, name=\"state\")\n            qr_target = QuantumRegister(1, name=\"target\")\n\n            self.qregs = [qr_state, qr_target]\n        else:\n            self.qregs = []\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n\n        if self.num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of qubits has not been set.\")\n\n        if self.num_qubits < self.num_state_qubits + 1:\n            valid = False\n            if raise_on_failure:\n                raise CircuitError(\n                    \"Not enough qubits in the circuit, need at least \"\n                    f\"{self.num_state_qubits + 1}.\"\n                )\n\n        return valid\n\n    def _build(self):\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        gate = PolynomialPauliRotationsGate(self.num_state_qubits, self.coeffs, self.basis)\n        self.append(gate, self.qubits)\n\n\nclass PolynomialPauliRotationsGate(Gate):\n    r\"\"\"A gate implementing polynomial Pauli rotations.\n\n    For a polynomial :math:`p(x)`, a basis state :math:`|i\\rangle` and a target qubit\n    :math:`|0\\rangle` this operator acts as:\n\n    .. math::\n\n        |i\\rangle |0\\rangle \\mapsto \\cos\\left(\\frac{p(i)}{2}\\right) |i\\rangle |0\\rangle\n        + \\sin\\left(\\frac{p(i)}{2}\\right) |i\\rangle |1\\rangle\n\n    Let n be the number of qubits representing the state, d the degree of p(x) and q_i the qubits,\n    where q_0 is the least significant qubit. Then for\n\n    .. math::\n\n        x = \\sum_{i=0}^{n-1} 2^i q_i,\n\n    we can write\n\n    .. math::\n\n        p(x) = \\sum_{j=0}^{j=d} c_j x^j\n\n    where :math:`c` are the input coefficients, ``coeffs``.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        coeffs: list[float] | None = None,\n        basis: str = \"Y\",\n        label: str | None = None,\n    ) -> None:\n        \"\"\"Prepare an approximation to a state with amplitudes specified by a polynomial.\n\n        Args:\n            num_state_qubits: The number of qubits representing the state.\n            coeffs: The coefficients of the polynomial. ``coeffs[i]`` is the coefficient of the\n                i-th power of x. Defaults to linear: [0, 1].\n            basis: The type of Pauli rotation ('X', 'Y', 'Z').\n            label: A label for the gate.\n        \"\"\"\n        self.coeffs = coeffs or [0, 1]\n        self.basis = basis.lower()\n        super().__init__(\"PolyPauli\", num_state_qubits + 1, [], label=label)\n\n    def _define(self):\n        circuit = QuantumCircuit(self.num_qubits)\n        qr_state = circuit.qubits[: self.num_qubits - 1]\n        qr_target = circuit.qubits[-1]\n\n        rotation_coeffs = self._get_rotation_coefficients()\n\n        if self.basis == \"x\":\n            circuit.rx(self.coeffs[0], qr_target)\n        elif self.basis == \"y\":\n            circuit.ry(self.coeffs[0], qr_target)\n        else:\n            circuit.rz(self.coeffs[0], qr_target)\n\n        for c in rotation_coeffs:\n            qr_control = []\n            for i, _ in enumerate(c):\n                if c[i] > 0:\n                    qr_control.append(qr_state[i])\n\n            # apply controlled rotations\n            if len(qr_control) > 1:\n                if self.basis == \"x\":\n                    circuit.mcrx(rotation_coeffs[c], qr_control, qr_target)\n                elif self.basis == \"y\":\n                    circuit.mcry(rotation_coeffs[c], qr_control, qr_target)\n                else:\n                    circuit.mcrz(rotation_coeffs[c], qr_control, qr_target)\n\n            elif len(qr_control) == 1:\n                if self.basis == \"x\":\n                    circuit.crx(rotation_coeffs[c], qr_control[0], qr_target)\n                elif self.basis == \"y\":\n                    circuit.cry(rotation_coeffs[c], qr_control[0], qr_target)\n                else:\n                    circuit.crz(rotation_coeffs[c], qr_control[0], qr_target)\n\n        self.definition = circuit\n\n    def _get_rotation_coefficients(self) -> dict[tuple[int, ...], float]:\n        \"\"\"Compute the coefficient of each monomial.\n\n        Returns:\n            A dictionary with pairs ``{control_state: rotation angle}`` where ``control_state``\n            is a tuple of ``0`` or ``1`` bits.\n        \"\"\"\n        # determine the control states\n        num_state_qubits = self.num_qubits - 1\n        degree = len(self.coeffs) - 1\n        all_combinations = list(product([0, 1], repeat=num_state_qubits))\n        valid_combinations = []\n        for combination in all_combinations:\n            if 0 < sum(combination) <= degree:\n                valid_combinations += [combination]\n\n        rotation_coeffs = {control_state: 0.0 for control_state in valid_combinations}\n\n        # compute the coefficients for the control states\n        for i, coeff in enumerate(self.coeffs[1:]):\n            i += 1  # since we skip the first element we need to increase i by one\n\n            # iterate over the multinomial coefficients\n            for comb, num_combs in _multinomial_coefficients(num_state_qubits, i).items():\n                control_state: tuple[int, ...] = ()\n                power = 1\n                for j, qubit in enumerate(comb):\n                    if qubit > 0:  # means we control on qubit i\n                        control_state += (1,)\n                        power *= 2 ** (j * qubit)\n                    else:\n                        control_state += (0,)\n\n                # Add angle\n                rotation_coeffs[control_state] += coeff * num_combs * power\n\n        return rotation_coeffs\n",
    "line_count": 390
  },
  {
    "filename": "quadratic_form.py",
    "path": "qiskit/circuit/library/arithmetic/quadratic_form.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"A circuit implementing a quadratic form on binary variables.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Union, Optional, List\nimport math\nfrom collections.abc import Sequence\n\nimport numpy as np\n\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, ParameterExpression, Gate, CircuitError\nfrom ..basis_change import QFT, QFTGate\n\n_ValueType = Union[int, float, np.integer, np.floating, ParameterExpression]\n\n\nclass QuadraticForm(QuantumCircuit):\n    r\"\"\"Implements a quadratic form on binary variables encoded in qubit registers.\n\n    A quadratic form on binary variables is a quadratic function :math:`Q` acting on a binary\n    variable of :math:`n` bits, :math:`x = x_0 ... x_{n-1}`. For an integer matrix :math:`A`,\n    an integer vector :math:`b` and an integer :math:`c` the function can be written as\n\n    .. math::\n\n        Q(x) = x^T A x + x^T b + c\n\n    If :math:`A`, :math:`b` or :math:`c` contain scalar values, this circuit computes only\n    an approximation of the quadratic form.\n\n    Provided with :math:`m` qubits to encode the value, this circuit computes :math:`Q(x) \\mod 2^m`\n    in [two's complement](https://stackoverflow.com/questions/1049722/what-is-2s-complement)\n    representation.\n\n    .. math::\n\n        |x\\rangle_n |0\\rangle_m \\mapsto |x\\rangle_n |(Q(x) + 2^m) \\mod 2^m \\rangle_m\n\n    Since we use two's complement e.g. the value of :math:`Q(x) = 3` requires 2 bits to represent\n    the value and 1 bit for the sign: `3 = '011'` where the first `0` indicates a positive value.\n    On the other hand, :math:`Q(x) = -3` would be `-3 = '101'`, where the first `1` indicates\n    a negative value and `01` is the two's complement of `3`.\n\n    If the value of :math:`Q(x)` is too large to be represented with `m` qubits, the resulting\n    bitstring is :math:`(Q(x) + 2^m) \\mod 2^m)`.\n\n    The implementation of this circuit is discussed in [1], Fig. 6.\n\n    References:\n        [1]: Gilliam et al., Grover Adaptive Search for Constrained Polynomial Binary Optimization.\n             `arXiv:1912.04088 <https://arxiv.org/pdf/1912.04088.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_result_qubits: Optional[int] = None,\n        quadratic: Optional[\n            Union[np.ndarray, List[List[Union[float, ParameterExpression]]]]\n        ] = None,\n        linear: Optional[Union[np.ndarray, List[Union[float, ParameterExpression]]]] = None,\n        offset: Optional[Union[float, ParameterExpression]] = None,\n        little_endian: bool = True,\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_result_qubits: The number of qubits to encode the result. Called :math:`m` in\n                the class documentation.\n            quadratic: A matrix containing the quadratic coefficients, :math:`A`.\n            linear: An array containing the linear coefficients, :math:`b`.\n            offset: A constant offset, :math:`c`.\n            little_endian: Encode the result in little endianness.\n\n        Raises:\n            ValueError: If ``linear`` and ``quadratic`` have mismatching sizes.\n            ValueError: If ``num_result_qubits`` is unspecified but cannot be determined because\n                some values of the quadratic form are parameterized.\n        \"\"\"\n        # check inputs match\n        if quadratic is not None and linear is not None:\n            if len(quadratic) != len(linear):\n                raise ValueError(\"Mismatching sizes of quadratic and linear.\")\n\n        # temporarily set quadratic and linear to [] instead of None so we can iterate over them\n        if quadratic is None:\n            quadratic = []\n\n        if linear is None:\n            linear = []\n\n        if offset is None:\n            offset = 0\n\n        num_input_qubits = np.max([1, len(linear), len(quadratic)])\n\n        # deduce number of result bits if not added\n        if num_result_qubits is None:\n            # check no value is parameterized\n            if (\n                any(any(isinstance(q_ij, ParameterExpression) for q_ij in q_i) for q_i in quadratic)\n                or any(isinstance(l_i, ParameterExpression) for l_i in linear)\n                or isinstance(offset, ParameterExpression)\n            ):\n                raise ValueError(\n                    \"If the number of result qubits is not specified, the quadratic \"\n                    \"form matrices/vectors/offset may not be parameterized.\"\n                )\n            num_result_qubits = self.required_result_qubits(quadratic, linear, offset)\n\n        qr_input = QuantumRegister(num_input_qubits)\n        qr_result = QuantumRegister(num_result_qubits)\n        circuit = QuantumCircuit(qr_input, qr_result, name=\"Q(x)\")\n\n        # set quadratic and linear again to None if they were None\n        if len(quadratic) == 0:\n            quadratic = None\n\n        if len(linear) == 0:\n            linear = None\n\n        scaling = np.pi * 2 ** (1 - num_result_qubits)\n\n        # initial QFT (just hadamards)\n        circuit.h(qr_result)\n\n        if little_endian:\n            qr_result = qr_result[::-1]\n\n        # constant coefficient\n        if offset != 0:\n            for i, q_i in enumerate(qr_result):\n                circuit.p(scaling * 2**i * offset, q_i)\n\n        # the linear part consists of the vector and the diagonal of the\n        # matrix, since x_i * x_i = x_i, as x_i is a binary variable\n        for j in range(num_input_qubits):\n            value = linear[j] if linear is not None else 0\n            value += quadratic[j][j] if quadratic is not None else 0\n            if value != 0:\n                for i, q_i in enumerate(qr_result):\n                    circuit.cp(scaling * 2**i * value, qr_input[j], q_i)\n\n        # the quadratic part adds A_ij and A_ji as x_i x_j == x_j x_i\n        if quadratic is not None:\n            for j in range(num_input_qubits):\n                for k in range(j + 1, num_input_qubits):\n                    value = quadratic[j][k] + quadratic[k][j]\n                    if value != 0:\n                        for i, q_i in enumerate(qr_result):\n                            circuit.mcp(scaling * 2**i * value, [qr_input[j], qr_input[k]], q_i)\n\n        # add the inverse QFT\n        iqft = QFT(num_result_qubits, do_swaps=False).inverse().reverse_bits()\n        circuit.compose(iqft, qubits=qr_result[:], inplace=True)\n\n        super().__init__(*circuit.qregs, name=\"Q(x)\")\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n    @staticmethod\n    def required_result_qubits(\n        quadratic: Union[np.ndarray, List[List[float]]],\n        linear: Union[np.ndarray, List[float]],\n        offset: float,\n    ) -> int:\n        \"\"\"Get the number of required result qubits.\n\n        Args:\n            quadratic: A matrix containing the quadratic coefficients.\n            linear: An array containing the linear coefficients.\n            offset: A constant offset.\n\n        Returns:\n            The number of qubits needed to represent the value of the quadratic form\n            in twos complement.\n        \"\"\"\n        return QuadraticFormGate.required_result_qubits(quadratic, linear, offset)\n\n\nclass QuadraticFormGate(Gate):\n    r\"\"\"Implements a quadratic form on binary variables encoded in qubit registers.\n\n    A quadratic form on binary variables is a quadratic function :math:`Q` acting on a binary\n    variable of :math:`n` bits, :math:`x = x_0 ... x_{n-1}`. For an integer matrix :math:`A`,\n    an integer vector :math:`b` and an integer :math:`c` the function can be written as\n\n    .. math::\n\n        Q(x) = x^T A x + x^T b + c\n\n    If :math:`A`, :math:`b` or :math:`c` contain scalar values, this circuit computes only\n    an approximation of the quadratic form.\n\n    Provided with :math:`m` qubits to encode the value, this circuit computes :math:`Q(x) \\mod 2^m`\n    in [two's complement](https://stackoverflow.com/questions/1049722/what-is-2s-complement)\n    representation.\n\n    .. math::\n\n        |x\\rangle_n |0\\rangle_m \\mapsto |x\\rangle_n |(Q(x) + 2^m) \\mod 2^m \\rangle_m\n\n    Since we use two's complement e.g. the value of :math:`Q(x) = 3` requires 2 bits to represent\n    the value and 1 bit for the sign: `3 = '011'` where the first `0` indicates a positive value.\n    On the other hand, :math:`Q(x) = -3` would be `-3 = '101'`, where the first `1` indicates\n    a negative value and `01` is the two's complement of `3`.\n\n    If the value of :math:`Q(x)` is too large to be represented with `m` qubits, the resulting\n    bitstring is :math:`(Q(x) + 2^m) \\mod 2^m)`.\n\n    The implementation of this circuit is discussed in [1], Fig. 6.\n\n    References:\n        [1]: Gilliam et al., Grover Adaptive Search for Constrained Polynomial Binary Optimization.\n             `arXiv:1912.04088 <https://arxiv.org/pdf/1912.04088.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_result_qubits: int | None = None,\n        quadratic: Sequence[Sequence[float]] | None = None,\n        linear: Sequence[Sequence[float]] | None = None,\n        offset: float | None = None,\n        label: str = \"Q(x)\",\n    ):\n        # check inputs match\n        if quadratic is not None and linear is not None:\n            if len(quadratic) != len(linear):\n                raise ValueError(\"Mismatching sizes of quadratic and linear.\")\n\n        # temporarily set quadratic and linear to [] instead of None so we can iterate over them\n        if quadratic is None:\n            quadratic = []\n\n        if linear is None:\n            linear = []\n\n        if offset is None:\n            offset = 0\n\n        self.num_input_qubits = np.max([1, len(linear), len(quadratic)])\n\n        # deduce number of result bits if not added\n        if num_result_qubits is None:\n            num_result_qubits = self.required_result_qubits(quadratic, linear, offset)\n\n        self.num_result_qubits = num_result_qubits\n        self.quadratic = quadratic\n        self.linear = linear\n        self.offset = offset\n\n        num_qubits = int(self.num_input_qubits + self.num_result_qubits)\n        super().__init__(\"QuadraticForm\", num_qubits, [], label=label)\n\n    @staticmethod\n    def required_result_qubits(\n        quadratic: Sequence[Sequence[float]],\n        linear: Sequence[float],\n        offset: float,\n    ) -> int:\n        \"\"\"Get the number of required result qubits.\n\n        Args:\n            quadratic: A matrix containing the quadratic coefficients.\n            linear: An array containing the linear coefficients.\n            offset: A constant offset.\n\n        Returns:\n            The number of qubits needed to represent the value of the quadratic form\n            in twos complement.\n        \"\"\"\n\n        bounds = []  # bounds = [minimum value, maximum value]\n        for condition in [lambda x: x < 0, lambda x: x > 0]:\n            bound = 0.0\n            bound += sum(sum(q_ij for q_ij in q_i if condition(q_ij)) for q_i in quadratic)\n            bound += sum(l_i for l_i in linear if condition(l_i))\n            bound += offset if condition(offset) else 0\n            bounds.append(bound)\n\n        # the minimum number of qubits is the number of qubits needed to represent\n        # the minimum/maximum value plus one sign qubit\n        num_qubits_for_min = math.ceil(math.log2(max(-bounds[0], 1)))\n        num_qubits_for_max = math.ceil(math.log2(bounds[1] + 1))\n        num_result_qubits = 1 + max(num_qubits_for_min, num_qubits_for_max)\n\n        return num_result_qubits\n\n    def validate_parameter(self, parameter):\n        if isinstance(parameter, _ValueType):\n            return parameter\n\n        if isinstance(parameter, (np.ndarray, Sequence)):\n            if all(isinstance(el, _ValueType) for el in parameter):\n                return parameter\n            for params in parameter:\n                if not all(isinstance(el, _ValueType) for el in params):\n                    raise CircuitError(\n                        f\"Invalid parameter type {type(parameter)} for QuadraticFormGate\"\n                    )\n\n            return parameter\n\n        return super().validate_parameter(parameter)\n\n    def _define(self):\n        quadratic, linear, offset = self.quadratic, self.linear, self.offset\n\n        qr_input = QuantumRegister(self.num_input_qubits)\n        qr_result = QuantumRegister(self.num_result_qubits)\n        circuit = QuantumCircuit(qr_input, qr_result)\n\n        # set quadratic and linear again to None if they were None\n        if len(quadratic) == 0:\n            quadratic = None\n\n        if len(linear) == 0:\n            linear = None\n\n        scaling = np.pi * 2 ** (1 - self.num_result_qubits)\n\n        # initial QFT\n        qft = QFTGate(self.num_result_qubits)\n        circuit.append(qft, qr_result)\n\n        # constant coefficient\n        if offset != 0:\n            for i, q_i in enumerate(qr_result):\n                circuit.p(scaling * 2**i * offset, q_i)\n\n        # the linear part consists of the vector and the diagonal of the\n        # matrix, since x_i * x_i = x_i, as x_i is a binary variable\n        for j in range(self.num_input_qubits):\n            value = linear[j] if linear is not None else 0\n            value += quadratic[j][j] if quadratic is not None else 0\n            if value != 0:\n                for i, q_i in enumerate(qr_result):\n                    circuit.cp(scaling * 2**i * value, qr_input[j], q_i)\n\n        # the quadratic part adds A_ij and A_ji as x_i x_j == x_j x_i\n        if quadratic is not None:\n            for j in range(self.num_input_qubits):\n                for k in range(j + 1, self.num_input_qubits):\n                    value = quadratic[j][k] + quadratic[k][j]\n                    if value != 0:\n                        for i, q_i in enumerate(qr_result):\n                            circuit.mcp(scaling * 2**i * value, [qr_input[j], qr_input[k]], q_i)\n\n        # add the inverse QFT\n        iqft = qft.inverse()\n        circuit.append(iqft, qr_result)\n\n        self.definition = circuit\n",
    "line_count": 365
  },
  {
    "filename": "weighted_adder.py",
    "path": "qiskit/circuit/library/arithmetic/weighted_adder.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the weighted sum of qubit states.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import List, Optional\nimport numpy as np\n\nfrom qiskit.circuit import QuantumRegister, AncillaRegister, QuantumCircuit, Gate\n\nfrom ..blueprintcircuit import BlueprintCircuit\n\n\nclass WeightedAdder(BlueprintCircuit):\n    r\"\"\"A circuit to compute the weighted sum of qubit registers.\n\n    Given :math:`n` qubit basis states :math:`q_0, \\ldots, q_{n-1} \\in \\{0, 1\\}` and non-negative\n    integer weights :math:`\\lambda_0, \\ldots, \\lambda_{n-1}`, this circuit performs the operation\n\n    .. math::\n\n        |q_0 \\ldots q_{n-1}\\rangle |0\\rangle_s\n        \\mapsto |q_0 \\ldots q_{n-1}\\rangle |\\sum_{j=0}^{n-1} \\lambda_j q_j\\rangle_s\n\n    where :math:`s` is the number of sum qubits required.\n    This can be computed as\n\n    .. math::\n\n        s = 1 + \\left\\lfloor \\log_2\\left( \\sum_{j=0}^{n-1} \\lambda_j \\right) \\right\\rfloor\n\n    or :math:`s = 1` if the sum of the weights is 0 (then the expression in the logarithm is\n    invalid).\n\n    For qubits in a circuit diagram, the first weight applies to the upper-most qubit.\n    For an example where the state of 4 qubits is added into a sum register, the circuit can\n    be schematically drawn as\n\n    .. code-block:: text\n\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          state_0: \u25240       \u251c | state_0 * weights[0]\n                   \u2502        \u2502 |\n          state_1: \u25241       \u251c | + state_1 * weights[1]\n                   \u2502        \u2502 |\n          state_2: \u25242       \u251c | + state_2 * weights[2]\n                   \u2502        \u2502 |\n          state_3: \u25243       \u251c | + state_3 * weights[3]\n                   \u2502        \u2502\n            sum_0: \u25244       \u251c |\n                   \u2502  Adder \u2502 |\n            sum_1: \u25245       \u251c | = sum_0 * 2^0 + sum_1 * 2^1 + sum_2 * 2^2\n                   \u2502        \u2502 |\n            sum_2: \u25246       \u251c |\n                   \u2502        \u2502\n          carry_0: \u25247       \u251c\n                   \u2502        \u2502\n          carry_1: \u25248       \u251c\n                   \u2502        \u2502\n        control_0: \u25249       \u251c\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: Optional[int] = None,\n        weights: Optional[List[int]] = None,\n        name: str = \"adder\",\n    ) -> None:\n        \"\"\"Computes the weighted sum controlled by state qubits.\n\n        Args:\n            num_state_qubits: The number of state qubits.\n            weights: List of weights, one for each state qubit. If none are provided they\n                default to 1 for every qubit.\n            name: The name of the circuit.\n        \"\"\"\n        super().__init__(name=name)\n\n        self._weights = None\n        self._num_state_qubits = None\n\n        self.weights = weights\n        self.num_state_qubits = num_state_qubits\n\n    @property\n    def num_sum_qubits(self) -> int:\n        \"\"\"The number of sum qubits in the circuit.\n\n        Returns:\n            The number of qubits needed to represent the weighted sum of the qubits.\n        \"\"\"\n        if sum(self.weights) > 0:\n            return int(np.floor(np.log2(sum(self.weights))) + 1)\n        return 1\n\n    @property\n    def weights(self) -> List[int]:\n        \"\"\"The weights for the qubit states.\n\n        Returns:\n            The weight for the qubit states.\n        \"\"\"\n        if self._weights:\n            return self._weights\n        if self.num_state_qubits:\n            return [1] * self.num_state_qubits\n        return None\n\n    @weights.setter\n    def weights(self, weights: List[int]) -> None:\n        \"\"\"Set the weights for summing the qubit states.\n\n        Args:\n            weights: The new weights.\n\n        Raises:\n            ValueError: If not all weights are close to an integer.\n        \"\"\"\n        if weights:\n            for i, weight in enumerate(weights):\n                if not np.isclose(weight, np.round(weight)):\n                    raise ValueError(\"Non-integer weights are not supported!\")\n                weights[i] = np.round(weight)\n\n        self._invalidate()\n        self._weights = weights\n        self._reset_registers()\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of qubits to be summed.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    @num_state_qubits.setter\n    def num_state_qubits(self, num_state_qubits: int) -> None:\n        \"\"\"Set the number of state qubits.\n\n        Args:\n            num_state_qubits: The new number of state qubits.\n        \"\"\"\n        if self._num_state_qubits is None or num_state_qubits != self._num_state_qubits:\n            self._invalidate()\n            self._num_state_qubits = num_state_qubits\n            self._reset_registers()\n\n    def _reset_registers(self):\n        \"\"\"Reset the registers.\"\"\"\n        self.qregs = []\n\n        if self.num_state_qubits:\n            qr_state = QuantumRegister(self.num_state_qubits, name=\"state\")\n            qr_sum = QuantumRegister(self.num_sum_qubits, name=\"sum\")\n            self.qregs = [qr_state, qr_sum]\n\n            if self.num_carry_qubits > 0:\n                qr_carry = AncillaRegister(self.num_carry_qubits, name=\"carry\")\n                self.add_register(qr_carry)\n\n            if self.num_control_qubits > 0:\n                qr_control = AncillaRegister(self.num_control_qubits, name=\"control\")\n                self.add_register(qr_control)\n\n    @property\n    def num_carry_qubits(self) -> int:\n        \"\"\"The number of carry qubits required to compute the sum.\n\n        Note that this is not necessarily equal to the number of ancilla qubits, these can\n        be queried using ``num_ancilla_qubits``.\n\n        Returns:\n            The number of carry qubits required to compute the sum.\n        \"\"\"\n        return self.num_sum_qubits - 1\n\n    @property\n    def num_control_qubits(self) -> int:\n        \"\"\"The number of additional control qubits required.\n\n        Note that the total number of ancilla qubits can be obtained by calling the\n        method ``num_ancilla_qubits``.\n\n        Returns:\n            The number of additional control qubits required (0 or 1).\n        \"\"\"\n        return int(self.num_sum_qubits > 2)\n\n    def _check_configuration(self, raise_on_failure=True):\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n        if self._num_state_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of state qubits has not been set.\")\n\n        if self._num_state_qubits != len(self.weights):\n            valid = False\n            if raise_on_failure:\n                raise ValueError(\"Mismatching number of state qubits and weights.\")\n\n        return valid\n\n    def _build(self):\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        num_result_qubits = self.num_state_qubits + self.num_sum_qubits\n\n        circuit = QuantumCircuit(*self.qregs)\n        qr_state = circuit.qubits[: self.num_state_qubits]\n        qr_sum = circuit.qubits[self.num_state_qubits : num_result_qubits]\n        qr_carry = circuit.qubits[num_result_qubits : num_result_qubits + self.num_carry_qubits]\n        qr_control = circuit.qubits[num_result_qubits + self.num_carry_qubits :]\n\n        # loop over state qubits and corresponding weights\n        for i, weight in enumerate(self.weights):\n            # only act if non-trivial weight\n            if np.isclose(weight, 0):\n                continue\n\n            # get state control qubit\n            q_state = qr_state[i]\n\n            # get bit representation of current weight\n            weight_binary = f\"{int(weight):b}\".rjust(self.num_sum_qubits, \"0\")[::-1]\n\n            # loop over bits of current weight and add them to sum and carry registers\n            for j, bit in enumerate(weight_binary):\n                if bit == \"1\":\n                    if self.num_sum_qubits == 1:\n                        circuit.cx(q_state, qr_sum[j])\n                    elif j == 0:\n                        # compute (q_sum[0] + 1) into (q_sum[0], q_carry[0])\n                        # - controlled by q_state[i]\n                        circuit.ccx(q_state, qr_sum[j], qr_carry[j])\n                        circuit.cx(q_state, qr_sum[j])\n                    elif j == self.num_sum_qubits - 1:\n                        # compute (q_sum[j] + q_carry[j-1] + 1) into (q_sum[j])\n                        # - controlled by q_state[i] / last qubit,\n                        # no carry needed by construction\n                        circuit.cx(q_state, qr_sum[j])\n                        circuit.ccx(q_state, qr_carry[j - 1], qr_sum[j])\n                    else:\n                        # compute (q_sum[j] + q_carry[j-1] + 1) into (q_sum[j], q_carry[j])\n                        # - controlled by q_state[i]\n                        circuit.x(qr_sum[j])\n                        circuit.x(qr_carry[j - 1])\n                        circuit.mcx(\n                            [q_state, qr_sum[j], qr_carry[j - 1]],\n                            qr_carry[j],\n                            qr_control,\n                            mode=\"v-chain\",\n                        )\n                        circuit.cx(q_state, qr_carry[j])\n                        circuit.x(qr_sum[j])\n                        circuit.x(qr_carry[j - 1])\n                        circuit.cx(q_state, qr_sum[j])\n                        circuit.ccx(q_state, qr_carry[j - 1], qr_sum[j])\n                else:\n                    if self.num_sum_qubits == 1:\n                        pass  # nothing to do, since nothing to add\n                    elif j == 0:\n                        pass  # nothing to do, since nothing to add\n                    elif j == self.num_sum_qubits - 1:\n                        # compute (q_sum[j] + q_carry[j-1]) into (q_sum[j])\n                        # - controlled by q_state[i] / last qubit,\n                        # no carry needed by construction\n                        circuit.ccx(q_state, qr_carry[j - 1], qr_sum[j])\n                    else:\n                        # compute (q_sum[j] + q_carry[j-1]) into (q_sum[j], q_carry[j])\n                        # - controlled by q_state[i]\n                        circuit.mcx(\n                            [q_state, qr_sum[j], qr_carry[j - 1]],\n                            qr_carry[j],\n                            qr_control,\n                            mode=\"v-chain\",\n                        )\n                        circuit.ccx(q_state, qr_carry[j - 1], qr_sum[j])\n\n            # uncompute carry qubits\n            for j in reversed(range(len(weight_binary))):\n                bit = weight_binary[j]\n                if bit == \"1\":\n                    if self.num_sum_qubits == 1:\n                        pass\n                    elif j == 0:\n                        circuit.x(qr_sum[j])\n                        circuit.ccx(q_state, qr_sum[j], qr_carry[j])\n                        circuit.x(qr_sum[j])\n                    elif j == self.num_sum_qubits - 1:\n                        pass\n                    else:\n                        circuit.x(qr_carry[j - 1])\n                        circuit.mcx(\n                            [q_state, qr_sum[j], qr_carry[j - 1]],\n                            qr_carry[j],\n                            qr_control,\n                            mode=\"v-chain\",\n                        )\n                        circuit.cx(q_state, qr_carry[j])\n                        circuit.x(qr_carry[j - 1])\n                else:\n                    if self.num_sum_qubits == 1:\n                        pass\n                    elif j == 0:\n                        pass\n                    elif j == self.num_sum_qubits - 1:\n                        pass\n                    else:\n                        # compute (q_sum[j] + q_carry[j-1]) into (q_sum[j], q_carry[j])\n                        # - controlled by q_state[i]\n                        circuit.x(qr_sum[j])\n                        circuit.mcx(\n                            [q_state, qr_sum[j], qr_carry[j - 1]],\n                            qr_carry[j],\n                            qr_control,\n                            mode=\"v-chain\",\n                        )\n                        circuit.x(qr_sum[j])\n\n        self.append(circuit.to_gate(), self.qubits)\n\n\nclass WeightedSumGate(Gate):\n    r\"\"\"A gate to compute the weighted sum of qubit registers.\n\n    Given :math:`n` qubit basis states :math:`q_0, \\ldots, q_{n-1} \\in \\{0, 1\\}` and non-negative\n    integer weights :math:`\\lambda_0, \\ldots, \\lambda_{n-1}`, this implements the operation\n\n    .. math::\n\n        |q_0 \\ldots q_{n-1}\\rangle |0\\rangle_s\n        \\mapsto |q_0 \\ldots q_{n-1}\\rangle |\\sum_{j=0}^{n-1} \\lambda_j q_j\\rangle_s\n\n    where :math:`s` is the number of sum qubits required.\n    This can be computed as\n\n    .. math::\n\n        s = 1 + \\left\\lfloor \\log_2\\left( \\sum_{j=0}^{n-1} \\lambda_j \\right) \\right\\rfloor\n\n    or :math:`s = 1` if the sum of the weights is 0 (then the expression in the logarithm is\n    invalid).\n\n    For qubits in a circuit diagram, the first weight applies to the upper-most qubit.\n    For an example where the state of 4 qubits is added into a sum register, the circuit can\n    be schematically drawn as\n\n    .. code-block:: text\n\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          state_0: \u25240             \u251c | state_0 * weights[0]\n                   \u2502              \u2502 |\n          state_1: \u25241             \u251c | + state_1 * weights[1]\n                   \u2502              \u2502 |\n          state_2: \u25242             \u251c | + state_2 * weights[2]\n                   \u2502              \u2502 |\n          state_3: \u25243 WeightedSum \u251c | + state_3 * weights[3]\n                   \u2502              \u2502\n            sum_0: \u25244             \u251c |\n                   \u2502              \u2502 |\n            sum_1: \u25245             \u251c | = sum_0 * 2^0 + sum_1 * 2^1 + sum_2 * 2^2\n                   \u2502              \u2502 |\n            sum_2: \u25246             \u251c |\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        weights: list[int] | None = None,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of state qubits.\n            weights: List of weights, one for each state qubit. If none are provided they\n                default to 1 for every qubit.\n            label: The name of the circuit.\n        \"\"\"\n        if weights is None:\n            weights = [1] * num_state_qubits\n\n        self.num_state_qubits = num_state_qubits\n\n        if sum(weights) > 0:\n            self.num_sum_qubits = int(np.floor(np.log2(sum(weights))) + 1)\n        else:\n            self.num_sum_qubits = 1\n\n        super().__init__(\"WeightedSum\", self.num_state_qubits + self.num_sum_qubits, weights, label)\n",
    "line_count": 410
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/arithmetic/adders/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The adder circuit library.\"\"\"\n\nfrom .cdkm_ripple_carry_adder import CDKMRippleCarryAdder\nfrom .draper_qft_adder import DraperQFTAdder\nfrom .vbe_ripple_carry_adder import VBERippleCarryAdder\nfrom .adder import ModularAdderGate, HalfAdderGate, FullAdderGate\n",
    "line_count": 19
  },
  {
    "filename": "adder.py",
    "path": "qiskit/circuit/library/arithmetic/adders/adder.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the sum of two equally sized qubit registers.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumCircuit, Gate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass Adder(QuantumCircuit):\n    r\"\"\"Compute the sum of two equally sized qubit registers.\n\n    For two registers :math:`|a\\rangle_n` and :math:`|b\\rangle_n` with :math:`n` qubits each, an\n    adder performs the following operation\n\n    .. math::\n\n        |a\\rangle_n |b\\rangle_n \\mapsto |a\\rangle_n |a + b\\rangle_{n + 1}.\n\n    The quantum register :math:`|a\\rangle_n` (and analogously :math:`|b\\rangle_n`)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=(\n            \"Use the adder gates provided in qiskit.circuit.library.arithmetic instead. \"\n            \"The gate type depends on the adder kind: fixed, half, full are represented by \"\n            \"ModularAdderGate, HalfAdderGate, FullAdderGate, respectively. For different adder \"\n            \"implementations, see https://docs.quantum.ibm.com/api/qiskit/synthesis.\",\n        ),\n        pending=True,\n    )\n    def __init__(self, num_state_qubits: int, name: str = \"Adder\") -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the registers.\n            name: The name of the circuit.\n        \"\"\"\n        super().__init__(name=name)\n        self._num_state_qubits = num_state_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n\nclass HalfAdderGate(Gate):\n    r\"\"\"Compute the sum of two equally-sized qubit registers, including a carry-out bit.\n\n    For two registers :math:`|a\\rangle_n` and :math:`|b\\rangle_n` with :math:`n` qubits each, an\n    adder performs the following operation\n\n    .. math::\n\n        |a\\rangle_n |b\\rangle_n \\mapsto |a\\rangle_n |a + b\\rangle_{n + 1}.\n\n    The quantum register :math:`|a\\rangle_n` (and analogously :math:`|b\\rangle_n`)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    def __init__(self, num_state_qubits: int, label: str | None = None) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the registers.\n            name: The name of the circuit.\n        \"\"\"\n        if num_state_qubits < 1:\n            raise ValueError(\"Need at least 1 state qubit.\")\n\n        super().__init__(\"HalfAdder\", 2 * num_state_qubits + 1, [], label=label)\n        self._num_state_qubits = num_state_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    def _define(self):\n        \"\"\"Populates self.definition with some decomposition of this gate.\"\"\"\n        from qiskit.synthesis.arithmetic import adder_qft_d00\n\n        # This particular decomposition does not use any ancilla qubits.\n        # Note that the transpiler may choose a different decomposition\n        # based on the number of ancilla qubits available.\n        self.definition = adder_qft_d00(self.num_state_qubits, kind=\"half\")\n\n\nclass ModularAdderGate(Gate):\n    r\"\"\"Compute the sum modulo :math:`2^n` of two :math:`n`-sized qubit registers.\n\n    For two registers :math:`|a\\rangle_n` and :math:`|b\\rangle_n` with :math:`n` qubits each, an\n    adder performs the following operation\n\n    .. math::\n\n        |a\\rangle_n |b\\rangle_n \\mapsto |a\\rangle_n |a + b \\text{ mod } 2^n\\rangle_n.\n\n    The quantum register :math:`|a\\rangle_n` (and analogously :math:`|b\\rangle_n`)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    def __init__(self, num_state_qubits: int, label: str | None = None) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the registers.\n            name: The name of the circuit.\n        \"\"\"\n        if num_state_qubits < 1:\n            raise ValueError(\"Need at least 1 state qubit.\")\n\n        super().__init__(\"ModularAdder\", 2 * num_state_qubits, [], label=label)\n        self._num_state_qubits = num_state_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    def _define(self):\n        \"\"\"Populates self.definition with some decomposition of this gate.\"\"\"\n        from qiskit.synthesis.arithmetic import adder_qft_d00\n\n        # This particular decomposition does not use any ancilla qubits.\n        # Note that the transpiler may choose a different decomposition\n        # based on the number of ancilla qubits available.\n        self.definition = adder_qft_d00(self.num_state_qubits, kind=\"fixed\")\n\n\nclass FullAdderGate(Gate):\n    r\"\"\"Compute the sum of two :math:`n`-sized qubit registers, including carry-in and -out bits.\n\n    For two registers :math:`|a\\rangle_n` and :math:`|b\\rangle_n` with :math:`n` qubits each, an\n    adder performs the following operation\n\n    .. math::\n\n        |c_{\\text{in}}\\rangle_1 |a\\rangle_n |b\\rangle_n\n        \\mapsto |a\\rangle_n |c_{\\text{in}} + a + b \\rangle_{n + 1}.\n\n    The quantum register :math:`|a\\rangle_n` (and analogously :math:`|b\\rangle_n`)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    def __init__(self, num_state_qubits: int, label: str | None = None) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the registers.\n            name: The name of the circuit.\n        \"\"\"\n        if num_state_qubits < 1:\n            raise ValueError(\"Need at least 1 state qubit.\")\n\n        super().__init__(\"FullAdder\", 2 * num_state_qubits + 2, [], label=label)\n        self._num_state_qubits = num_state_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    def _define(self):\n        \"\"\"Populates self.definition with a decomposition of this gate.\"\"\"\n        from qiskit.synthesis.arithmetic import adder_ripple_c04\n\n        # In the case of a full adder, this method does not use any ancilla qubits\n        self.definition = adder_ripple_c04(self.num_state_qubits, kind=\"full\")\n",
    "line_count": 236
  },
  {
    "filename": "cdkm_ripple_carry_adder.py",
    "path": "qiskit/circuit/library/arithmetic/adders/cdkm_ripple_carry_adder.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the sum of two qubit registers using ripple-carry approach.\"\"\"\n\nfrom qiskit.synthesis.arithmetic import adder_ripple_c04\nfrom .adder import Adder\n\n\nclass CDKMRippleCarryAdder(Adder):\n    r\"\"\"A ripple-carry circuit to perform in-place addition on two qubit registers.\n\n    As an example, a ripple-carry adder circuit that performs addition on two 3-qubit sized\n    registers with a carry-in bit (``kind=\"full\"``) is as follows:\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         cin_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524  MAJ \u251c\u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\u2524  UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502     \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u2500\u2500\u25a0\u2500\u2500\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241     \u251c\u2524      \u251c\u2524  MAJ \u251c\u2500\u2500\u253c\u2500\u2500\u2524  UMA \u251c\u2524      \u251c\u25241     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502  \u2502  \u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2524      \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502  \u2502  \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           b_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u2500\u2500\u253c\u2500\u2500\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        cout_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                        \u2514\u2500\u2500\u2500\u2518\n\n    Here *MAJ* and *UMA* gates correspond to the gates introduced in [1]. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n\n    Two different kinds of adders are supported. By setting the ``kind`` argument, you can also\n    choose a half-adder, which doesn't have a carry-in, and a fixed-sized-adder, which has neither\n    carry-in nor carry-out, and thus acts on fixed register sizes. Unlike the full-adder,\n    these circuits need one additional helper qubit.\n\n    The circuit diagram for the fixed-point adder (``kind=\"fixed\"``) on 3-qubit sized inputs is\n\n    .. code-block:: text\n\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           a_0: \u25240     \u251c\u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\u25240     \u251c\n                \u2502      \u2502\u2502      \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502      \u2502\u2502      \u2502\n           a_1: \u2524      \u251c\u25240     \u251c\u25242     \u251c\u25242     \u251c\u25240     \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           a_2: \u2524      \u251c\u2524  MAJ \u251c\u25240     \u251c\u25240     \u251c\u2524  UMA \u251c\u2524      \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_0: \u25241 MAJ \u251c\u2524      \u251c\u2524  MAJ \u251c\u2524  UMA \u251c\u2524      \u251c\u25241 UMA \u251c\n                \u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\u2502      \u2502\n           b_1: \u2524      \u251c\u25241     \u251c\u2524      \u251c\u2524      \u251c\u25241     \u251c\u2524      \u251c\n                \u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\u2502      \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502      \u2502\n           b_2: \u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241     \u251c\u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\n                \u2502      \u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502      \u2502\n        help_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242     \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    It has one less qubit than the full-adder since it doesn't have the carry-out, but uses\n    a helper qubit instead of the carry-in, so it only has one less qubit, not two.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_c04\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    **References:**\n\n    [1] Cuccaro et al., A new quantum ripple-carry addition circuit, 2004.\n    `arXiv:quant-ph/0410184 <https://arxiv.org/pdf/quant-ph/0410184.pdf>`_\n\n    [2] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, kind: str = \"full\", name: str = \"CDKMRippleCarryAdder\"\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits in either input register for\n                state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n                registers must have the same number of qubits.\n            kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n                adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n                and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n                nor carry-out.\n            name: The name of the circuit object.\n        Raises:\n            ValueError: If ``num_state_qubits`` is lower than 1.\n        \"\"\"\n        super().__init__(num_state_qubits, name=name)\n        circuit = adder_ripple_c04(num_state_qubits, kind)\n\n        self.add_register(*circuit.qregs)\n        self.append(circuit.to_gate(), self.qubits)\n",
    "line_count": 124
  },
  {
    "filename": "draper_qft_adder.py",
    "path": "qiskit/circuit/library/arithmetic/adders/draper_qft_adder.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the sum of two qubit registers using QFT.\"\"\"\n\nimport numpy as np\n\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.library.basis_change import QFT\n\nfrom .adder import Adder\n\n\nclass DraperQFTAdder(Adder):\n    r\"\"\"A circuit that uses QFT to perform in-place addition on two qubit registers.\n\n    For registers with :math:`n` qubits, the QFT adder can perform addition modulo\n    :math:`2^n` (with ``kind=\"fixed\"``) or ordinary addition by adding a carry qubits (with\n    ``kind=\"half\"``).\n\n    As an example, a non-fixed_point QFT adder circuit that performs addition on two 2-qubit sized\n    registers is as follows:\n\n    .. code-block:: text\n\n         a_0:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                         \u2502      \u2502                        \u2502\n         a_1:   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(\u03c0)  \u2502        \u2502      \u2502        \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         b_0:   \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n                \u2502      \u2502        \u2502P(\u03c0/2)  \u2502P(\u03c0)  \u2502        \u2502       \u2502       \u2502\n         b_1:   \u25241 qft \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241 iqft \u251c\n                \u2502      \u2502                        \u2502P(\u03c0/2)  \u2502P(\u03c0/4) \u2502       \u2502\n        cout_0: \u25242     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25242      \u251c\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this\n        circuit can be chosen via ``Adder=[\"qft_d00\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n    **References:**\n\n    [1] T. G. Draper, Addition on a Quantum Computer, 2000.\n    `arXiv:quant-ph/0008033 <https://arxiv.org/pdf/quant-ph/0008033.pdf>`_\n\n    [2] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    [3] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, kind: str = \"fixed\", name: str = \"DraperQFTAdder\"\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits in either input register for\n                state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n                registers must have the same number of qubits.\n            kind: The kind of adder, can be ``'half'`` for a half adder or\n                ``'fixed'`` for a fixed-sized adder. A half adder contains a carry-out to represent\n                the most-significant bit, but the fixed-sized adder doesn't and hence performs\n                addition modulo ``2 ** num_state_qubits``.\n            name: The name of the circuit object.\n        Raises:\n            ValueError: If ``num_state_qubits`` is lower than 1.\n        \"\"\"\n        if kind == \"full\":\n            raise ValueError(\"The DraperQFTAdder only supports 'half' and 'fixed' as ``kind``.\")\n\n        if num_state_qubits < 1:\n            raise ValueError(\"The number of qubits must be at least 1.\")\n\n        super().__init__(num_state_qubits, name=name)\n\n        qr_a = QuantumRegister(num_state_qubits, name=\"a\")\n        qr_b = QuantumRegister(num_state_qubits, name=\"b\")\n        qr_list = [qr_a, qr_b]\n\n        if kind == \"half\":\n            qr_z = QuantumRegister(1, name=\"cout\")\n            qr_list.append(qr_z)\n\n        # add registers\n        self.add_register(*qr_list)\n\n        # define register containing the sum and number of qubits for QFT circuit\n        qr_sum = qr_b[:] if kind == \"fixed\" else qr_b[:] + qr_z[:]\n        num_qubits_qft = num_state_qubits if kind == \"fixed\" else num_state_qubits + 1\n\n        circuit = QuantumCircuit(*self.qregs, name=name)\n\n        # build QFT adder circuit\n        circuit.append(QFT(num_qubits_qft, do_swaps=False).to_gate(), qr_sum[:])\n\n        for j in range(num_state_qubits):\n            for k in range(num_state_qubits - j):\n                lam = np.pi / (2**k)\n                circuit.cp(lam, qr_a[j], qr_b[j + k])\n\n        if kind == \"half\":\n            for j in range(num_state_qubits):\n                lam = np.pi / (2 ** (j + 1))\n                circuit.cp(lam, qr_a[num_state_qubits - j - 1], qr_z[0])\n\n        circuit.append(QFT(num_qubits_qft, do_swaps=False).inverse().to_gate(), qr_sum[:])\n\n        self.append(circuit.to_gate(), self.qubits)\n",
    "line_count": 130
  },
  {
    "filename": "vbe_ripple_carry_adder.py",
    "path": "qiskit/circuit/library/arithmetic/adders/vbe_ripple_carry_adder.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the sum of two qubit registers using Classical Addition.\"\"\"\n\nfrom __future__ import annotations\nfrom qiskit.synthesis.arithmetic import adder_ripple_v95\nfrom .adder import Adder\n\n\nclass VBERippleCarryAdder(Adder):\n    r\"\"\"The VBE ripple carry adder [1].\n\n    This circuit performs inplace addition of two equally-sized quantum registers.\n    As an example, a classical adder circuit that performs full addition (i.e. including\n    a carry-in bit) on two 2-qubit sized registers is as follows:\n\n    .. code-block:: text\n\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           cin_0: \u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240          \u251c\u25240     \u251c\n                  \u2502        \u2502                       \u2502           \u2502\u2502      \u2502\n             a_0: \u25241       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241          \u251c\u25241     \u251c\n                  \u2502        \u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502           \u2502\u2502  Sum \u2502\n             a_1: \u2524        \u251c\u25241       \u251c\u2500\u2500\u25a0\u2500\u2500\u25241     \u251c\u2524           \u251c\u2524      \u251c\n                  \u2502        \u2502\u2502        \u2502  \u2502  \u2502      \u2502\u2502           \u2502\u2502      \u2502\n             b_0: \u25242 Carry \u251c\u2524        \u251c\u2500\u2500\u253c\u2500\u2500\u2524      \u251c\u25242 Carry_dg \u251c\u25242     \u251c\n                  \u2502        \u2502\u2502        \u2502\u250c\u2500\u2534\u2500\u2510\u2502      \u2502\u2502           \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             b_1: \u2524        \u251c\u25242 Carry \u251c\u2524 X \u251c\u25242 Sum \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502\u2514\u2500\u2500\u2500\u2518\u2502      \u2502\u2502           \u2502\n          cout_0: \u2524        \u251c\u25243       \u251c\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2502        \u2502\u2502        \u2502     \u2502      \u2502\u2502           \u2502\n        helper_0: \u25243       \u251c\u25240       \u251c\u2500\u2500\u2500\u2500\u2500\u25240     \u251c\u25243          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n    Here *Carry* and *Sum* gates correspond to the gates introduced in [1].\n    *Carry_dg* correspond to the inverse of the *Carry* gate. Note that\n    in this implementation the input register qubits are ordered as all qubits from\n    the first input register, followed by all qubits from the second input register.\n    This is different ordering as compared to Figure 2 in [1], which leads to a different\n    drawing of the circuit.\n\n    .. seealso::\n\n        The following generic gate objects perform additions, like this circuit class,\n        but allow the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Adder=[\"ripple_v95\"]``.\n\n        :class:`.ModularAdderGate`: A generic inplace adder, modulo :math:`2^n`. This\n            is functionally equivalent to ``kind=\"fixed\"``.\n\n        :class:`.AdderGate`: A generic inplace adder. This\n            is functionally equivalent to ``kind=\"half\"``.\n\n        :class:`.FullAdderGate`: A generic inplace adder, with a carry-in bit. This\n            is functionally equivalent to ``kind=\"full\"``.\n\n    **References:**\n\n    [1] Vedral et al., Quantum Networks for Elementary Arithmetic Operations, 1995.\n    `arXiv:quant-ph/9511018 <https://arxiv.org/pdf/quant-ph/9511018.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self, num_state_qubits: int, kind: str = \"full\", name: str = \"VBERippleCarryAdder\"\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The size of the register.\n            kind: The kind of adder, can be ``'full'`` for a full adder, ``'half'`` for a half\n                adder, or ``'fixed'`` for a fixed-sized adder. A full adder includes both carry-in\n                and carry-out, a half only carry-out, and a fixed-sized adder neither carry-in\n                nor carry-out.\n            name: The name of the circuit.\n\n        Raises:\n            ValueError: If ``num_state_qubits`` is lower than 1.\n        \"\"\"\n        super().__init__(num_state_qubits, name=name)\n        circuit = adder_ripple_v95(num_state_qubits, kind)\n\n        self.add_register(*circuit.qregs)\n        self.append(circuit.to_gate(), self.qubits)\n",
    "line_count": 96
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/arithmetic/multipliers/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The multiplier circuit library.\"\"\"\n\nfrom .hrs_cumulative_multiplier import HRSCumulativeMultiplier\nfrom .rg_qft_multiplier import RGQFTMultiplier\nfrom .multiplier import MultiplierGate\n",
    "line_count": 18
  },
  {
    "filename": "hrs_cumulative_multiplier.py",
    "path": "qiskit/circuit/library/arithmetic/multipliers/hrs_cumulative_multiplier.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the product of two qubit registers using classical multiplication approach.\"\"\"\n\nfrom typing import Optional\nfrom qiskit.circuit import QuantumRegister, AncillaRegister, QuantumCircuit\n\nfrom .multiplier import Multiplier\n\n\nclass HRSCumulativeMultiplier(Multiplier):\n    r\"\"\"A multiplication circuit to store product of two input registers out-of-place.\n\n    Circuit uses the approach from [1]. As an example, a multiplier circuit that\n    performs a non-modular multiplication on two 3-qubit sized registers with\n    the default adder is as follows (where ``Adder`` denotes the\n    ``CDKMRippleCarryAdder``):\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502\n          a_1: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                   \u2502         \u2502\n          a_2: \u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n          b_0: \u25240       \u251c\u25240       \u251c\u25240       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_1: \u25241       \u251c\u25241       \u251c\u25241       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n          b_2: \u25242       \u251c\u25242       \u251c\u25242       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_0: \u25243       \u251c\u2524        \u251c\u2524        \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_1: \u25244       \u251c\u25243       \u251c\u2524        \u251c\n               \u2502  Adder \u2502\u2502  Adder \u2502\u2502  Adder \u2502\n        out_2: \u25245       \u251c\u25244       \u251c\u25243       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_3: \u25246       \u251c\u25245       \u251c\u25244       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_4: \u2524        \u251c\u25246       \u251c\u25245       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        out_5: \u2524        \u251c\u2524        \u251c\u25246       \u251c\n               \u2502        \u2502\u2502        \u2502\u2502        \u2502\n        aux_0: \u25247       \u251c\u25247       \u251c\u25247       \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Multiplication in this circuit is implemented in a classical approach by performing\n    a series of shifted additions using one of the input registers while the qubits\n    from the other input register act as control qubits for the adders.\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"cumulative_h18\"]``.\n\n    **References:**\n\n    [1] H\u00e4ner et al., Optimizing Quantum Circuits for Arithmetic, 2018.\n    `arXiv:1805.12445 <https://arxiv.org/pdf/1805.12445.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        num_result_qubits: Optional[int] = None,\n        adder: Optional[QuantumCircuit] = None,\n        name: str = \"HRSCumulativeMultiplier\",\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits in either input register for\n                state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n                registers must have the same number of qubits.\n            num_result_qubits: The number of result qubits to limit the output to.\n                If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n                to limit the output to the specified number of qubits. Default\n                value is ``2 * num_state_qubits`` to represent any possible\n                result from the multiplication of the two inputs.\n            adder: Half adder circuit to be used for performing multiplication. The\n                CDKMRippleCarryAdder is used as default if no adder is provided.\n            name: The name of the circuit object.\n        Raises:\n            NotImplementedError: If ``num_result_qubits`` is not default and a custom adder is provided.\n        \"\"\"\n        super().__init__(num_state_qubits, num_result_qubits, name=name)\n\n        if self.num_result_qubits != 2 * num_state_qubits and adder is not None:\n            raise NotImplementedError(\"Only default adder is supported for modular multiplication.\")\n\n        # define the registers\n        qr_a = QuantumRegister(num_state_qubits, name=\"a\")\n        qr_b = QuantumRegister(num_state_qubits, name=\"b\")\n        qr_out = QuantumRegister(self.num_result_qubits, name=\"out\")\n        self.add_register(qr_a, qr_b, qr_out)\n\n        # prepare adder as controlled gate\n        if adder is None:\n            from qiskit.circuit.library.arithmetic.adders import CDKMRippleCarryAdder\n\n            adder = CDKMRippleCarryAdder(num_state_qubits, kind=\"half\")\n\n        # get the number of helper qubits needed\n        num_helper_qubits = adder.num_ancillas\n\n        # add helper qubits if required\n        if num_helper_qubits > 0:\n            qr_h = AncillaRegister(num_helper_qubits, name=\"helper\")  # helper/ancilla qubits\n            self.add_register(qr_h)\n\n        # build multiplication circuit\n        circuit = QuantumCircuit(*self.qregs, name=name)\n\n        for i in range(num_state_qubits):\n            excess_qubits = max(0, num_state_qubits + i + 1 - self.num_result_qubits)\n            if excess_qubits == 0:\n                num_adder_qubits = num_state_qubits\n                adder_for_current_step = adder\n            else:\n                num_adder_qubits = num_state_qubits - excess_qubits + 1\n                adder_for_current_step = CDKMRippleCarryAdder(num_adder_qubits, kind=\"fixed\")\n            controlled_adder = adder_for_current_step.to_gate().control(1)\n            qr_list = (\n                [qr_a[i]]\n                + qr_b[:num_adder_qubits]\n                + qr_out[i : num_state_qubits + i + 1 - excess_qubits]\n            )\n            if num_helper_qubits > 0:\n                qr_list.extend(qr_h[:])\n            circuit.append(controlled_adder, qr_list)\n\n        self.append(circuit.to_gate(), self.qubits)\n",
    "line_count": 146
  },
  {
    "filename": "multiplier.py",
    "path": "qiskit/circuit/library/arithmetic/multipliers/multiplier.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the product of two equally sized qubit registers.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumCircuit, Gate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass Multiplier(QuantumCircuit):\n    r\"\"\"Compute the product of two equally sized qubit registers into a new register.\n\n    For two input registers :math:`|a\\rangle_n`, :math:`|b\\rangle_n` with :math:`n` qubits each\n    and an output register with :math:`2n` qubits, a multiplier performs the following operation\n\n    .. math::\n\n        |a\\rangle_n |b\\rangle_n |0\\rangle_{t} \\mapsto |a\\rangle_n |b\\rangle_n |a \\cdot b\\rangle_t\n\n    where :math:`t` is the number of bits used to represent the result. To completely store the result\n    of the multiplication without overflow we need :math:`t = 2n` bits.\n\n    The quantum register :math:`|a\\rangle_n` (analogously :math:`|b\\rangle_n` and\n    output register)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=(\n            \"Use the MultiplierGate provided in qiskit.circuit.library.arithmetic instead. \"\n            \"For different multiplier implementations, see \"\n            \"https://docs.quantum.ibm.com/api/qiskit/synthesis.\",\n        ),\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_state_qubits: int,\n        num_result_qubits: int | None = None,\n        name: str = \"Multiplier\",\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the input registers.\n            num_result_qubits: The number of result qubits to limit the output to.\n                Default value is ``2 * num_state_qubits`` to represent any possible\n                result from the multiplication of the two inputs.\n            name: The name of the circuit.\n        Raises:\n            ValueError: If ``num_state_qubits`` is smaller than 1.\n            ValueError: If ``num_result_qubits`` is smaller than ``num_state_qubits``.\n            ValueError: If ``num_result_qubits`` is larger than ``2 * num_state_qubits``.\n        \"\"\"\n        if num_state_qubits < 1:\n            raise ValueError(\"The number of qubits must be at least 1.\")\n\n        if num_result_qubits is None:\n            num_result_qubits = 2 * num_state_qubits\n\n        if num_result_qubits < num_state_qubits:\n            raise ValueError(\n                \"Number of result qubits is smaller than number of input state qubits.\"\n            )\n        if num_result_qubits > 2 * num_state_qubits:\n            raise ValueError(\n                \"Number of result qubits is larger than twice the number of input state qubits.\"\n            )\n\n        super().__init__(name=name)\n        self._num_state_qubits = num_state_qubits\n        self._num_result_qubits = num_result_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    @property\n    def num_result_qubits(self) -> int:\n        \"\"\"The number of result qubits to limit the output to.\n\n        Returns:\n            The number of result qubits.\n        \"\"\"\n        return self._num_result_qubits\n\n\nclass MultiplierGate(Gate):\n    r\"\"\"Compute the product of two equally sized qubit registers into a new register.\n\n    For two input registers :math:`|a\\rangle_n`, :math:`|b\\rangle_n` with :math:`n` qubits each\n    and an output register with :math:`2n` qubits, a multiplier performs the following operation\n\n    .. math::\n\n        |a\\rangle_n |b\\rangle_n |0\\rangle_{t} \\mapsto |a\\rangle_n |b\\rangle_n |a \\cdot b\\rangle_t\n\n    where :math:`t` is the number of bits used to represent the result. To completely store the result\n    of the multiplication without overflow we need :math:`t = 2n` bits.\n\n    The quantum register :math:`|a\\rangle_n` (analogously :math:`|b\\rangle_n` and\n    output register)\n\n    .. math::\n\n        |a\\rangle_n = |a_0\\rangle \\otimes \\cdots \\otimes |a_{n - 1}\\rangle,\n\n    for :math:`a_i \\in \\{0, 1\\}`, is associated with the integer value\n\n    .. math::\n\n        a = 2^{0}a_{0} + 2^{1}a_{1} + \\cdots + 2^{n - 1}a_{n - 1}.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        num_result_qubits: int | None = None,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_state_qubits: The number of qubits in each of the input registers.\n            num_result_qubits: The number of result qubits to limit the output to.\n                Default value is ``2 * num_state_qubits`` to represent any possible\n                result from the multiplication of the two inputs.\n            name: The name of the circuit.\n        Raises:\n            ValueError: If ``num_state_qubits`` is smaller than 1.\n            ValueError: If ``num_result_qubits`` is smaller than ``num_state_qubits``.\n            ValueError: If ``num_result_qubits`` is larger than ``2 * num_state_qubits``.\n        \"\"\"\n        if num_state_qubits < 1:\n            raise ValueError(\"The number of state qubits must be at least 1.\")\n\n        if num_result_qubits is None:\n            num_result_qubits = 2 * num_state_qubits\n        elif num_result_qubits < num_state_qubits or num_result_qubits > 2 * num_state_qubits:\n            raise ValueError(\n                f\"num_result_qubits ({num_result_qubits}) must be in between num_state_qubits \"\n                f\"({num_state_qubits}) and 2 * num_state_qubits ({2 * num_state_qubits})\"\n            )\n\n        super().__init__(\"Multiplier\", 2 * num_state_qubits + num_result_qubits, [], label=label)\n\n        self._num_state_qubits = num_state_qubits\n        self._num_result_qubits = num_result_qubits\n\n    @property\n    def num_state_qubits(self) -> int:\n        \"\"\"The number of state qubits, i.e. the number of bits in each input register.\n\n        Returns:\n            The number of state qubits.\n        \"\"\"\n        return self._num_state_qubits\n\n    @property\n    def num_result_qubits(self) -> int:\n        \"\"\"The number of result qubits to limit the output to.\n\n        Returns:\n            The number of result qubits.\n        \"\"\"\n        return self._num_result_qubits\n\n    def _define(self):\n        \"\"\"Populates self.definition with some decomposition of this gate.\"\"\"\n        from qiskit.synthesis.arithmetic import multiplier_qft_r17\n\n        # This particular decomposition does not use any ancilla qubits.\n        # Note that the transpiler may choose a different decomposition\n        # based on the number of ancilla qubits available.\n        self.definition = multiplier_qft_r17(self.num_state_qubits)\n",
    "line_count": 202
  },
  {
    "filename": "rg_qft_multiplier.py",
    "path": "qiskit/circuit/library/arithmetic/multipliers/rg_qft_multiplier.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2021.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Compute the product of two qubit registers using QFT.\"\"\"\n\nfrom typing import Optional\nimport numpy as np\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit\nfrom qiskit.circuit.library.standard_gates import PhaseGate\nfrom qiskit.circuit.library.basis_change import QFT\n\nfrom .multiplier import Multiplier\n\n\nclass RGQFTMultiplier(Multiplier):\n    r\"\"\"A QFT multiplication circuit to store product of two input registers out-of-place.\n\n    Multiplication in this circuit is implemented using the procedure of Fig. 3 in [1], where\n    weighted sum rotations are implemented as given in Fig. 5 in [1]. QFT is used on the output\n    register and is followed by rotations controlled by input registers. The rotations\n    transform the state into the product of two input registers in QFT base, which is\n    reverted from QFT base using inverse QFT.\n    As an example, a circuit that performs a modular QFT multiplication on two 2-qubit\n    sized input registers with an output register of 2 qubits, is as follows:\n\n    .. code-block:: text\n\n          a_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                       \u2502       \u2502      \u2502      \u2502\n          a_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_0: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                        \u2502       \u2502       \u2502       \u2502      \u2502       \u2502      \u2502      \u2502\n          b_1: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502P(4\u03c0)  \u2502       \u2502P(2\u03c0)  \u2502      \u2502P(2\u03c0)  \u2502      \u2502P(\u03c0)  \u2502       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        out_0: \u25240     \u251c\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25240      \u251c\n               \u2502  qft \u2502         \u2502P(2\u03c0)          \u2502P(\u03c0)          \u2502P(\u03c0)         \u2502P(\u03c0/2) \u2502  iqft \u2502\n        out_1: \u25241     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25241      \u251c\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    .. seealso::\n\n        The :class:`.MultiplierGate` objects represents a multiplication, like this circuit class,\n        but allows the compiler to select the optimal decomposition based on the context.\n        Specific implementations can be set via the :class:`.HLSConfig`, e.g. this circuit\n        can be chosen via ``Multiplier=[\"qft_r17\"]``.\n\n    **References:**\n\n    [1] Ruiz-Perez et al., Quantum arithmetic with the Quantum Fourier Transform, 2017.\n    `arXiv:1411.5949 <https://arxiv.org/pdf/1411.5949.pdf>`_\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_state_qubits: int,\n        num_result_qubits: Optional[int] = None,\n        name: str = \"RGQFTMultiplier\",\n    ) -> None:\n        r\"\"\"\n        Args:\n            num_state_qubits: The number of qubits in either input register for\n                state :math:`|a\\rangle` or :math:`|b\\rangle`. The two input\n                registers must have the same number of qubits.\n            num_result_qubits: The number of result qubits to limit the output to.\n                If number of result qubits is :math:`n`, multiplication modulo :math:`2^n` is performed\n                to limit the output to the specified number of qubits. Default\n                value is ``2 * num_state_qubits`` to represent any possible\n                result from the multiplication of the two inputs.\n            name: The name of the circuit object.\n\n        \"\"\"\n        super().__init__(num_state_qubits, num_result_qubits, name=name)\n\n        # define the registers\n        qr_a = QuantumRegister(num_state_qubits, name=\"a\")\n        qr_b = QuantumRegister(num_state_qubits, name=\"b\")\n        qr_out = QuantumRegister(self.num_result_qubits, name=\"out\")\n        self.add_register(qr_a, qr_b, qr_out)\n\n        # build multiplication circuit\n        circuit = QuantumCircuit(*self.qregs, name=name)\n\n        circuit.append(QFT(self.num_result_qubits, do_swaps=False).to_gate(), qr_out[:])\n\n        for j in range(1, num_state_qubits + 1):\n            for i in range(1, num_state_qubits + 1):\n                for k in range(1, self.num_result_qubits + 1):\n                    lam = (2 * np.pi) / (2 ** (i + j + k - 2 * num_state_qubits))\n                    circuit.append(\n                        PhaseGate(lam).control(2),\n                        [qr_a[num_state_qubits - j], qr_b[num_state_qubits - i], qr_out[k - 1]],\n                    )\n\n        circuit.append(QFT(self.num_result_qubits, do_swaps=False).inverse().to_gate(), qr_out[:])\n\n        self.append(circuit.to_gate(), self.qubits)\n",
    "line_count": 109
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/basis_change/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The basis change circuits.\"\"\"\n\nfrom .qft import QFT, QFTGate\n",
    "line_count": 16
  },
  {
    "filename": "qft.py",
    "path": "qiskit/circuit/library/basis_change/qft.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Define a Quantum Fourier Transform circuit (QFT) and a native gate (QFTGate).\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\n\nfrom qiskit.circuit.quantumcircuit import QuantumRegister, CircuitInstruction, Gate\nfrom qiskit.utils.deprecation import deprecate_func\nfrom ..blueprintcircuit import BlueprintCircuit\n\n\nclass QFT(BlueprintCircuit):\n    r\"\"\"Quantum Fourier Transform Circuit.\n\n    The Quantum Fourier Transform (QFT) on :math:`n` qubits is the operation\n\n    .. math::\n\n        |j\\rangle \\mapsto \\frac{1}{2^{n/2}} \\sum_{k=0}^{2^n - 1} e^{2\\pi ijk / 2^n} |k\\rangle\n\n    The circuit that implements this transformation can be implemented using Hadamard gates\n    on each qubit, a series of controlled-U1 (or Z, depending on the phase) gates and a\n    layer of Swap gates. The layer of Swap gates can in principle be dropped if the QFT appears\n    at the end of the circuit, since then the re-ordering can be done classically. They\n    can be turned off using the ``do_swaps`` attribute.\n\n    For 4 qubits, the circuit that implements this transformation is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4)\n       _generate_circuit_library_visualization(circuit)\n\n    The inverse QFT can be obtained by calling the ``inverse`` method on this class.\n    The respective circuit diagram is:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(4).inverse()\n       _generate_circuit_library_visualization(circuit)\n\n    One method to reduce circuit depth is to implement the QFT approximately by ignoring\n    controlled-phase rotations where the angle is beneath a threshold. This is discussed\n    in more detail in https://arxiv.org/abs/quant-ph/9601018 or\n    https://arxiv.org/abs/quant-ph/0403071.\n\n    Here, this can be adjusted using the ``approximation_degree`` attribute: the smallest\n    ``approximation_degree`` rotation angles are dropped from the QFT. For instance, a QFT\n    on 5 qubits with approximation degree 2 yields (the barriers are dropped in this example):\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import QFT\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QFT(5, approximation_degree=2)\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=(\n            \"Use qiskit.circuit.library.QFTGate or qiskit.synthesis.qft.synth_qft_full instead, \"\n            \"for access to all previous arguments.\",\n        ),\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_qubits: int | None = None,\n        approximation_degree: int = 0,\n        do_swaps: bool = True,\n        inverse: bool = False,\n        insert_barriers: bool = False,\n        name: str | None = None,\n    ) -> None:\n        \"\"\"Construct a new QFT circuit.\n\n        Args:\n            num_qubits: The number of qubits on which the QFT acts.\n            approximation_degree: The degree of approximation (0 for no approximation).\n            do_swaps: Whether to include the final swaps in the QFT.\n            inverse: If True, the inverse Fourier transform is constructed.\n            insert_barriers: If True, barriers are inserted as visualization improvement.\n            name: The name of the circuit.\n        \"\"\"\n        if name is None:\n            name = \"IQFT\" if inverse else \"QFT\"\n\n        super().__init__(name=name)\n        self._approximation_degree = approximation_degree\n        self._do_swaps = do_swaps\n        self._insert_barriers = insert_barriers\n        self._inverse = inverse\n        self.num_qubits = num_qubits\n\n    @property\n    def num_qubits(self) -> int:\n        \"\"\"The number of qubits in the QFT circuit.\n\n        Returns:\n            The number of qubits in the circuit.\n        \"\"\"\n        # This method needs to be overwritten to allow adding the setter for num_qubits while still\n        # complying to pylint.\n        return super().num_qubits\n\n    @num_qubits.setter\n    def num_qubits(self, num_qubits: int) -> None:\n        \"\"\"Set the number of qubits.\n\n        Note that this changes the registers of the circuit.\n\n        Args:\n            num_qubits: The new number of qubits.\n        \"\"\"\n        if num_qubits != self.num_qubits:\n            self._invalidate()\n\n            self.qregs = []\n            if num_qubits is not None and num_qubits > 0:\n                self.qregs = [QuantumRegister(num_qubits, name=\"q\")]\n\n    @property\n    def approximation_degree(self) -> int:\n        \"\"\"The approximation degree of the QFT.\n\n        Returns:\n            The currently set approximation degree.\n        \"\"\"\n        return self._approximation_degree\n\n    @approximation_degree.setter\n    def approximation_degree(self, approximation_degree: int) -> None:\n        \"\"\"Set the approximation degree of the QFT.\n\n        Args:\n            approximation_degree: The new approximation degree.\n\n        Raises:\n            ValueError: If the approximation degree is smaller than 0.\n        \"\"\"\n        if approximation_degree < 0:\n            raise ValueError(\"Approximation degree cannot be smaller than 0.\")\n\n        if approximation_degree != self._approximation_degree:\n            self._invalidate()\n            self._approximation_degree = approximation_degree\n\n    @property\n    def insert_barriers(self) -> bool:\n        \"\"\"Whether barriers are inserted for better visualization or not.\n\n        Returns:\n            True, if barriers are inserted, False if not.\n        \"\"\"\n        return self._insert_barriers\n\n    @insert_barriers.setter\n    def insert_barriers(self, insert_barriers: bool) -> None:\n        \"\"\"Specify whether barriers are inserted for better visualization or not.\n\n        Args:\n            insert_barriers: If True, barriers are inserted, if False not.\n        \"\"\"\n        if insert_barriers != self._insert_barriers:\n            self._invalidate()\n            self._insert_barriers = insert_barriers\n\n    @property\n    def do_swaps(self) -> bool:\n        \"\"\"Whether the final swaps of the QFT are applied or not.\n\n        Returns:\n            True, if the final swaps are applied, False if not.\n        \"\"\"\n        return self._do_swaps\n\n    @do_swaps.setter\n    def do_swaps(self, do_swaps: bool) -> None:\n        \"\"\"Specify whether to do the final swaps of the QFT circuit or not.\n\n        Args:\n            do_swaps: If True, the final swaps are applied, if False not.\n        \"\"\"\n        if do_swaps != self._do_swaps:\n            self._invalidate()\n            self._do_swaps = do_swaps\n\n    def is_inverse(self) -> bool:\n        \"\"\"Whether the inverse Fourier transform is implemented.\n\n        Returns:\n            True, if the inverse Fourier transform is implemented, False otherwise.\n        \"\"\"\n        return self._inverse\n\n    def inverse(self, annotated: bool = False) -> \"QFT\":\n        \"\"\"Invert this circuit.\n\n        Args:\n            annotated: indicates whether the inverse gate can be implemented\n                as an annotated gate. The value of this argument is ignored as the\n                inverse of a QFT is an IQFT which is just another instance of\n                :class:`.QFT`.\n\n        Returns:\n            The inverted circuit.\n        \"\"\"\n\n        if self.name in (\"QFT\", \"IQFT\"):\n            name = \"QFT\" if self._inverse else \"IQFT\"\n        else:\n            name = self.name + \"_dg\"\n\n        inverted = self.copy(name=name)\n\n        # data consists of the QFT gate only\n        iqft = self.data[0].operation.inverse()\n        iqft.name = name\n\n        inverted.data.clear()\n        inverted._append(CircuitInstruction(iqft, inverted.qubits, []))\n\n        inverted._inverse = not self._inverse\n        return inverted\n\n    def _check_configuration(self, raise_on_failure: bool = True) -> bool:\n        \"\"\"Check if the current configuration is valid.\"\"\"\n        valid = True\n        if self.num_qubits is None:\n            valid = False\n            if raise_on_failure:\n                raise AttributeError(\"The number of qubits has not been set.\")\n        return valid\n\n    def _build(self) -> None:\n        \"\"\"If not already built, build the circuit.\"\"\"\n        if self._is_built:\n            return\n\n        super()._build()\n\n        num_qubits = self.num_qubits\n\n        if num_qubits == 0:\n            return\n\n        from qiskit.synthesis.qft import synth_qft_full\n\n        circuit = synth_qft_full(\n            num_qubits,\n            do_swaps=self._do_swaps,\n            insert_barriers=self._insert_barriers,\n            approximation_degree=self._approximation_degree,\n            inverse=self._inverse,\n            name=self.name,\n        )\n\n        wrapped = circuit.to_instruction() if self.insert_barriers else circuit.to_gate()\n        self.compose(wrapped, qubits=self.qubits, inplace=True)\n\n\nclass QFTGate(Gate):\n    r\"\"\"Quantum Fourier Transform Gate.\n\n    The Quantum Fourier Transform (QFT) on :math:`n` qubits is the operation\n\n    .. math::\n\n        |j\\rangle \\mapsto \\frac{1}{2^{n/2}} \\sum_{k=0}^{2^n - 1} e^{2\\pi ijk / 2^n} |k\\rangle\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits: int,\n    ):\n        \"\"\"\n        Args:\n            num_qubits: The number of qubits on which the QFT acts.\n        \"\"\"\n        super().__init__(name=\"qft\", num_qubits=num_qubits, params=[])\n\n    def __array__(self, dtype=complex, copy=None):\n        \"\"\"Return a numpy array for the QFTGate.\"\"\"\n        if copy is False:\n            raise ValueError(\"unable to avoid copy while creating an array as requested\")\n        n = self.num_qubits\n        nums = np.arange(2**n)\n        outer = np.outer(nums, nums)\n        return np.exp(2j * np.pi * outer * (0.5**n), dtype=dtype) * (0.5 ** (n / 2))\n\n    def _define(self):\n        \"\"\"Provide a specific decomposition of the QFTGate into a quantum circuit.\"\"\"\n        from qiskit.synthesis.qft import synth_qft_full\n\n        self.definition = synth_qft_full(num_qubits=self.num_qubits)\n",
    "line_count": 317
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/boolean_logic/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The Boolean logic circuit library.\"\"\"\n\nfrom .quantum_and import AND, AndGate\nfrom .quantum_or import OR, OrGate\nfrom .quantum_xor import XOR, BitwiseXorGate, random_bitwise_xor\nfrom .inner_product import InnerProduct, InnerProductGate\n",
    "line_count": 19
  },
  {
    "filename": "inner_product.py",
    "path": "qiskit/circuit/library/boolean_logic/inner_product.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"InnerProduct circuit and gate.\"\"\"\n\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit, Gate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass InnerProduct(QuantumCircuit):\n    r\"\"\"A 2n-qubit Boolean function that computes the inner product of\n    two n-qubit vectors over :math:`F_2`.\n\n    This implementation is a phase oracle which computes the following transform.\n\n    .. math::\n\n        \\mathcal{IP}_{2n} : F_2^{2n} \\rightarrow {-1, 1}\n        \\mathcal{IP}_{2n}(x_1, \\cdots, x_n, y_1, \\cdots, y_n) = (-1)^{x.y}\n\n    The corresponding unitary is a diagonal, which induces a -1 phase on any inputs\n    where the inner product of the top and bottom registers is 1. Otherwise it keeps\n    the input intact.\n\n    .. code-block:: text\n\n\n        q0_0: \u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502\n        q0_1: \u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502  \u2502\n        q0_2: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n               \u2502  \u2502  \u2502\n        q0_3: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\n               \u2502  \u2502  \u2502  \u2502\n        q1_0: \u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                  \u2502  \u2502  \u2502\n        q1_1: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                     \u2502  \u2502\n        q1_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\n                        \u2502\n        q1_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\n\n\n    Reference Circuit:\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit.library import InnerProduct\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           circuit = InnerProduct(4)\n           _generate_circuit_library_visualization(circuit)\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.InnerProductGate instead.\",\n        pending=True,\n    )\n    def __init__(self, num_qubits: int) -> None:\n        \"\"\"Return a circuit to compute the inner product of 2 n-qubit registers.\n\n        Args:\n            num_qubits: width of top and bottom registers (half total circuit width)\n        \"\"\"\n        qr_a = QuantumRegister(num_qubits)\n        qr_b = QuantumRegister(num_qubits)\n        inner = QuantumCircuit(qr_a, qr_b, name=\"inner_product\")\n\n        for i in range(num_qubits):\n            inner.cz(qr_a[i], qr_b[i])\n\n        super().__init__(*inner.qregs, name=\"inner_product\")\n        self.compose(inner.to_gate(), qubits=self.qubits, inplace=True)\n\n\nclass InnerProductGate(Gate):\n    r\"\"\"A 2n-qubit Boolean function that computes the inner product of\n    two n-qubit vectors over :math:`F_2`.\n\n    This implementation is a phase oracle which computes the following transform.\n\n    .. math::\n\n        \\mathcal{IP}_{2n} : F_2^{2n} \\rightarrow {-1, 1}\n        \\mathcal{IP}_{2n}(x_1, \\cdots, x_n, y_1, \\cdots, y_n) = (-1)^{x.y}\n\n    The corresponding unitary is a diagonal, which induces a -1 phase on any inputs\n    where the inner product of the top and bottom registers is 1. Otherwise, it keeps\n    the input intact.\n\n    .. parsed-literal::\n\n\n        q0_0: \u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502\n        q0_1: \u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n               \u2502  \u2502\n        q0_2: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n               \u2502  \u2502  \u2502\n        q0_3: \u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u25a0\u2500\n               \u2502  \u2502  \u2502  \u2502\n        q1_0: \u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                  \u2502  \u2502  \u2502\n        q1_1: \u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u253c\u2500\n                     \u2502  \u2502\n        q1_2: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u253c\u2500\n                        \u2502\n        q1_3: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\n\n\n    Reference Circuit:\n        .. plot::\n           :alt: Diagram illustrating the previously described circuit.\n\n           from qiskit.circuit import QuantumCircuit\n           from qiskit.circuit.library import InnerProductGate\n           from qiskit.visualization.library import _generate_circuit_library_visualization\n           circuit = QuantumCircuit(8)\n           circuit.append(InnerProductGate(4), [0, 1, 2, 3, 4, 5, 6, 7])\n           _generate_circuit_library_visualization(circuit)\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits: int,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_qubits: width of top and bottom registers (half total number of qubits).\n        \"\"\"\n        super().__init__(\"inner_product\", 2 * num_qubits, [])\n\n    def _define(self):\n        num_qubits = self.num_qubits // 2\n        qr_a = QuantumRegister(num_qubits, name=\"x\")\n        qr_b = QuantumRegister(num_qubits, name=\"y\")\n\n        circuit = QuantumCircuit(qr_a, qr_b, name=\"inner_product\")\n        for i in range(num_qubits):\n            circuit.cz(qr_a[i], qr_b[i])\n\n        self.definition = circuit\n\n    def __eq__(self, other):\n        return isinstance(other, InnerProductGate) and self.num_qubits == other.num_qubits\n",
    "line_count": 158
  },
  {
    "filename": "quantum_and.py",
    "path": "qiskit/circuit/library/boolean_logic/quantum_and.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Boolean AND circuit and gate.\"\"\"\n\nfrom __future__ import annotations\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit, AncillaRegister, Gate\nfrom qiskit.circuit.library.standard_gates import MCXGate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass AND(QuantumCircuit):\n    r\"\"\"A circuit implementing the logical AND operation on a number of qubits.\n\n    For the AND operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of all variable qubits is ``True``. In this format, the AND\n    operation equals a multi-controlled X gate, which is controlled on all variable qubits.\n    Using a list of flags however, qubits can be skipped or negated. Practically, the flags\n    allow to skip controls or to apply pre- and post-X gates to the negated qubits.\n\n    The AND gate without special flags equals the multi-controlled-X gate:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import AND\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = AND(5)\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` and the last two are ``True`` we use the flags\n    ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import AND\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = AND(5, flags=[-1, 0, 0, 1, 1])\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.AndGate instead.\",\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_variable_qubits: int,\n        flags: list[int] | None = None,\n        mcx_mode: str = \"noancilla\",\n    ) -> None:\n        \"\"\"Create a new logical AND circuit.\n\n        Args:\n            num_variable_qubits: The qubits of which the AND is computed. The result will be written\n                into an additional result qubit.\n            flags: A list of +1/0/-1 marking negations or omissions of qubits.\n            mcx_mode: The mode to be used to implement the multi-controlled X gate.\n        \"\"\"\n        self.num_variable_qubits = num_variable_qubits\n        self.flags = flags\n\n        # add registers\n        qr_variable = QuantumRegister(num_variable_qubits, name=\"variable\")\n        qr_result = QuantumRegister(1, name=\"result\")\n\n        circuit = QuantumCircuit(qr_variable, qr_result, name=\"and\")\n\n        # determine the control qubits: all that have a nonzero flag\n        flags = flags or [1] * num_variable_qubits\n        control_qubits = [q for q, flag in zip(qr_variable, flags) if flag != 0]\n\n        # determine the qubits that need to be flipped (if a flag is < 0)\n        flip_qubits = [q for q, flag in zip(qr_variable, flags) if flag < 0]\n\n        # determine the number of ancillas\n        num_ancillas = MCXGate.get_num_ancilla_qubits(len(control_qubits), mode=mcx_mode)\n        if num_ancillas > 0:\n            qr_ancilla = AncillaRegister(num_ancillas, \"ancilla\")\n            circuit.add_register(qr_ancilla)\n        else:\n            qr_ancilla = AncillaRegister(0)\n\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n        circuit.mcx(control_qubits, qr_result[:], qr_ancilla[:], mode=mcx_mode)\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n\n        super().__init__(*circuit.qregs, name=\"and\")\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\nclass AndGate(Gate):\n    r\"\"\"A gate representing the logical AND operation on a number of qubits.\n\n    For the AND operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of all variable qubits is ``True``. In this format, the AND\n    operation equals a multi-controlled X gate, which is controlled on all variable qubits.\n    Using a list of flags however, qubits can be skipped or negated. Practically, the flags\n    allow to skip controls or to apply pre- and post-X gates to the negated qubits.\n\n    The AndGate gate without special flags equals the multi-controlled-X gate:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import AndGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumCircuit(6)\n       circuit.append(AndGate(5), [0, 1, 2, 3, 4, 5])\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` and the last two are ``True`` we use the flags\n    ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import AndGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumCircuit(6)\n       circuit.append(AndGate(5, flags=[-1, 0, 0, 1, 1]), [0, 1, 2, 3, 4, 5])\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_variable_qubits: int,\n        flags: list[int] | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_variable_qubits: The qubits of which the AND is computed. The result will be written\n                into an additional result qubit.\n            flags: A list of +1/0/-1 marking negations or omissions of qubits.\n        \"\"\"\n        super().__init__(\"and\", num_variable_qubits + 1, [])\n        self.num_variable_qubits = num_variable_qubits\n        self.flags = flags\n\n    def _define(self):\n        # add registers\n        qr_variable = QuantumRegister(self.num_variable_qubits, name=\"variable\")\n        qr_result = QuantumRegister(1, name=\"result\")\n\n        # determine the control qubits: all that have a nonzero flag\n        flags = self.flags or [1] * self.num_variable_qubits\n        control_qubits = [q for q, flag in zip(qr_variable, flags) if flag != 0]\n\n        # determine the qubits that need to be flipped (if a flag is < 0)\n        flip_qubits = [q for q, flag in zip(qr_variable, flags) if flag < 0]\n\n        # create the definition circuit\n        circuit = QuantumCircuit(qr_variable, qr_result, name=\"and\")\n\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n        circuit.mcx(control_qubits, qr_result[:])\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n\n        self.definition = circuit\n\n    # pylint: disable=unused-argument\n    def inverse(self, annotated: bool = False):\n        r\"\"\"Return inverted AND gate (itself).\n\n        Args:\n            annotated: when set to ``True``, this is typically used to return an\n                :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n                :class:`.Gate`. However, for this class this argument is ignored as this gate\n                is self-inverse.\n\n        Returns:\n            AndGate: inverse gate (self-inverse).\n        \"\"\"\n        return AndGate(self.num_variable_qubits, self.flags)\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, AndGate)\n            and self.num_variable_qubits == other.num_variable_qubits\n            and self.flags == other.flags\n        )\n",
    "line_count": 205
  },
  {
    "filename": "quantum_or.py",
    "path": "qiskit/circuit/library/boolean_logic/quantum_or.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Boolean OR circuit and gate.\"\"\"\n\nfrom __future__ import annotations\nfrom typing import List, Optional\n\nfrom qiskit.circuit import QuantumRegister, QuantumCircuit, AncillaRegister, Gate\nfrom qiskit.circuit.library.standard_gates import MCXGate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass OR(QuantumCircuit):\n    r\"\"\"A circuit implementing the logical OR operation on a number of qubits.\n\n    For the OR operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of any variable qubit is ``True``. The OR is implemented using\n    a multi-open-controlled X gate (i.e. flips if the state is :math:`|0\\rangle`) and\n    applying an X gate on the result qubit.\n    Using a list of flags, qubits can be skipped or negated.\n\n    The OR gate without special flags:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import OR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = OR(5)\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` or one of the last two are ``True`` we use the\n    flags ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import OR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = OR(5, flags=[-1, 0, 0, 1, 1])\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Use qiskit.circuit.library.OrGate instead.\",\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_variable_qubits: int,\n        flags: Optional[List[int]] = None,\n        mcx_mode: str = \"noancilla\",\n    ) -> None:\n        \"\"\"Create a new logical OR circuit.\n\n        Args:\n            num_variable_qubits: The qubits of which the OR is computed. The result will be written\n                into an additional result qubit.\n            flags: A list of +1/0/-1 marking negations or omissions of qubits.\n            mcx_mode: The mode to be used to implement the multi-controlled X gate.\n        \"\"\"\n        self.num_variable_qubits = num_variable_qubits\n        self.flags = flags\n\n        # add registers\n        qr_variable = QuantumRegister(num_variable_qubits, name=\"variable\")\n        qr_result = QuantumRegister(1, name=\"result\")\n        circuit = QuantumCircuit(qr_variable, qr_result, name=\"or\")\n\n        # determine the control qubits: all that have a nonzero flag\n        flags = flags or [1] * num_variable_qubits\n        control_qubits = [q for q, flag in zip(qr_variable, flags) if flag != 0]\n\n        # determine the qubits that need to be flipped (if a flag is > 0)\n        flip_qubits = [q for q, flag in zip(qr_variable, flags) if flag > 0]\n\n        # determine the number of ancillas\n        num_ancillas = MCXGate.get_num_ancilla_qubits(len(control_qubits), mode=mcx_mode)\n        if num_ancillas > 0:\n            qr_ancilla = AncillaRegister(num_ancillas, \"ancilla\")\n            circuit.add_register(qr_ancilla)\n        else:\n            qr_ancilla = AncillaRegister(0)\n\n        circuit.x(qr_result)\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n        circuit.mcx(control_qubits, qr_result[:], qr_ancilla[:], mode=mcx_mode)\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n\n        super().__init__(*circuit.qregs, name=\"or\")\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\nclass OrGate(Gate):\n    r\"\"\"A gate representing the logical OR operation on a number of qubits.\n\n    For the OR operation the state :math:`|1\\rangle` is interpreted as ``True``. The result\n    qubit is flipped, if the state of any variable qubit is ``True``. The OR is implemented using\n    a multi-open-controlled X gate (i.e. flips if the state is :math:`|0\\rangle`) and\n    applying an X gate on the result qubit.\n    Using a list of flags, qubits can be skipped or negated.\n\n    The OrGate gate without special flags:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import OrGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumCircuit(6)\n       circuit.append(OrGate(5), [0, 1, 2, 3, 4, 5])\n       _generate_circuit_library_visualization(circuit)\n\n    Using flags we can negate qubits or skip them. For instance, if we have 5 qubits and want to\n    return ``True`` if the first qubit is ``False`` or one of the last two are ``True`` we use the\n    flags ``[-1, 0, 0, 1, 1]``.\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import OrGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumCircuit(6)\n       circuit.append(OrGate(5, flags=[-1, 0, 0, 1, 1]), [0, 1, 2, 3, 4, 5])\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_variable_qubits: int,\n        flags: list[int] | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_variable_qubits: The qubits of which the AND is computed. The result will be written\n                into an additional result qubit.\n            flags: A list of +1/0/-1 marking negations or omissions of qubits.\n        \"\"\"\n        super().__init__(\"and\", num_variable_qubits + 1, [])\n        self.num_variable_qubits = num_variable_qubits\n        self.flags = flags\n\n    def _define(self):\n        # add registers\n        qr_variable = QuantumRegister(self.num_variable_qubits, name=\"variable\")\n        qr_result = QuantumRegister(1, name=\"result\")\n\n        # determine the control qubits: all that have a nonzero flag\n        flags = self.flags or [1] * self.num_variable_qubits\n        control_qubits = [q for q, flag in zip(qr_variable, flags) if flag != 0]\n\n        # determine the qubits that need to be flipped (if a flag is > 0)\n        flip_qubits = [q for q, flag in zip(qr_variable, flags) if flag > 0]\n\n        # create the definition circuit\n        circuit = QuantumCircuit(qr_variable, qr_result, name=\"or\")\n\n        circuit.x(qr_result)\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n        circuit.mcx(control_qubits, qr_result[:])\n        if len(flip_qubits) > 0:\n            circuit.x(flip_qubits)\n\n        self.definition = circuit\n\n    # pylint: disable=unused-argument\n    def inverse(self, annotated: bool = False):\n        r\"\"\"Return inverted OR gate (itself).\n\n        Args:\n            annotated: when set to ``True``, this is typically used to return an\n                :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n                :class:`.Gate`. However, for this class this argument is ignored as this gate\n                is self-inverse.\n\n        Returns:\n            OrGate: inverse gate (self-inverse).\n        \"\"\"\n        return OrGate(self.num_variable_qubits, self.flags)\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, OrGate)\n            and self.num_variable_qubits == other.num_variable_qubits\n            and self.flags == other.flags\n        )\n",
    "line_count": 207
  },
  {
    "filename": "quantum_xor.py",
    "path": "qiskit/circuit/library/boolean_logic/quantum_xor.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Bitwise XOR circuit and gate.\"\"\"\n\nfrom typing import Optional\n\nimport numpy as np\nfrom qiskit.circuit import QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass XOR(QuantumCircuit):\n    \"\"\"An n_qubit circuit for bitwise xor-ing the input with some integer ``amount``.\n\n    The ``amount`` is xor-ed in bitstring form with the input.\n\n    This circuit can also represent addition by ``amount`` over the finite field GF(2).\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=\"Instead, for xor-ing with a specified amount, use BitwiseXorGate,\"\n        \"and for xor-ing with a random amount, use random_bitwise_xor.\",\n        pending=True,\n    )\n    def __init__(\n        self,\n        num_qubits: int,\n        amount: Optional[int] = None,\n        seed: Optional[int] = None,\n    ) -> None:\n        \"\"\"Return a circuit implementing bitwise xor.\n\n        Args:\n            num_qubits: the width of circuit.\n            amount: the xor amount in decimal form.\n            seed: random seed in case a random xor is requested.\n\n        Raises:\n            CircuitError: if the xor bitstring exceeds available qubits.\n\n        Reference Circuit:\n            .. plot::\n               :alt: Diagram illustrating the previously described circuit.\n\n               from qiskit.circuit.library import XOR\n               from qiskit.visualization.library import _generate_circuit_library_visualization\n               circuit = XOR(5, seed=42)\n               _generate_circuit_library_visualization(circuit)\n        \"\"\"\n        circuit = QuantumCircuit(num_qubits, name=\"xor\")\n\n        if amount is not None:\n            if len(bin(amount)[2:]) > num_qubits:\n                raise CircuitError(\"Bits in 'amount' exceed circuit width\")\n        else:\n            rng = np.random.default_rng(seed)\n            amount = rng.integers(0, 2**num_qubits)\n\n        for i in range(num_qubits):\n            bit = amount & 1\n            amount = amount >> 1\n            if bit == 1:\n                circuit.x(i)\n\n        super().__init__(*circuit.qregs, name=\"xor\")\n        self.compose(circuit.to_gate(), qubits=self.qubits, inplace=True)\n\n\nclass BitwiseXorGate(Gate):\n    \"\"\"An n-qubit gate for bitwise xor-ing the input with some integer ``amount``.\n\n    The ``amount`` is xor-ed in bitstring form with the input.\n\n    This gate can also represent addition by ``amount`` over the finite field GF(2).\n\n    Reference Circuit:\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit import QuantumCircuit\n       from qiskit.circuit.library import BitwiseXorGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = QuantumCircuit(5)\n       circuit.append(BitwiseXorGate(5, amount=12), [0, 1, 2, 3, 4])\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits: int,\n        amount: int,\n    ) -> None:\n        \"\"\"\n        Args:\n            num_qubits: the width of circuit.\n            amount: the xor amount in decimal form.\n\n        Raises:\n            CircuitError: if the xor bitstring exceeds available qubits.\n        \"\"\"\n        if len(bin(amount)[2:]) > num_qubits:\n            raise CircuitError(\"Bits in 'amount' exceed circuit width\")\n\n        super().__init__(\"xor\", num_qubits, [])\n        self.amount = amount\n\n    def _define(self):\n        circuit = QuantumCircuit(self.num_qubits, name=\"xor\")\n        amount = self.amount\n        for i in range(self.num_qubits):\n            bit = amount & 1\n            amount = amount >> 1\n            if bit == 1:\n                circuit.x(i)\n\n        self.definition = circuit\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, BitwiseXorGate)\n            and self.num_qubits == other.num_qubits\n            and self.amount == other.amount\n        )\n\n    # pylint: disable=unused-argument\n    def inverse(self, annotated: bool = False):\n        r\"\"\"Return inverted BitwiseXorGate gate (itself).\n\n        Args:\n            annotated: when set to ``True``, this is typically used to return an\n                :class:`.AnnotatedOperation` with an inverse modifier set instead of a concrete\n                :class:`.Gate`. However, for this class this argument is ignored as this gate\n                is self-inverse.\n\n        Returns:\n            BitwiseXorGate: inverse gate (self-inverse).\n        \"\"\"\n        return BitwiseXorGate(self.num_qubits, self.amount)\n\n\ndef random_bitwise_xor(num_qubits: int, seed: int) -> BitwiseXorGate:\n    \"\"\"\n    Create a random BitwiseXorGate.\n\n    Args:\n        num_qubits: the width of circuit.\n        seed: random seed in case a random xor is requested.\n    \"\"\"\n\n    rng = np.random.default_rng(seed)\n    amount = rng.integers(0, 2**num_qubits)\n    return BitwiseXorGate(num_qubits, amount)\n",
    "line_count": 168
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/data_preparation/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nData-encoding circuits\n======================\n\nIn machine learning, pattern recognition and image processing, a **data-encoding circuit**\nstarts from an initial set of measured data and builds derived values (also known as\n**features**) intended to be informative and non-redundant, facilitating the subsequent\nlearning and generalization steps, and in some cases leading to better human\ninterpretations.\n\nA feature map is related to **dimensionality reduction**; it involves reducing the amount of\nresources required to describe a large set of data. When performing analysis of complex data,\none of the major problems stems from the number of variables involved. Analysis with a large\nnumber of variables generally requires a large amount of memory and computation power, and may\neven cause a classification algorithm to overfit to training samples and generalize poorly to new\nsamples.\n\nWhen the input data to an algorithm is too large to be processed and is suspected to be redundant\n(for example, the same measurement is provided in both pounds and kilograms), then it can be\ntransformed into a reduced set of features, named a **feature vector**.\n\nThe process of determining a subset of the initial features is called **feature selection**.\nThe selected features are expected to contain the relevant information from the input data,\nso that the desired task can be performed by using the reduced representation instead\nof the complete initial data.\n\n\"\"\"\n\nfrom .pauli_feature_map import PauliFeatureMap, pauli_feature_map, z_feature_map, zz_feature_map\nfrom ._z_feature_map import ZFeatureMap\nfrom ._zz_feature_map import ZZFeatureMap\nfrom .state_preparation import StatePreparation, UniformSuperpositionGate\nfrom .initializer import Initialize\n\n__all__ = [\n    \"pauli_feature_map\",\n    \"PauliFeatureMap\",\n    \"z_feature_map\",\n    \"ZFeatureMap\",\n    \"zz_feature_map\",\n    \"ZZFeatureMap\",\n    \"StatePreparation\",\n    \"UniformSuperpositionGate\",\n    \"Initialize\",\n]\n",
    "line_count": 58
  },
  {
    "filename": "_z_feature_map.py",
    "path": "qiskit/circuit/library/data_preparation/_z_feature_map.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Create a new first-order Pauli-Z expansion circuit.\"\"\"\n\nfrom typing import Callable, Optional\nimport numpy as np\nfrom qiskit.utils.deprecation import deprecate_func\n\nfrom .pauli_feature_map import PauliFeatureMap\n\n\nclass ZFeatureMap(PauliFeatureMap):\n    \"\"\"The first order Pauli Z-evolution circuit.\n\n    On 3 qubits and with 2 repetitions the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 U(2.0*x[1]) \u251c\u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This is a sub-class of :class:`~qiskit.circuit.library.PauliFeatureMap` where the Pauli\n    strings are fixed as `['Z']`. As a result the first order expansion will be a circuit without\n    entangling gates.\n\n    Examples:\n\n        >>> prep = ZFeatureMap(3, reps=3, insert_barriers=True)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2510 \u2591 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[0]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[1]) \u251c\n             \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2524 \u2591 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\u2500\u2591\u2500\u2524 H \u251c\u2500\u2591\u2500\u2524 P(2.0*x[2]) \u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2518 \u2591 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> data_map = lambda x: x[0]*x[0] + 1  # note: input is an array\n        >>> prep = ZFeatureMap(3, reps=1, data_map_func=data_map)\n        >>> print(prep.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]**2 + 2.0) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]**2 + 2.0) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        >>> from qiskit.circuit.library import TwoLocal\n        >>> ry = TwoLocal(3, \"ry\", \"cz\", reps=1)\n        >>> classifier = ZFeatureMap(3, reps=1) + ry\n        >>> print(classifier.decompose())\n             \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2524 RY(\u03b8[0]) \u251c\u2500\u25a0\u2500\u2500\u25a0\u2500\u2524 RY(\u03b8[3]) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 RY(\u03b8[1]) \u251c\u2500\u25a0\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[4]) \u251c\n             \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502      \u2502      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        q_2: \u2524 H \u251c\u2524 P(2.0*x[2]) \u251c\u2524 RY(\u03b8[2]) \u251c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2524 RY(\u03b8[5]) \u251c\n             \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=(\n            \"Use the z_feature_map function as a replacement. Note that this will no longer \"\n            \"return a BlueprintCircuit, but just a plain QuantumCircuit.\"\n        ),\n        pending=True,\n    )\n    def __init__(\n        self,\n        feature_dimension: int,\n        reps: int = 2,\n        data_map_func: Optional[Callable[[np.ndarray], float]] = None,\n        parameter_prefix: str = \"x\",\n        insert_barriers: bool = False,\n        name: str = \"ZFeatureMap\",\n    ) -> None:\n        \"\"\"Create a new first-order Pauli-Z expansion circuit.\n\n        Args:\n            feature_dimension: The number of features\n            reps: The number of repeated circuits. Defaults to 2, has a minimum value of 1.\n            data_map_func: A mapping function for data x which can be supplied to override the\n                default mapping from :meth:`self_product`.\n            parameter_prefix: The prefix used if default parameters are generated.\n            insert_barriers: If True, barriers are inserted in between the evolution instructions\n                and hadamard layers.\n\n        \"\"\"\n        super().__init__(\n            feature_dimension=feature_dimension,\n            paulis=[\"Z\"],\n            reps=reps,\n            data_map_func=data_map_func,\n            parameter_prefix=parameter_prefix,\n            insert_barriers=insert_barriers,\n            name=name,\n        )\n",
    "line_count": 116
  },
  {
    "filename": "_zz_feature_map.py",
    "path": "qiskit/circuit/library/data_preparation/_zz_feature_map.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Second-order Pauli-Z expansion circuit.\"\"\"\n\nfrom typing import Callable, List, Union, Optional, Dict, Tuple\nimport numpy as np\nfrom qiskit.utils.deprecation import deprecate_func\nfrom .pauli_feature_map import PauliFeatureMap\n\n\nclass ZZFeatureMap(PauliFeatureMap):\n    r\"\"\"Second-order Pauli-Z evolution circuit.\n\n    For 3 qubits and 1 repetition and linear entanglement the circuit is represented by:\n\n    .. code-block:: text\n\n        \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[0])) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[1])) \u251c\u2524 X \u251c\u2524 P(2.0*\u03c6(x[0],x[1])) \u251c\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n        \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n        \u2524 H \u251c\u2524 P(2.0*\u03c6(x[2])) \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2524 P(2.0*\u03c6(x[1],x[2])) \u251c\u2524 X \u251c\n        \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                 \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    where :math:`\\varphi` is a classical non-linear function, which defaults to :math:`\\varphi(x) = x`\n    if and :math:`\\varphi(x,y) = (\\pi - x)(\\pi - y)`.\n\n    Examples:\n\n    .. code-block::\n\n         from qiskit.circuit.library import ZZFeatureMap\n         prep = ZZFeatureMap(2, reps=1)\n         print(prep.decompose())\n\n    .. code-block:: text\n\n              \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         q_0: \u2524 H \u251c\u2524 P(2.0*x[0]) \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n              \u251c\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2500\u2534\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2534\u2500\u2510\n         q_1: \u2524 H \u251c\u2524 P(2.0*x[1]) \u251c\u2524 X \u251c\u2524 P(2.0*(pi - x[0])*(pi - x[1])) \u251c\u2524 X \u251c\n              \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2518\n\n    .. code-block::\n\n         from qiskit.circuit.library import EfficientSU2\n         classifier = ZZFeatureMap(3).compose(EfficientSU2(3))\n         classifier.num_parameters\n\n    .. code-block:: text\n\n         27\n\n    .. code-block::\n\n         classifier.parameters  # 'x' for the data preparation, '\u03b8' for the SU2 parameters\n\n    .. code-block:: text\n\n         ParameterView([\n             ParameterVectorElement(x[0]), ParameterVectorElement(x[1]),\n             ParameterVectorElement(x[2]), ParameterVectorElement(\u03b8[0]),\n             ParameterVectorElement(\u03b8[1]), ParameterVectorElement(\u03b8[2]),\n             ParameterVectorElement(\u03b8[3]), ParameterVectorElement(\u03b8[4]),\n             ParameterVectorElement(\u03b8[5]), ParameterVectorElement(\u03b8[6]),\n             ParameterVectorElement(\u03b8[7]), ParameterVectorElement(\u03b8[8]),\n             ParameterVectorElement(\u03b8[9]), ParameterVectorElement(\u03b8[10]),\n             ParameterVectorElement(\u03b8[11]), ParameterVectorElement(\u03b8[12]),\n             ParameterVectorElement(\u03b8[13]), ParameterVectorElement(\u03b8[14]),\n             ParameterVectorElement(\u03b8[15]), ParameterVectorElement(\u03b8[16]),\n             ParameterVectorElement(\u03b8[17]), ParameterVectorElement(\u03b8[18]),\n             ParameterVectorElement(\u03b8[19]), ParameterVectorElement(\u03b8[20]),\n             ParameterVectorElement(\u03b8[21]), ParameterVectorElement(\u03b8[22]),\n             ParameterVectorElement(\u03b8[23])\n         ])\n\n    .. code-block::\n\n         classifier.count_ops()\n\n    .. code-block:: text\n\n        OrderedDict([('ZZFeatureMap', 1), ('EfficientSU2', 1)])\n\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.3\",\n        additional_msg=(\n            \"Use the z_feature_map function as a replacement. Note that this will no longer \"\n            \"return a BlueprintCircuit, but just a plain QuantumCircuit.\"\n        ),\n        pending=True,\n    )\n    def __init__(\n        self,\n        feature_dimension: int,\n        reps: int = 2,\n        entanglement: Union[\n            str,\n            Dict[int, List[Tuple[int]]],\n            Callable[[int], Union[str, Dict[int, List[Tuple[int]]]]],\n        ] = \"full\",\n        data_map_func: Optional[Callable[[np.ndarray], float]] = None,\n        parameter_prefix: str = \"x\",\n        insert_barriers: bool = False,\n        name: str = \"ZZFeatureMap\",\n    ) -> None:\n        \"\"\"Create a new second-order Pauli-Z expansion.\n\n        Args:\n            feature_dimension: Number of features.\n            reps: The number of repeated circuits, has a min. value of 1.\n            entanglement: Specifies the entanglement structure. Refer to\n                :class:`~qiskit.circuit.library.PauliFeatureMap` for detail.\n            data_map_func: A mapping function for data x.\n            parameter_prefix: The prefix used if default parameters are generated.\n            insert_barriers: If True, barriers are inserted in between the evolution instructions\n                and hadamard layers.\n\n        Raises:\n            ValueError: If the feature dimension is smaller than 2.\n        \"\"\"\n        if feature_dimension < 2:\n            raise ValueError(\n                \"The ZZFeatureMap contains 2-local interactions and cannot be \"\n                f\"defined for less than 2 qubits. You provided {feature_dimension}.\"\n            )\n\n        super().__init__(\n            feature_dimension=feature_dimension,\n            reps=reps,\n            entanglement=entanglement,\n            paulis=[\"Z\", \"ZZ\"],\n            data_map_func=data_map_func,\n            parameter_prefix=parameter_prefix,\n            insert_barriers=insert_barriers,\n            name=name,\n        )\n",
    "line_count": 151
  },
  {
    "filename": "initializer.py",
    "path": "qiskit/circuit/library/data_preparation/initializer.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"\nInitialize qubit registers to desired arbitrary state.\n\"\"\"\n\nfrom __future__ import annotations\nfrom collections.abc import Sequence\nimport typing\n\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.instruction import Instruction\nfrom qiskit.circuit.library.generalized_gates import Isometry\nfrom .state_preparation import StatePreparation\n\nif typing.TYPE_CHECKING:\n    from qiskit.quantum_info.states.statevector import Statevector\n\n_EPS = 1e-10  # global variable used to chop very small numbers to zero\n\n\nclass Initialize(Instruction):\n    \"\"\"Complex amplitude initialization.\n\n    Class that initializes some flexible collection of qubit registers, implemented by calling\n    the :class:`~.library.StatePreparation` class.\n    Note that ``Initialize`` is an :class:`~.circuit.Instruction` and not a :class:`.Gate` since it\n    contains a reset instruction, which is not unitary.\n\n    The initial state is prepared based on the :class:`~.library.Isometry` synthesis described in [1].\n\n    References:\n        1. Iten et al., Quantum circuits for isometries (2016).\n           `Phys. Rev. A 93, 032318\n           <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.032318>`__.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        params: Statevector | Sequence[complex] | str | int,\n        num_qubits: int | None = None,\n        normalize: bool = False,\n    ) -> None:\n        r\"\"\"\n        Args:\n            params: The state to initialize to, can be either of the following.\n\n                * Statevector or vector of complex amplitudes to initialize to.\n                * Labels of basis states of the Pauli eigenstates Z, X, Y. See\n                  :meth:`.Statevector.from_label`. Notice the order of the labels is reversed with\n                  respect to the qubit index to be applied to. Example label '01' initializes the\n                  qubit zero to :math:`|1\\rangle` and the qubit one to :math:`|0\\rangle`.\n                * An integer that is used as a bitmap indicating which qubits to initialize to\n                  :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit\n                  2 to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n\n            num_qubits: This parameter is only used if params is an int. Indicates the total\n                number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n                and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n                and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n            normalize: Whether to normalize an input array to a unit vector.\n        \"\"\"\n        self._stateprep = StatePreparation(params, num_qubits, normalize=normalize)\n\n        super().__init__(\"initialize\", self._stateprep.num_qubits, 0, self._stateprep.params)\n\n    def _define(self):\n        q = QuantumRegister(self.num_qubits, \"q\")\n        initialize_circuit = QuantumCircuit(q, name=\"init_def\")\n        initialize_circuit.reset(q)\n        initialize_circuit.append(self._stateprep, q)\n        self.definition = initialize_circuit\n\n    def gates_to_uncompute(self) -> QuantumCircuit:\n        \"\"\"Call to create a circuit with gates that take the desired vector to zero.\n\n        Returns:\n            QuantumCircuit: circuit to take ``self.params`` vector to :math:`|{00\\\\ldots0}\\\\rangle`\n        \"\"\"\n\n        isom = Isometry(self.params, 0, 0)\n        return isom._gates_to_uncompute()\n\n    @property\n    def params(self):\n        \"\"\"Return initialize params.\"\"\"\n        return self._stateprep.params\n\n    @params.setter\n    def params(self, parameters: Statevector | Sequence[complex] | str | int) -> None:\n        \"\"\"Set initialize params.\"\"\"\n        self._stateprep.params = parameters\n\n    def broadcast_arguments(self, qargs, cargs):\n        return self._stateprep.broadcast_arguments(qargs, cargs)\n",
    "line_count": 108
  },
  {
    "filename": "state_preparation.py",
    "path": "qiskit/circuit/library/data_preparation/state_preparation.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\"\"\"Prepare a quantum state from the state where all qubits are 0.\"\"\"\n\nfrom typing import Union, Optional\n\nimport math\nimport numpy as np\n\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.library.standard_gates.x import XGate\nfrom qiskit.circuit.library.standard_gates.h import HGate\nfrom qiskit.circuit.library.standard_gates.s import SGate, SdgGate\nfrom qiskit.circuit.library.generalized_gates import Isometry\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.quantum_info.states.statevector import (\n    Statevector,\n)  # pylint: disable=cyclic-import\n\n_EPS = 1e-10  # global variable used to chop very small numbers to zero\n\n\nclass StatePreparation(Gate):\n    \"\"\"Complex amplitude state preparation.\n\n    Class that implements the (complex amplitude) state preparation of some\n    flexible collection of qubit registers.\n    \"\"\"\n\n    def __init__(\n        self,\n        params: Union[str, list, int, Statevector],\n        num_qubits: Optional[int] = None,\n        inverse: bool = False,\n        label: Optional[str] = None,\n        normalize: bool = False,\n    ):\n        r\"\"\"\n        Args:\n            params:\n                * Statevector: Statevector to initialize to.\n                * list: vector of complex amplitudes to initialize to.\n                * string: labels of basis states of the Pauli eigenstates Z, X, Y. See\n                  :meth:`.Statevector.from_label`.\n                  Notice the order of the labels is reversed with respect to the qubit index to\n                  be applied to. Example label '01' initializes the qubit zero to :math:`|1\\rangle`\n                  and the qubit one to :math:`|0\\rangle`.\n                * int: an integer that is used as a bitmap indicating which qubits to initialize\n                  to :math:`|1\\rangle`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n                  to :math:`|1\\rangle` and qubit 1 to :math:`|0\\rangle`.\n            num_qubits: This parameter is only used if params is an int. Indicates the total\n                number of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n                and params is 3. This allows qubits 0 and 1 to be initialized to :math:`|1\\rangle`\n                and the remaining 3 qubits to be initialized to :math:`|0\\rangle`.\n            inverse: if True, the inverse state is constructed.\n            label: An optional label for the gate\n            normalize (bool): Whether to normalize an input array to a unit vector.\n\n        Raises:\n            QiskitError: ``num_qubits`` parameter used when ``params`` is not an integer\n\n        When a Statevector argument is passed the state is prepared based on the\n        :class:`~.library.Isometry` synthesis described in [1].\n\n        References:\n            1. Iten et al., Quantum circuits for isometries (2016).\n               `Phys. Rev. A 93, 032318\n               <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.032318>`__.\n\n        \"\"\"\n        self._params_arg = params\n        self._inverse = inverse\n        self._name = \"state_preparation_dg\" if self._inverse else \"state_preparation\"\n\n        if label is None:\n            self._label = \"State Preparation Dg\" if self._inverse else \"State Preparation\"\n        else:\n            self._label = f\"{label} Dg\" if self._inverse else label\n\n        if isinstance(params, Statevector):\n            params = params.data\n\n        if not isinstance(params, int) and num_qubits is not None:\n            raise QiskitError(\n                \"The num_qubits parameter to StatePreparation should only be\"\n                \" used when params is an integer\"\n            )\n        self._from_label = isinstance(params, str)\n        self._from_int = isinstance(params, int)\n\n        # if initialized from a vector, check that the parameters are normalized\n        if not self._from_label and not self._from_int:\n            norm = np.linalg.norm(params)\n            if normalize:\n                params = np.array(params, dtype=np.complex128) / norm\n            elif not math.isclose(norm, 1.0, abs_tol=_EPS):\n                raise QiskitError(f\"Sum of amplitudes-squared is not 1, but {norm}.\")\n\n        num_qubits = self._get_num_qubits(num_qubits, params)\n        params = [params] if isinstance(params, int) else params\n\n        super().__init__(self._name, num_qubits, params, label=self._label)\n\n    def _define(self):\n        if self._from_label:\n            self.definition = self._define_from_label()\n        elif self._from_int:\n            self.definition = self._define_from_int()\n        else:\n            self.definition = self._define_synthesis_isom()\n\n    def _define_from_label(self):\n        q = QuantumRegister(self.num_qubits, \"q\")\n        initialize_circuit = QuantumCircuit(q, name=\"init_def\")\n\n        for qubit, param in enumerate(reversed(self.params)):\n            if param == \"1\":\n                initialize_circuit.append(XGate(), [q[qubit]])\n            elif param == \"+\":\n                initialize_circuit.append(HGate(), [q[qubit]])\n            elif param == \"-\":\n                initialize_circuit.append(XGate(), [q[qubit]])\n                initialize_circuit.append(HGate(), [q[qubit]])\n            elif param == \"r\":  # |+i>\n                initialize_circuit.append(HGate(), [q[qubit]])\n                initialize_circuit.append(SGate(), [q[qubit]])\n            elif param == \"l\":  # |-i>\n                initialize_circuit.append(HGate(), [q[qubit]])\n                initialize_circuit.append(SdgGate(), [q[qubit]])\n\n        if self._inverse:\n            initialize_circuit = initialize_circuit.inverse()\n\n        return initialize_circuit\n\n    def _define_from_int(self):\n        q = QuantumRegister(self.num_qubits, \"q\")\n        initialize_circuit = QuantumCircuit(q, name=\"init_def\")\n\n        # Convert to int since QuantumCircuit converted to complex\n        # and make a bit string and reverse it\n        intstr = f\"{int(np.real(self.params[0])):0{self.num_qubits}b}\"[::-1]\n\n        # Raise if number of bits is greater than num_qubits\n        if len(intstr) > self.num_qubits:\n            raise QiskitError(\n                f\"StatePreparation integer has {len(intstr)} bits, but this exceeds the\"\n                f\" number of qubits in the circuit, {self.num_qubits}.\"\n            )\n\n        for qubit, bit in enumerate(intstr):\n            if bit == \"1\":\n                initialize_circuit.append(XGate(), [q[qubit]])\n\n        # note: X is it's own inverse, so even if self._inverse is True,\n        # we don't need to invert anything\n        return initialize_circuit\n\n    def _define_synthesis_isom(self):\n        \"\"\"Calculate a subcircuit that implements this initialization via isometry\"\"\"\n        q = QuantumRegister(self.num_qubits, \"q\")\n        initialize_circuit = QuantumCircuit(q, name=\"init_def\")\n\n        isom = Isometry(self.params, 0, 0)\n        initialize_circuit.compose(isom.definition, copy=False, inplace=True)\n\n        # invert the circuit to create the desired vector from zero (assuming\n        # the qubits are in the zero state)\n        if self._inverse is True:\n            return initialize_circuit.inverse()\n\n        return initialize_circuit\n\n    def _get_num_qubits(self, num_qubits, params):\n        \"\"\"Get number of qubits needed for state preparation\"\"\"\n        if isinstance(params, str):\n            num_qubits = len(params)\n        elif isinstance(params, int):\n            if num_qubits is None:\n                num_qubits = int(math.log2(params)) + 1\n        else:\n            num_qubits = math.log2(len(params))\n\n            # Check if param is a power of 2\n            if num_qubits == 0 or not num_qubits.is_integer():\n                raise QiskitError(\"Desired statevector length not a positive power of 2.\")\n\n            num_qubits = int(num_qubits)\n        return num_qubits\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Return inverted StatePreparation\"\"\"\n\n        label = (\n            None if self._label in (\"State Preparation\", \"State Preparation Dg\") else self._label\n        )\n\n        return StatePreparation(self._params_arg, inverse=not self._inverse, label=label)\n\n    def broadcast_arguments(self, qargs, cargs):\n        flat_qargs = [qarg for sublist in qargs for qarg in sublist]\n\n        if self.num_qubits != len(flat_qargs):\n            raise QiskitError(\n                f\"StatePreparation parameter vector has {2**self.num_qubits}\"\n                f\" elements, therefore expects {self.num_qubits} \"\n                f\"qubits. However, {len(flat_qargs)} were provided.\"\n            )\n        yield flat_qargs, []\n\n    def validate_parameter(self, parameter):\n        \"\"\"StatePreparation instruction parameter can be str, int, float, and complex.\"\"\"\n\n        # StatePreparation instruction parameter can be str\n        if isinstance(parameter, str):\n            if parameter in [\"0\", \"1\", \"+\", \"-\", \"l\", \"r\"]:\n                return parameter\n            raise CircuitError(\n                f\"invalid param label {type(parameter)} for instruction {self.name}. Label should be \"\n                \"0, 1, +, -, l, or r \"\n            )\n\n        # StatePreparation instruction parameter can be int, float, and complex.\n        if isinstance(parameter, (int, float, complex)):\n            return complex(parameter)\n        elif isinstance(parameter, np.number):\n            return complex(parameter.item())\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} for instruction  {self.name}\")\n\n    def _return_repeat(self, exponent: float) -> \"Gate\":\n        return Gate(name=f\"{self.name}*{exponent}\", num_qubits=self.num_qubits, params=[])\n\n\nclass UniformSuperpositionGate(Gate):\n    r\"\"\"Implements a uniform superposition state.\n\n    This gate is used to create the uniform superposition state\n    :math:`\\frac{1}{\\sqrt{M}} \\sum_{j=0}^{M-1}  |j\\rangle` when it acts on an input\n    state :math:`|0...0\\rangle`. Note, that `M` is not required to be\n    a power of 2, in which case the uniform superposition could be\n    prepared by a single layer of Hadamard gates.\n\n    .. note::\n\n        This class uses the Shukla-Vedula algorithm [1], which only needs\n        :math:`O(\\log_2 (M))` qubits and :math:`O(\\log_2 (M))` gates,\n        to prepare the superposition.\n\n    **References:**\n    [1]: A. Shukla and P. Vedula (2024), An efficient quantum algorithm for preparation\n    of uniform quantum superposition states, `Quantum Inf Process 23, 38\n    <https://link.springer.com/article/10.1007/s11128-024-04258-4>`_.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_superpos_states: int = 2,\n        num_qubits: Optional[int] = None,\n    ):\n        r\"\"\"\n        Args:\n            num_superpos_states (int):\n                A positive integer M = num_superpos_states (> 1) representing the number of computational\n                basis states with an amplitude of 1/sqrt(M) in the uniform superposition\n                state (:math:`\\frac{1}{\\sqrt{M}} \\sum_{j=0}^{M-1}  |j\\rangle`, where\n                :math:`1< M <= 2^n`). Note that the remaining (:math:`2^n - M`) computational basis\n                states have zero amplitudes. Here M need not be an integer power of 2.\n\n            num_qubits (int):\n                A positive integer representing the number of qubits used.  If num_qubits is None\n                or is not specified, then num_qubits is set to ceil(log2(num_superpos_states)).\n\n        Raises:\n            ValueError: num_qubits must be an integer greater than or equal to log2(num_superpos_states).\n\n        \"\"\"\n        if num_superpos_states <= 1:\n            raise ValueError(\"num_superpos_states must be a positive integer greater than 1.\")\n        if num_qubits is None:\n            num_qubits = int(math.ceil(math.log2(num_superpos_states)))\n        else:\n            if not (isinstance(num_qubits, int) and (num_qubits >= math.log2(num_superpos_states))):\n                raise ValueError(\n                    \"num_qubits must be an integer greater than or equal to log2(num_superpos_states).\"\n                )\n        super().__init__(\"USup\", num_qubits, [num_superpos_states])\n\n    def _define(self):\n\n        qc = QuantumCircuit(self._num_qubits)\n\n        num_superpos_states = self.params[0]\n\n        if (\n            num_superpos_states & (num_superpos_states - 1)\n        ) == 0:  # if num_superpos_states is an integer power of 2\n            m = int(math.log2(num_superpos_states))\n            qc.h(range(m))\n            self.definition = qc\n            return\n\n        n_value = [int(x) for x in reversed(np.binary_repr(num_superpos_states))]\n        k = len(n_value)\n        l_value = [index for (index, item) in enumerate(n_value) if item == 1]  # Locations of '1's\n\n        qc.x(l_value[1:k])\n        m_current_value = 2 ** l_value[0]\n        theta = -2 * np.arccos(np.sqrt(m_current_value / num_superpos_states))\n\n        if l_value[0] > 0:  # if num_superpos_states is even\n            qc.h(range(l_value[0]))\n        qc.ry(theta, l_value[1])\n        qc.ch(l_value[1], range(l_value[0], l_value[1]), ctrl_state=\"0\")\n\n        for m in range(1, len(l_value) - 1):\n            theta = -2 * np.arccos(\n                np.sqrt(2 ** l_value[m] / (num_superpos_states - m_current_value))\n            )\n            qc.cry(theta, l_value[m], l_value[m + 1], ctrl_state=\"0\")\n            qc.ch(l_value[m + 1], range(l_value[m], l_value[m + 1]), ctrl_state=\"0\")\n            m_current_value = m_current_value + 2 ** l_value[m]\n\n        self.definition = qc\n",
    "line_count": 337
  },
  {
    "filename": "__init__.py",
    "path": "qiskit/circuit/library/generalized_gates/__init__.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"The circuit library module on generalized gates.\"\"\"\n\nfrom .diagonal import Diagonal, DiagonalGate\nfrom .permutation import Permutation, PermutationGate\nfrom .mcmt import MCMT, MCMTVChain, MCMTGate\nfrom .gms import GMS, MSGate\nfrom .gr import GR, GRX, GRY, GRZ\nfrom .pauli import PauliGate\nfrom .rv import RVGate\nfrom .linear_function import LinearFunction\nfrom .isometry import Isometry\nfrom .uc import UCGate\nfrom .uc_pauli_rot import UCPauliRotGate\nfrom .ucrx import UCRXGate\nfrom .ucry import UCRYGate\nfrom .ucrz import UCRZGate\nfrom .unitary import UnitaryGate\nfrom .mcg_up_to_diagonal import MCGupDiag\n",
    "line_count": 31
  },
  {
    "filename": "diagonal.py",
    "path": "qiskit/circuit/library/generalized_gates/diagonal.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"Diagonal matrix circuit.\"\"\"\n\nfrom __future__ import annotations\nfrom collections.abc import Sequence\n\nimport cmath\nimport math\nimport numpy as np\n\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit.annotated_operation import AnnotatedOperation, InverseModifier\nfrom qiskit.utils.deprecation import deprecate_func\n\nfrom .ucrz import UCRZGate\n\n_EPS = 1e-10\n\n\nclass Diagonal(QuantumCircuit):\n    \"\"\"Circuit implementing a diagonal transformation.\"\"\"\n\n    @deprecate_func(since=\"1.3\", additional_msg=\"Use DiagonalGate instead.\", pending=True)\n    def __init__(self, diag: Sequence[complex]) -> None:\n        r\"\"\"\n        Args:\n            diag: List of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).\n\n        Raises:\n            CircuitError: if the list of the diagonal entries or the qubit list is in bad format;\n                if the number of diagonal entries is not :math:`2^k`, where :math:`k` denotes the\n                number of qubits.\n        \"\"\"\n        DiagonalGate._check_input(diag)\n        num_qubits = int(math.log2(len(diag)))\n\n        super().__init__(num_qubits, name=\"Diagonal\")\n        self.append(DiagonalGate(diag), self.qubits)\n\n\nclass DiagonalGate(Gate):\n    r\"\"\"A generic diagonal quantum gate.\n\n    Matrix form:\n\n    .. math::\n        \\text{DiagonalGate}\\ q_0, q_1, .., q_{n-1} =\n            \\begin{pmatrix}\n                D[0]    & 0         & \\dots     & 0 \\\\\n                0       & D[1]      & \\dots     & 0 \\\\\n                \\vdots  & \\vdots    & \\ddots    & 0 \\\\\n                0       & 0         & \\dots     & D[n-1]\n            \\end{pmatrix}\n\n    Diagonal gates are useful as representations of Boolean functions,\n    as they can map from :math:`\\{0,1\\}^{2^n}` to :math:`\\{0,1\\}^{2^n}` space. For example a phase\n    oracle can be seen as a diagonal gate with :math:`\\{1, -1\\}` on the diagonals. Such\n    an oracle will induce a :math:`+1` or :math`-1` phase on the amplitude of any corresponding\n    basis state.\n\n    Diagonal gates appear in many classically hard oracular problems such as\n    Forrelation or Hidden Shift circuits.\n\n    Diagonal gates are represented and simulated more efficiently than a dense\n    :math:`2^n \\times 2^n` unitary matrix.\n\n    The reference implementation is via the method described in\n    Theorem 7 of [1]. The code is based on Emanuel Malvetti's semester thesis\n    at ETH in 2018, supervised by Raban Iten and Prof. Renato Renner.\n\n    **Reference:**\n\n    [1] Shende et al., Synthesis of Quantum Logic Circuits, 2009\n    `arXiv:0406176 <https://arxiv.org/pdf/quant-ph/0406176.pdf>`_\n    \"\"\"\n\n    def __init__(self, diag: Sequence[complex]) -> None:\n        r\"\"\"\n        Args:\n            diag: list of the :math:`2^k` diagonal entries (for a diagonal gate on :math:`k` qubits).\n        \"\"\"\n        self._check_input(diag)\n        num_qubits = int(math.log2(len(diag)))\n\n        super().__init__(\"diagonal\", num_qubits, diag)\n\n    def _define(self):\n        # Since the diagonal is a unitary, all its entries have absolute value\n        # one and the diagonal is fully specified by the phases of its entries.\n        diag_phases = [cmath.phase(z) for z in self.params]\n        n = len(diag_phases)\n        circuit = QuantumCircuit(self.num_qubits)\n\n        while n >= 2:\n            angles_rz = []\n            for i in range(0, n, 2):\n                diag_phases[i // 2], rz_angle = _extract_rz(diag_phases[i], diag_phases[i + 1])\n                angles_rz.append(rz_angle)\n            num_act_qubits = int(math.log2(n))\n            ctrl_qubits = list(range(self.num_qubits - num_act_qubits + 1, self.num_qubits))\n            target_qubit = self.num_qubits - num_act_qubits\n\n            ucrz = UCRZGate(angles_rz)\n            circuit.append(ucrz, [target_qubit] + ctrl_qubits)\n\n            n //= 2\n        circuit.global_phase += diag_phases[0]\n\n        self.definition = circuit\n\n    def validate_parameter(self, parameter):\n        \"\"\"Diagonal Gate parameter should accept complex\n        (in addition to the Gate parameter types) and always return build-in complex.\"\"\"\n        if isinstance(parameter, complex):\n            return complex(parameter)\n        else:\n            return complex(super().validate_parameter(parameter))\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Return the inverse of the diagonal gate.\"\"\"\n        if annotated:\n            return AnnotatedOperation(self.copy(), InverseModifier)\n\n        return DiagonalGate([np.conj(entry) for entry in self.params])\n\n    @staticmethod\n    def _check_input(diag):\n        \"\"\"Check if ``diag`` is in valid format.\"\"\"\n        if not isinstance(diag, (list, np.ndarray)):\n            raise CircuitError(\"Diagonal entries must be in a list or numpy array.\")\n        num_qubits = math.log2(len(diag))\n        if num_qubits < 1 or not num_qubits.is_integer():\n            raise CircuitError(\"The number of diagonal entries is not a positive power of 2.\")\n        if not np.allclose(np.abs(diag), 1, atol=_EPS):\n            raise CircuitError(\"A diagonal element does not have absolute value one.\")\n\n\ndef _extract_rz(phi1, phi2):\n    \"\"\"\n    Extract a Rz rotation (angle given by first output) such that exp(j*phase)*Rz(z_angle)\n    is equal to the diagonal matrix with entires exp(1j*ph1) and exp(1j*ph2).\n    \"\"\"\n    phase = (phi1 + phi2) / 2.0\n    z_angle = phi2 - phi1\n    return phase, z_angle\n",
    "line_count": 160
  },
  {
    "filename": "gms.py",
    "path": "qiskit/circuit/library/generalized_gates/gms.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\n\"\"\"\nGlobal M\u00f8lmer\u2013S\u00f8rensen gate.\n\"\"\"\n\nfrom __future__ import annotations\nfrom collections.abc import Sequence\n\nimport numpy as np\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.parameterexpression import ParameterValueType\nfrom qiskit.circuit.library.standard_gates import RXXGate\nfrom qiskit.circuit.gate import Gate\nfrom qiskit.utils.deprecation import deprecate_func\n\n\nclass GMS(QuantumCircuit):\n    r\"\"\"Global M\u00f8lmer\u2013S\u00f8rensen gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240          \u251c\n             \u2502           \u2502\n        q_1: \u25241   GMS    \u251c\n             \u2502           \u2502\n        q_2: \u25242          \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GMS\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GMS(num_qubits=3, theta=[[0, np.pi/4, np.pi/8],\n                                          [0, 0, np.pi/2],\n                                          [0, 0, 0]])\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    The M\u00f8lmer\u2013S\u00f8rensen gate is native to ion-trap systems. The global MS\n    can be applied to multiple ions to entangle multiple qubits simultaneously [1].\n\n    In the two-qubit case, this is equivalent to an XX(theta) interaction,\n    and is thus reduced to the RXXGate. The global MS gate is a sum of XX\n    interactions on all pairs [2].\n\n    .. math::\n\n        GMS(\\chi_{12}, \\chi_{13}, ..., \\chi_{n-1 n}) =\n        exp(-i \\sum_{i=1}^{n} \\sum_{j=i+1}^{n} X{\\otimes}X \\frac{\\chi_{ij}}{2})\n\n    **References:**\n\n    [1] S\u00f8rensen, A. and M\u00f8lmer, K., Multi-particle entanglement of hot trapped ions.\n    Physical Review Letters. 82 (9): 1835\u20131838.\n    `arXiv:9810040 <https://arxiv.org/abs/quant-ph/9810040>`_\n\n    [2] Maslov, D. and Nam, Y., Use of global interactions in efficient quantum circuit\n    constructions. New Journal of Physics, 20(3), p.033018.\n    `arXiv:1707.06356 <https://arxiv.org/abs/1707.06356>`_\n    \"\"\"\n\n    @deprecate_func(since=\"1.3\", additional_msg=\"Use the MSGate instead.\", pending=True)\n    def __init__(self, num_qubits: int, theta: list[list[float]] | np.ndarray) -> None:\n        \"\"\"Create a new Global M\u00f8lmer\u2013S\u00f8rensen (GMS) gate.\n\n        Args:\n            num_qubits: width of gate.\n            theta: a num_qubits x num_qubits symmetric matrix of\n                interaction angles for each qubit pair. The upper\n                triangle is considered.\n        \"\"\"\n        super().__init__(num_qubits, name=\"gms\")\n        if not isinstance(theta, list):\n            theta = [theta] * int((num_qubits**2 - 1) / 2)\n        gms = QuantumCircuit(num_qubits, name=\"gms\")\n        for i in range(self.num_qubits):\n            for j in range(i + 1, self.num_qubits):\n                gms.append(RXXGate(theta[i][j]), [i, j])\n        self.append(gms.to_gate(), self.qubits)\n\n\nclass MSGate(Gate):\n    r\"\"\"The M\u00f8lmer\u2013S\u00f8rensen gate.\n\n    The M\u00f8lmer\u2013S\u00f8rensen gate is native to ion-trap systems. The global MS\n    can be applied to multiple ions to entangle multiple qubits simultaneously [1].\n\n    In the two-qubit case, this is equivalent to an XX interaction,\n    and is thus reduced to the :class:`.RXXGate`. The global MS gate is a sum of XX\n    interactions on all pairs [2].\n\n    .. math::\n\n        MS(\\chi_{12}, \\chi_{13}, ..., \\chi_{n-1 n}) =\n        exp(-i \\sum_{i=1}^{n} \\sum_{j=i+1}^{n} X{\\otimes}X \\frac{\\chi_{ij}}{2})\n\n    Example::\n\n        import numpy as np\n        from qiskit.circuit.library import MSGate\n        from qiskit.quantum_info import Operator\n\n        gate = MSGate(num_qubits=3, theta=[[0, np.pi/4, np.pi/8],\n                                           [0, 0, np.pi/2],\n                                           [0, 0, 0]])\n        print(Operator(gate))\n\n\n    **References:**\n\n    [1] S\u00f8rensen, A. and M\u00f8lmer, K., Multi-particle entanglement of hot trapped ions.\n    Physical Review Letters. 82 (9): 1835\u20131838.\n    `arXiv:9810040 <https://arxiv.org/abs/quant-ph/9810040>`_\n\n    [2] Maslov, D. and Nam, Y., Use of global interactions in efficient quantum circuit\n    constructions. New Journal of Physics, 20(3), p.033018.\n    `arXiv:1707.06356 <https://arxiv.org/abs/1707.06356>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        num_qubits: int,\n        theta: ParameterValueType | Sequence[Sequence[ParameterValueType]],\n        label: str | None = None,\n    ):\n        \"\"\"\n        Args:\n            num_qubits: The number of qubits the MS gate acts on.\n            theta: The XX rotation angles. If a single value, the same angle is used on all\n                interactions. Alternatively an upper-triangular, square matrix with width\n                ``num_qubits`` can be provided with interaction angles for each qubit pair.\n            label: A gate label.\n        \"\"\"\n        super().__init__(\"ms\", num_qubits, [theta], label=label)\n\n    def _define(self):\n        thetas = self.params[0]\n        q = QuantumRegister(self.num_qubits, name=\"q\")\n        qc = QuantumCircuit(q, name=self.name)\n        for i in range(self.num_qubits):\n            for j in range(i + 1, self.num_qubits):\n                # if theta is just a single angle, use that, otherwise use the correct index\n                theta = thetas if not isinstance(thetas, Sequence) else thetas[i][j]\n                qc._append(RXXGate(theta), [q[i], q[j]], [])\n\n        self.definition = qc\n\n    def validate_parameter(self, parameter):\n        if isinstance(parameter, Sequence):\n            # pylint: disable=super-with-arguments\n            return [\n                [super(MSGate, self).validate_parameter(theta) for theta in row]\n                for row in parameter\n            ]\n\n        return super().validate_parameter(parameter)\n",
    "line_count": 176
  },
  {
    "filename": "gr.py",
    "path": "qiskit/circuit/library/generalized_gates/gr.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Global R gates.\"\"\"\n\nimport numpy as np\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\n\n\nclass GR(QuantumCircuit):\n    r\"\"\"Global R gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241 GR(\u03f4,\u03c6) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global R gate is native to atomic systems (ion traps, cold neutrals). The global R\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an R(theta, phi) operation,\n    and is thus reduced to the RGate. The global R gate is a direct sum of R\n    operations on all individual qubits.\n\n    .. math::\n\n        GR(\\theta, \\phi) = \\exp(-i \\sum_{i=1}^{n} (\\cos(\\phi)X_i + \\sin(\\phi)Y_i) \\theta/2)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GR\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GR(num_qubits=3, theta=np.pi/4, phi=np.pi/2)\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(self, num_qubits: int, theta: float, phi: float) -> None:\n        \"\"\"Create a new Global R (GR) gate.\n\n        Args:\n            num_qubits: number of qubits.\n            theta: rotation angle about axis determined by phi\n            phi: angle of rotation axis in xy-plane\n        \"\"\"\n        name = f\"GR({theta:.2f}, {phi:.2f})\"\n        circuit = QuantumCircuit(num_qubits, name=name)\n        circuit.r(theta, phi, circuit.qubits)\n\n        super().__init__(num_qubits, name=name)\n        self.append(circuit.to_gate(), self.qubits)\n\n\nclass GRX(GR):\n    r\"\"\"Global RX gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRX(\u03f4) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RX gate is native to atomic systems (ion traps, cold neutrals). The global RX\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RX(theta) operations,\n    and is thus reduced to the RXGate. The global RX gate is a direct sum of RX\n    operations on all individual qubits.\n\n    .. math::\n\n        GRX(\\theta) = \\exp(-i \\sum_{i=1}^{n} X_i \\theta/2)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n        from qiskit.circuit.library import GRX\n        from qiskit.visualization.library import _generate_circuit_library_visualization\n        import numpy as np\n        circuit = GRX(num_qubits=3, theta=np.pi/4)\n        _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(self, num_qubits: int, theta: float) -> None:\n        \"\"\"Create a new Global RX (GRX) gate.\n\n        Args:\n            num_qubits: number of qubits.\n            theta: rotation angle about x-axis\n        \"\"\"\n        super().__init__(num_qubits, theta, phi=0)\n\n\nclass GRY(GR):\n    r\"\"\"Global RY gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRY(\u03f4) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RY gate is native to atomic systems (ion traps, cold neutrals). The global RY\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RY(theta) operation,\n    and is thus reduced to the RYGate. The global RY gate is a direct sum of RY\n    operations on all individual qubits.\n\n    .. math::\n\n        GRY(\\theta) = \\exp(-i \\sum_{i=1}^{n} Y_i \\theta/2)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GRY\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GRY(num_qubits=3, theta=np.pi/4)\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(self, num_qubits: int, theta: float) -> None:\n        \"\"\"Create a new Global RY (GRY) gate.\n\n        Args:\n            num_qubits: number of qubits.\n            theta: rotation angle about y-axis\n        \"\"\"\n        super().__init__(num_qubits, theta, phi=np.pi / 2)\n\n\nclass GRZ(QuantumCircuit):\n    r\"\"\"Global RZ gate.\n\n    **Circuit symbol:**\n\n    .. code-block:: text\n\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        q_0: \u25240         \u251c\n             \u2502          \u2502\n        q_1: \u25241  GRZ(\u03c6) \u251c\n             \u2502          \u2502\n        q_2: \u25242         \u251c\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    The global RZ gate is native to atomic systems (ion traps, cold neutrals). The global RZ\n    can be applied to multiple qubits simultaneously.\n\n    In the one-qubit case, this is equivalent to an RZ(phi) operation,\n    and is thus reduced to the RZGate. The global RZ gate is a direct sum of RZ\n    operations on all individual qubits.\n\n    .. math::\n\n        GRZ(\\phi) = \\exp(-i \\sum_{i=1}^{n} Z_i \\phi)\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import GRZ\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       import numpy as np\n       circuit = GRZ(num_qubits=3, phi=np.pi/2)\n       _generate_circuit_library_visualization(circuit)\n\n    \"\"\"\n\n    def __init__(self, num_qubits: int, phi: float) -> None:\n        \"\"\"Create a new Global RZ (GRZ) gate.\n\n        Args:\n            num_qubits: number of qubits.\n            phi: rotation angle about z-axis\n        \"\"\"\n        super().__init__(num_qubits, name=\"grz\")\n        self.rz(phi, self.qubits)\n",
    "line_count": 220
  },
  {
    "filename": "isometry.py",
    "path": "qiskit/circuit/library/generalized_gates/isometry.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n# pylint: disable=invalid-name\n# pylint: disable=unused-variable\n# pylint: disable=missing-param-doc\n# pylint: disable=missing-type-doc\n\n\"\"\"\nGeneric isometries from m to n qubits.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nimport numpy as np\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit.instruction import Instruction\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.quantum_info.operators.predicates import is_isometry\nfrom qiskit._accelerate import isometry as isometry_rs\n\nfrom .diagonal import DiagonalGate\nfrom .uc import UCGate\nfrom .mcg_up_to_diagonal import MCGupDiag\n\n_EPS = 1e-10  # global variable used to chop very small numbers to zero\n\n\nclass Isometry(Instruction):\n    r\"\"\"Decomposition of arbitrary isometries from :math:`m` to :math:`n` qubits.\n\n    In particular, this allows to decompose unitaries (m=n) and to do state preparation (:math:`m=0`).\n\n    The decomposition is based on [1].\n\n    References:\n        1. Iten et al., Quantum circuits for isometries (2016).\n           `Phys. Rev. A 93, 032318\n           <https://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.032318>`__.\n\n    \"\"\"\n\n    # Notation: In the following decomposition we label the qubit by\n    # 0 -> most significant one\n    # ...\n    # n -> least significant one\n    # finally, we convert the labels back to the qubit numbering used in Qiskit\n    # (using: _get_qubits_by_label)\n\n    def __init__(\n        self,\n        isometry: np.ndarray,\n        num_ancillas_zero: int,\n        num_ancillas_dirty: int,\n        epsilon: float = _EPS,\n    ) -> None:\n        r\"\"\"\n        Args:\n            isometry: An isometry from :math:`m` to :math`n` qubits, i.e., a complex\n                ``np.ndarray`` of dimension :math:`2^n \\times 2^m` with orthonormal columns (given\n                in the computational basis specified by the order of the ancillas\n                and the input qubits, where the ancillas are considered to be more\n                significant than the input qubits).\n            num_ancillas_zero: Number of additional ancillas that start in the state :math:`|0\\rangle`\n                (the :math:`n-m` ancillas required for providing the output of the isometry are\n                not accounted for here).\n            num_ancillas_dirty: Number of additional ancillas that start in an arbitrary state.\n            epsilon: Error tolerance of calculations.\n        \"\"\"\n        # Convert to numpy array in case not already an array\n        isometry = np.array(isometry, dtype=complex)\n\n        # change a row vector to a column vector (in the case of state preparation)\n        if len(isometry.shape) == 1:\n            isometry = isometry.reshape(isometry.shape[0], 1)\n\n        self.iso_data = isometry\n\n        self.num_ancillas_zero = num_ancillas_zero\n        self.num_ancillas_dirty = num_ancillas_dirty\n        self._inverse = None\n        self._epsilon = epsilon\n\n        # Check if the isometry has the right dimension and if the columns are orthonormal\n        n = math.log2(isometry.shape[0])\n        m = math.log2(isometry.shape[1])\n        if not n.is_integer() or n < 0:\n            raise QiskitError(\n                \"The number of rows of the isometry is not a non negative power of 2.\"\n            )\n        if not m.is_integer() or m < 0:\n            raise QiskitError(\n                \"The number of columns of the isometry is not a non negative power of 2.\"\n            )\n        if m > n:\n            raise QiskitError(\n                \"The input matrix has more columns than rows and hence it can't be an isometry.\"\n            )\n        if not is_isometry(isometry, self._epsilon):\n            raise QiskitError(\n                \"The input matrix has non orthonormal columns and hence it is not an isometry.\"\n            )\n\n        num_qubits = int(n) + num_ancillas_zero + num_ancillas_dirty\n\n        super().__init__(\"isometry\", num_qubits, 0, [isometry])\n\n    def _define(self):\n        # TODO The inverse().inverse() is because there is code to uncompute (_gates_to_uncompute)\n        #  an isometry, but not for generating its decomposition. It would be cheaper to do the\n        #  later here instead.\n        gate = self.inv_gate()\n        gate = gate.inverse()\n        q = QuantumRegister(self.num_qubits, \"q\")\n        iso_circuit = QuantumCircuit(q, name=\"isometry\")\n        iso_circuit.append(gate, q[:])\n        self.definition = iso_circuit\n\n    def inverse(self, annotated: bool = False):\n        self.params = []\n        inv = super().inverse(annotated=annotated)\n        self.params = [self.iso_data]\n        return inv\n\n    def _gates_to_uncompute(self):\n        \"\"\"\n        Call to create a circuit with gates that take the desired isometry to the first 2^m columns\n         of the 2^n*2^n identity matrix (see https://arxiv.org/abs/1501.06911)\n        \"\"\"\n        q = QuantumRegister(self.num_qubits, \"q\")\n        circuit = QuantumCircuit(q, name=\"isometry_to_uncompute\")\n        (\n            q_input,\n            q_ancillas_for_output,\n            q_ancillas_zero,\n            q_ancillas_dirty,\n        ) = self._define_qubit_role(q)\n        # Copy the isometry (this is computationally expensive for large isometries but guarantees\n        # to keep a copyof the input isometry)\n        remaining_isometry = self.iso_data.astype(complex)  # note: \"astype\" does copy the isometry\n        diag = []\n        m = int(math.log2(self.iso_data.shape[1]))\n        # Decompose the column with index column_index and attache the gate to the circuit object.\n        # Return the isometry that is left to decompose, where the columns up to index column_index\n        # correspond to the firstfew columns of the identity matrix up to diag, and hence we only\n        # have to save a list containing them.\n        for column_index in range(2**m):\n            remaining_isometry, diag = self._decompose_column(\n                circuit, q, diag, remaining_isometry, column_index\n            )\n            # extract phase of the state that was sent to the basis state ket(column_index)\n            diag.append(remaining_isometry[column_index, 0])\n            # remove first column (which is now stored in diag)\n            remaining_isometry = remaining_isometry[:, 1:]\n        if len(diag) > 1 and not isometry_rs.diag_is_identity_up_to_global_phase(\n            diag, self._epsilon\n        ):\n            diagonal = DiagonalGate(np.conj(diag))\n            circuit.append(diagonal, q_input)\n        return circuit\n\n    def _decompose_column(self, circuit, q, diag, remaining_isometry, column_index):\n        \"\"\"\n        Decomposes the column with index column_index.\n        \"\"\"\n        n = int(math.log2(self.iso_data.shape[0]))\n        for s in range(n):\n            remaining_isometry, diag = self._disentangle(\n                circuit, q, diag, remaining_isometry, column_index, s\n            )\n        return remaining_isometry, diag\n\n    def _disentangle(self, circuit, q, diag, remaining_isometry, column_index, s):\n        \"\"\"\n        Disentangle the s-th significant qubit (starting with s = 0) into the zero or the one state\n        (dependent on column_index)\n        \"\"\"\n        # To shorten the notation, we introduce:\n        k = column_index\n        # k_prime is the index of the column with index column_index in the remaining isometry\n        # (note that we remove columns of the isometry during the procedure for efficiency)\n        k_prime = 0\n        v = remaining_isometry\n        n = int(math.log2(self.iso_data.shape[0]))\n\n        # MCG to set one entry to zero (preparation for disentangling with UCGate):\n        index1 = 2 * isometry_rs.a(k, s + 1) * 2**s + isometry_rs.b(k, s + 1)\n        index2 = (2 * isometry_rs.a(k, s + 1) + 1) * 2**s + isometry_rs.b(k, s + 1)\n        target_label = n - s - 1\n        # Check if a MCG is required\n        if (\n            isometry_rs.k_s(k, s) == 0\n            and isometry_rs.b(k, s + 1) != 0\n            and np.abs(v[index2, k_prime]) > self._epsilon\n        ):\n            # Find the MCG, decompose it and apply it to the remaining isometry\n            gate = isometry_rs.reverse_qubit_state(\n                [v[index1, k_prime], v[index2, k_prime]], 0, self._epsilon\n            )\n            control_labels = [\n                i\n                for i, x in enumerate(_get_binary_rep_as_list(k, n))\n                if x == 1 and i != target_label\n            ]\n            diagonal_mcg = self._append_mcg_up_to_diagonal(\n                circuit, q, gate, control_labels, target_label\n            )\n            # apply the MCG to the remaining isometry\n            v = isometry_rs.apply_multi_controlled_gate(v, control_labels, target_label, gate)\n            # correct for the implementation \"up to diagonal\"\n            diag_mcg_inverse = np.conj(diagonal_mcg).astype(complex, copy=False)\n            v = isometry_rs.apply_diagonal_gate(\n                v, control_labels + [target_label], diag_mcg_inverse\n            )\n            # update the diag according to the applied diagonal gate\n            diag = isometry_rs.apply_diagonal_gate_to_diag(\n                diag, control_labels + [target_label], diag_mcg_inverse, n\n            )\n\n        # UCGate to disentangle a qubit:\n        # Find the UCGate, decompose it and apply it to the remaining isometry\n        single_qubit_gates = self._find_squs_for_disentangling(v, k, s)\n        if not isometry_rs.ucg_is_identity_up_to_global_phase(single_qubit_gates, self._epsilon):\n            control_labels = list(range(target_label))\n            diagonal_ucg = self._append_ucg_up_to_diagonal(\n                circuit, q, single_qubit_gates, control_labels, target_label\n            )\n            # merge the diagonal into the UCGate for efficient application of both together\n            diagonal_ucg_inverse = np.conj(diagonal_ucg).astype(complex, copy=False)\n            single_qubit_gates = isometry_rs.merge_ucgate_and_diag(\n                single_qubit_gates, diagonal_ucg_inverse\n            )\n            # apply the UCGate (with the merged diagonal gate) to the remaining isometry\n            v = isometry_rs.apply_ucg(v, len(control_labels), single_qubit_gates)\n            # update the diag according to the applied diagonal gate\n            diag = isometry_rs.apply_diagonal_gate_to_diag(\n                diag, control_labels + [target_label], diagonal_ucg_inverse, n\n            )\n            # # correct for the implementation \"up to diagonal\"\n            # diag_inv = np.conj(diag).tolist()\n            # _apply_diagonal_gate(v, control_labels + [target_label], diag_inv)\n        return v, diag\n\n    # This method finds the single-qubit gates for a UCGate to disentangle a qubit:\n    # we consider the n-qubit state v[:,0] starting with k zeros (in the computational basis).\n    # The qubit with label n-s-1 is disentangled into the basis state k_s(k,s).\n    def _find_squs_for_disentangling(self, v, k, s):\n        res = isometry_rs.find_squs_for_disentangling(\n            v, k, s, self._epsilon, n=int(math.log2(self.iso_data.shape[0]))\n        )\n        return res\n\n    # Append a UCGate up to diagonal to the circuit circ.\n    def _append_ucg_up_to_diagonal(self, circ, q, single_qubit_gates, control_labels, target_label):\n        (\n            q_input,\n            q_ancillas_for_output,\n            q_ancillas_zero,\n            q_ancillas_dirty,\n        ) = self._define_qubit_role(q)\n        n = int(math.log2(self.iso_data.shape[0]))\n        qubits = q_input + q_ancillas_for_output\n        # Note that we have to reverse the control labels, since controls are provided by\n        # increasing qubit number toa UCGate by convention\n        control_qubits = _reverse_qubit_oder(_get_qubits_by_label(control_labels, qubits, n))\n        target_qubit = _get_qubits_by_label([target_label], qubits, n)[0]\n        ucg = UCGate(single_qubit_gates, up_to_diagonal=True)\n        circ.append(ucg, [target_qubit] + control_qubits)\n        return ucg._get_diagonal()\n\n    # Append a MCG up to diagonal to the circuit circ. The diagonal should only act on the control\n    # and target qubits and not on the ancillas. In principle, it would be allowed to act on the\n    # dirty ancillas on which we perform the isometry (i.e., on the qubits listed in \"qubits\"\n    # below). But for simplicity, the current code version ignores this future optimization\n    # possibility.\n    def _append_mcg_up_to_diagonal(self, circ, q, gate, control_labels, target_label):\n        (\n            q_input,\n            q_ancillas_for_output,\n            q_ancillas_zero,\n            q_ancillas_dirty,\n        ) = self._define_qubit_role(q)\n        n = int(math.log2(self.iso_data.shape[0]))\n        qubits = q_input + q_ancillas_for_output\n        control_qubits = _reverse_qubit_oder(_get_qubits_by_label(control_labels, qubits, n))\n        target_qubit = _get_qubits_by_label([target_label], qubits, n)[0]\n        # The qubits on which we neither act nor control on with the MCG, can be used\n        # as dirty ancillas\n        ancilla_dirty_labels = [i for i in range(n) if i not in control_labels + [target_label]]\n        ancillas_dirty = (\n            _reverse_qubit_oder(_get_qubits_by_label(ancilla_dirty_labels, qubits, n))\n            + q_ancillas_dirty\n        )\n        mcg_up_to_diag = MCGupDiag(\n            gate, len(control_qubits), len(q_ancillas_zero), len(ancillas_dirty)\n        )\n        circ.append(\n            mcg_up_to_diag, [target_qubit] + control_qubits + q_ancillas_zero + ancillas_dirty\n        )\n        return mcg_up_to_diag._get_diagonal()\n\n    def _define_qubit_role(self, q):\n\n        n = int(math.log2(self.iso_data.shape[0]))\n        m = int(math.log2(self.iso_data.shape[1]))\n\n        # Define the role of the qubits\n        q_input = q[:m]\n        q_ancillas_for_output = q[m:n]\n        q_ancillas_zero = q[n : n + self.num_ancillas_zero]\n        q_ancillas_dirty = q[n + self.num_ancillas_zero :]\n        return q_input, q_ancillas_for_output, q_ancillas_zero, q_ancillas_dirty\n\n    def validate_parameter(self, parameter):\n        \"\"\"Isometry parameter has to be an ndarray.\"\"\"\n        if isinstance(parameter, np.ndarray):\n            return parameter\n        if isinstance(parameter, (list, int)):\n            return parameter\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} for gate {self.name}\")\n\n    def inv_gate(self):\n        \"\"\"Return the adjoint of the unitary.\"\"\"\n        if self._inverse is None:\n            # call to generate the circuit that takes the isometry to the first 2^m columns\n            # of the 2^n identity matrix\n            iso_circuit = self._gates_to_uncompute()\n            # invert the circuit to create the circuit implementing the isometry\n            self._inverse = iso_circuit.to_instruction()\n        return self._inverse\n\n\n# Get the qubits in the list qubits corresponding to the labels listed in labels. The total number\n# of qubits is given by num_qubits (and determines the convention for the qubit labeling)\n\n# Remark: We labeled the qubits with decreasing significance. So we have to transform the labels to\n# be compatible with the standard convention of Qiskit.\n\n\ndef _get_qubits_by_label(labels, qubits, num_qubits):\n    return [qubits[num_qubits - label - 1] for label in labels]\n\n\ndef _reverse_qubit_oder(qubits):\n    return list(reversed(qubits))\n\n\n# Convert list of binary digits to integer\n\n\ndef _get_binary_rep_as_list(n, num_digits):\n    binary_string = np.binary_repr(n).zfill(num_digits)\n    binary = []\n    for line in binary_string:\n        for c in line:\n            binary.append(int(c))\n    return binary[-num_digits:]\n",
    "line_count": 371
  },
  {
    "filename": "linear_function.py",
    "path": "qiskit/circuit/library/generalized_gates/linear_function.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2024.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Linear Function.\"\"\"\n\nfrom __future__ import annotations\nimport numpy as np\nfrom qiskit.circuit.quantumcircuit import QuantumCircuit, Gate\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.circuit.library.generalized_gates.permutation import PermutationGate\nfrom qiskit.utils.deprecation import deprecate_func\n\n# pylint: disable=cyclic-import\nfrom qiskit.quantum_info import Clifford\n\n\nclass LinearFunction(Gate):\n    r\"\"\"A linear reversible circuit on n qubits.\n\n    Internally, a linear function acting on n qubits is represented\n    as a n x n matrix of 0s and 1s in numpy array format.\n\n    A linear function can be synthesized into CX and SWAP gates using the Patel\u2013Markov\u2013Hayes\n    algorithm, as implemented in :func:`~qiskit.synthesis.synth_cnot_count_full_pmh`\n    based on reference [1].\n\n    For efficiency, the internal n x n matrix is stored in the format expected\n    by cnot_synth, which is the big-endian (and not the little-endian) bit-ordering convention.\n\n    **Example:** the circuit\n\n    .. code-block:: text\n\n        q_0: \u2500\u2500\u25a0\u2500\u2500\n             \u250c\u2500\u2534\u2500\u2510\n        q_1: \u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518\n        q_2: \u2500\u2500\u2500\u2500\u2500\n\n    is represented by a 3x3 linear matrix\n\n    .. math::\n\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                1 & 1 & 0 \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n\n\n    **References:**\n\n    [1] Ketan N. Patel, Igor L. Markov, and John P. Hayes,\n    Optimal synthesis of linear reversible circuits,\n    Quantum Inf. Comput. 8(3) (2008).\n    `Online at umich.edu. <https://web.eecs.umich.edu/~imarkov/pubs/jour/qic08-cnot.pdf>`_\n    \"\"\"\n\n    def __init__(\n        self,\n        linear: (\n            list[list[bool]]\n            | np.ndarray[bool]\n            | QuantumCircuit\n            | LinearFunction\n            | PermutationGate\n            | Clifford\n        ),\n        validate_input: bool = False,\n    ) -> None:\n        \"\"\"Create a new linear function.\n\n        Args:\n            linear: data from which a linear function can be constructed. It can be either a\n                nxn matrix (describing the linear transformation), a permutation (which is a\n                special case of a linear function), another linear function, a clifford (when\n                it corresponds to a linear function), or a quantum circuit composed of\n                linear gates (CX and SWAP) and other objects described above, including\n                nested subcircuits.\n\n            validate_input: if True, performs more expensive input validation checks,\n                such as checking that a given n x n matrix is invertible.\n\n        Raises:\n            CircuitError: if the input is invalid:\n                either the input matrix is not square or not invertible,\n                or the input quantum circuit contains non-linear objects\n                (for example, a Hadamard gate, or a Clifford that does\n                not correspond to a linear function).\n        \"\"\"\n\n        original_circuit = None\n\n        if isinstance(linear, (list, np.ndarray)):\n            # Normalize to numpy array (coercing entries to 0s and 1s)\n            try:\n                linear = np.array(linear, dtype=bool, copy=True)\n            except ValueError:\n                raise CircuitError(\n                    \"A linear function must be represented by a square matrix.\"\n                ) from None\n\n            # Check that the matrix is square\n            if len(linear.shape) != 2 or linear.shape[0] != linear.shape[1]:\n                raise CircuitError(\"A linear function must be represented by a square matrix.\")\n\n            # Optionally, check that the matrix is invertible\n            if validate_input:\n                from qiskit.synthesis.linear import check_invertible_binary_matrix\n\n                if not check_invertible_binary_matrix(linear):\n                    raise CircuitError(\n                        \"A linear function must be represented by an invertible matrix.\"\n                    )\n\n        elif isinstance(linear, QuantumCircuit):\n            # The following function will raise a CircuitError if there are nonlinear gates.\n            original_circuit = linear\n            linear = LinearFunction._circuit_to_mat(linear)\n\n        elif isinstance(linear, LinearFunction):\n            linear = linear.linear.copy()\n\n        elif isinstance(linear, PermutationGate):\n            linear = LinearFunction._permutation_to_mat(linear)\n\n        elif isinstance(linear, Clifford):\n            # The following function will raise a CircuitError if clifford does not correspond\n            # to a linear function.\n            linear = LinearFunction._clifford_to_mat(linear)\n\n        # Note: if we wanted, we could also try to construct a linear function from a\n        # general operator, by first attempting to convert it to clifford, and then to\n        # a linear function.\n\n        else:\n            raise CircuitError(\"A linear function cannot be successfully constructed.\")\n\n        super().__init__(\n            name=\"linear_function\", num_qubits=len(linear), params=[linear, original_circuit]\n        )\n\n    @staticmethod\n    def _circuit_to_mat(qc: QuantumCircuit):\n        \"\"\"This creates a nxn matrix corresponding to the given quantum circuit.\"\"\"\n        nq = qc.num_qubits\n        mat = np.eye(nq, nq, dtype=bool)\n\n        for instruction in qc.data:\n            if instruction.operation.name in (\"barrier\", \"delay\"):\n                # can be ignored\n                continue\n            if instruction.operation.name == \"cx\":\n                # implemented directly\n                cb = qc.find_bit(instruction.qubits[0]).index\n                tb = qc.find_bit(instruction.qubits[1]).index\n                mat[tb, :] = (mat[tb, :]) ^ (mat[cb, :])\n                continue\n            if instruction.operation.name == \"swap\":\n                # implemented directly\n                cb = qc.find_bit(instruction.qubits[0]).index\n                tb = qc.find_bit(instruction.qubits[1]).index\n                mat[[cb, tb]] = mat[[tb, cb]]\n                continue\n\n            # In all other cases, we construct the linear function for the operation.\n            # and compose (multiply) linear matrices.\n\n            if getattr(instruction.operation, \"definition\", None) is not None:\n                other = LinearFunction(instruction.operation.definition)\n            else:\n                other = LinearFunction(instruction.operation)\n\n            positions = [qc.find_bit(q).index for q in instruction.qubits]\n            other = other.extend_with_identity(len(mat), positions)\n            mat = np.dot(other.linear.astype(int), mat.astype(int)) % 2\n            mat = mat.astype(bool)\n\n        return mat\n\n    @staticmethod\n    def _clifford_to_mat(cliff):\n        \"\"\"This creates a nxn matrix corresponding to the given Clifford, when Clifford\n        can be converted to a linear function. This is possible when the clifford has\n        tableau of the form [[A, B], [C, D]], with B = C = 0 and D = A^{-1}^t, and zero\n        phase vector. In this case, the required matrix is A^t.\n        Raises an error otherwise.\n        \"\"\"\n        # Note: since cliff is a valid Clifford, then the condition D = A^{-1}^t\n        # holds automatically once B = C = 0.\n        if cliff.phase.any() or cliff.destab_z.any() or cliff.stab_x.any():\n            raise CircuitError(\"The given clifford does not correspond to a linear function.\")\n        return np.transpose(cliff.destab_x)\n\n    @staticmethod\n    def _permutation_to_mat(perm):\n        \"\"\"This creates a nxn matrix from a given permutation gate.\"\"\"\n        nq = len(perm.pattern)\n        mat = np.zeros((nq, nq), dtype=bool)\n        for i, j in enumerate(perm.pattern):\n            mat[i, j] = True\n        return mat\n\n    def __eq__(self, other):\n        \"\"\"Check if two linear functions represent the same matrix.\"\"\"\n        if not isinstance(other, LinearFunction):\n            return False\n        return (self.linear == other.linear).all()\n\n    def validate_parameter(self, parameter):\n        \"\"\"Parameter validation\"\"\"\n        return parameter\n\n    def _define(self):\n        \"\"\"Populates self.definition with a decomposition of this gate.\"\"\"\n        from qiskit.synthesis.linear import synth_cnot_count_full_pmh\n\n        self.definition = synth_cnot_count_full_pmh(self.linear)\n\n    @deprecate_func(\n        since=\"1.3\",\n        pending=True,\n        additional_msg=\"Call LinearFunction.definition instead, or compile the circuit.\",\n    )\n    def synthesize(self):\n        \"\"\"Synthesizes the linear function into a quantum circuit.\n\n        Returns:\n            QuantumCircuit: A circuit implementing the evolution.\n        \"\"\"\n        return self.definition\n\n    @property\n    def linear(self):\n        \"\"\"Returns the n x n matrix representing this linear function.\"\"\"\n        return self.params[0]\n\n    @property\n    def original_circuit(self):\n        \"\"\"Returns the original circuit used to construct this linear function\n        (including None, when the linear function is not constructed from a circuit).\n        \"\"\"\n        return self.params[1]\n\n    def is_permutation(self) -> bool:\n        \"\"\"Returns whether this linear function is a permutation,\n        that is whether every row and every column of the n x n matrix\n        has exactly one 1.\n        \"\"\"\n        linear = self.linear\n        perm = np.all(np.sum(linear, axis=0) == 1) and np.all(np.sum(linear, axis=1) == 1)\n        return perm\n\n    def permutation_pattern(self):\n        \"\"\"This method first checks if a linear function is a permutation and raises a\n        `qiskit.circuit.exceptions.CircuitError` if not. In the case that this linear function\n        is a permutation, returns the permutation pattern.\n        \"\"\"\n        if not self.is_permutation():\n            raise CircuitError(\"The linear function is not a permutation\")\n\n        linear = self.linear\n        locs = np.where(linear == 1)\n        return locs[1]\n\n    def extend_with_identity(self, num_qubits: int, positions: list[int]) -> LinearFunction:\n        \"\"\"Extend linear function to a linear function over nq qubits,\n        with identities on other subsystems.\n\n        Args:\n            num_qubits: number of qubits of the extended function.\n\n            positions: describes the positions of original qubits in the extended\n                function's qubits.\n\n        Returns:\n            LinearFunction: extended linear function.\n        \"\"\"\n        extended_mat = np.eye(num_qubits, dtype=bool)\n\n        for i, pos in enumerate(positions):\n            extended_mat[positions, pos] = self.linear[:, i]\n\n        return LinearFunction(extended_mat)\n\n    def mat_str(self):\n        \"\"\"Return string representation of the linear function\n        viewed as a matrix with 0/1 entries.\n        \"\"\"\n        return str(self.linear.astype(int))\n\n    def function_str(self):\n        \"\"\"Return string representation of the linear function\n        viewed as a linear transformation.\n        \"\"\"\n        out = \"(\"\n        mat = self.linear\n        for row in range(self.num_qubits):\n            first_entry = True\n            for col in range(self.num_qubits):\n                if mat[row, col]:\n                    if not first_entry:\n                        out += \" + \"\n                    out += \"x_\" + str(col)\n                    first_entry = False\n            if row != self.num_qubits - 1:\n                out += \", \"\n        out += \")\\n\"\n        return out\n",
    "line_count": 319
  },
  {
    "filename": "mcg_up_to_diagonal.py",
    "path": "qiskit/circuit/library/generalized_gates/mcg_up_to_diagonal.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2019.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n# pylint: disable=unused-variable\n\n\"\"\"Multi controlled single-qubit unitary up to diagonal.\"\"\"\n\n# ToDo: This code should be merged wth the implementation of MCGs\n# ToDo: (introducing a decomposition mode \"up_to_diagonal\").\n\nimport numpy as np\n\nfrom qiskit.circuit import Gate\nfrom qiskit.circuit.quantumcircuit import QuantumRegister, QuantumCircuit\nfrom qiskit.circuit.exceptions import CircuitError\nfrom qiskit.exceptions import QiskitError\nfrom qiskit.quantum_info.operators.predicates import is_isometry\n\nfrom .uc import UCGate\n\n_EPS = 1e-10  # global variable used to chop very small numbers to zero\n\n\nclass MCGupDiag(Gate):\n    r\"\"\"\n    Decomposes a multi-controlled gate :math:`U` up to a diagonal :math:`D` acting on the control\n    and target qubit (but not on the ancilla qubits), i.e., it implements a circuit corresponding to\n    a unitary :math:`U'`, such that :math:`U = D U'`.\n    \"\"\"\n\n    def __init__(\n        self, gate: np.ndarray, num_controls: int, num_ancillas_zero: int, num_ancillas_dirty: int\n    ) -> None:\n        r\"\"\"\n        Args:\n            gate: :math:`2 \\times 2` unitary given as a (complex) ``ndarray``.\n            num_controls: Number of control qubits.\n            num_ancillas_zero: Number of ancilla qubits that start in the state zero.\n            num_ancillas_dirty: Number of ancilla qubits that are allowed to start in an\n                arbitrary state.\n\n        Raises:\n            QiskitError: if the input format is wrong; if the array gate is not unitary\n        \"\"\"\n\n        self.num_controls = num_controls\n        self.num_ancillas_zero = num_ancillas_zero\n        self.num_ancillas_dirty = num_ancillas_dirty\n        # Check if the gate has the right dimension\n        if not gate.shape == (2, 2):\n            raise QiskitError(\"The dimension of the controlled gate is not equal to (2,2).\")\n        # Check if the single-qubit gate is unitary\n        if not is_isometry(gate, _EPS):\n            raise QiskitError(\"The controlled gate is not unitary.\")\n        # Create new gate.\n        num_qubits = 1 + num_controls + num_ancillas_zero + num_ancillas_dirty\n        super().__init__(\"MCGupDiag\", num_qubits, [gate])\n\n    def _define(self):\n        mcg_up_diag_circuit, _ = self._dec_mcg_up_diag()\n        gate = mcg_up_diag_circuit.to_instruction()\n        q = QuantumRegister(self.num_qubits, \"q\")\n        mcg_up_diag_circuit = QuantumCircuit(q, name=\"mcg_up_to_diagonal\")\n        mcg_up_diag_circuit.append(gate, q[:])\n        self.definition = mcg_up_diag_circuit\n\n    def inverse(self, annotated: bool = False) -> Gate:\n        \"\"\"Return the inverse.\n\n        Note that the resulting Gate object has an empty ``params`` property.\n        \"\"\"\n        if not annotated:\n            inverse_gate = Gate(\n                name=self.name + \"_dg\", num_qubits=self.num_qubits, params=[]\n            )  # removing the params because arrays are deprecated\n\n            definition = QuantumCircuit(*self.definition.qregs)\n            for inst in reversed(self._definition):\n                definition._append(\n                    inst.replace(operation=inst.operation.inverse(annotated=annotated))\n                )\n            inverse_gate.definition = definition\n        else:\n            inverse_gate = super().inverse(annotated=annotated)\n        return inverse_gate\n\n    # Returns the diagonal up to which the gate is implemented.\n    def _get_diagonal(self):\n        # Important: for a control list q_controls = [q[0],...,q_[k-1]] the diagonal gate is\n        # provided in the computational basis of the qubits q[k-1],...,q[0],q_target, decreasingly\n        # ordered with respect to the significance of the qubit in the computational basis\n        _, diag = self._dec_mcg_up_diag()\n        return diag\n\n    def _dec_mcg_up_diag(self):\n        \"\"\"\n        Call to create a circuit with gates that implement the MCG up to a diagonal gate.\n        Remark: The qubits the gate acts on are ordered in the following way:\n            q=[q_target,q_controls,q_ancilla_zero,q_ancilla_dirty]\n        \"\"\"\n        diag = np.ones(2 ** (self.num_controls + 1)).tolist()\n        q = QuantumRegister(self.num_qubits, \"q\")\n        circuit = QuantumCircuit(q, name=\"mcg_up_to_diagonal\")\n        (q_target, q_controls, q_ancillas_zero, q_ancillas_dirty) = self._define_qubit_role(q)\n        # ToDo: Keep this threshold updated such that the lowest gate count is achieved:\n        # ToDo: we implement the MCG with a UCGate up to diagonal if the number of controls is\n        # ToDo: smaller than the threshold.\n        threshold = float(\"inf\")\n        if self.num_controls < threshold:\n            # Implement the MCG as a UCGate (up to diagonal)\n            gate_list = [np.eye(2, 2) for i in range(2**self.num_controls)]\n            gate_list[-1] = self.params[0]\n            ucg = UCGate(gate_list, up_to_diagonal=True)\n            circuit.append(ucg, [q_target] + q_controls)\n            diag = ucg._get_diagonal()\n            # else:\n            # ToDo: Use the best decomposition for MCGs up to diagonal gates here\n            # ToDo: (with all available ancillas)\n        return circuit, diag\n\n    def _define_qubit_role(self, q):\n        # Define the role of the qubits\n        q_target = q[0]\n        q_controls = q[1 : self.num_controls + 1]\n        q_ancillas_zero = q[self.num_controls + 1 : self.num_controls + 1 + self.num_ancillas_zero]\n        q_ancillas_dirty = q[self.num_controls + 1 + self.num_ancillas_zero :]\n        return q_target, q_controls, q_ancillas_zero, q_ancillas_dirty\n\n    def validate_parameter(self, parameter):\n        \"\"\"Multi controlled single-qubit unitary gate parameter has to be an ndarray.\"\"\"\n        if isinstance(parameter, np.ndarray):\n            return parameter\n        else:\n            raise CircuitError(f\"invalid param type {type(parameter)} in gate {self.name}\")\n",
    "line_count": 144
  },
  {
    "filename": "mcmt.py",
    "path": "qiskit/circuit/library/generalized_gates/mcmt.py",
    "language": "Python",
    "code": "# This code is part of Qiskit.\n#\n# (C) Copyright IBM 2017, 2020.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Multiple-Control, Multiple-Target Gate.\"\"\"\n\nfrom __future__ import annotations\n\nimport warnings\nfrom collections.abc import Callable\n\nfrom qiskit import circuit\nfrom qiskit.circuit import ControlledGate, Gate, QuantumCircuit\nfrom qiskit.circuit._utils import _ctrl_state_to_int\nfrom qiskit.utils.deprecation import deprecate_func\nfrom ..standard_gates import get_standard_gate_name_mapping\n\n\nclass MCMT(QuantumCircuit):\n    \"\"\"The multi-controlled multi-target gate, for an arbitrary singly controlled target gate.\n\n    For example, the H gate controlled on 3 qubits and acting on 2 target qubit is represented as:\n\n    .. code-block:: text\n\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n        \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n        \u25240     \u251c\n        \u2502  2-H \u2502\n        \u25241     \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    This default implementations requires no ancilla qubits, by broadcasting the target gate\n    to the number of target qubits and using Qiskit's generic control routine to control the\n    broadcasted target on the control qubits. If ancilla qubits are available, a more efficient\n    variant using the so-called V-chain decomposition can be used. This is implemented in\n    :class:`~qiskit.circuit.library.MCMTVChain`.\n    \"\"\"\n\n    @deprecate_func(since=\"1.4\", additional_msg=\"Use MCMTGate instead.\")\n    def __init__(\n        self,\n        gate: Gate | Callable[[QuantumCircuit, circuit.Qubit, circuit.Qubit], circuit.Instruction],\n        num_ctrl_qubits: int,\n        num_target_qubits: int,\n    ) -> None:\n        \"\"\"Create a new multi-control multi-target gate.\n\n        Args:\n            gate: The gate to be applied controlled on the control qubits and applied to the target\n                qubits. Can be either a Gate or a circuit method.\n                If it is a callable, it will be casted to a Gate.\n            num_ctrl_qubits: The number of control qubits.\n            num_target_qubits: The number of target qubits.\n\n        Raises:\n            AttributeError: If the gate cannot be casted to a controlled gate.\n            AttributeError: If the number of controls or targets is 0.\n        \"\"\"\n        if num_ctrl_qubits == 0 or num_target_qubits == 0:\n            raise AttributeError(\"Need at least one control and one target qubit.\")\n\n        if callable(gate):\n            warnings.warn(\n                \"Passing a callable to MCMT is pending deprecation since Qiskit 1.3. Pass a \"\n                \"gate instance or the gate name instead, e.g. pass 'h' instead of QuantumCircuit.h.\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            gate = gate.__name__\n        elif isinstance(gate, QuantumCircuit):\n            warnings.warn(\n                \"Passing a QuantumCircuit is pending deprecation since Qiskit 1.3. Pass a gate \"\n                \"or turn the circuit into a gate using the ``to_gate`` method, instead.\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            gate = gate.to_gate()\n\n        self.gate = MCMTGate._identify_base_gate(gate)\n        self.num_ctrl_qubits = num_ctrl_qubits\n        self.num_target_qubits = num_target_qubits\n\n        # initialize the circuit object\n        num_qubits = num_ctrl_qubits + num_target_qubits + self.num_ancilla_qubits\n        super().__init__(num_qubits, name=\"mcmt\")\n        self._build()\n\n    def _build(self):\n        gate = MCMTGate(self.gate, self.num_ctrl_qubits, self.num_target_qubits)\n        self.append(gate, self.qubits)\n\n    @property\n    def num_ancilla_qubits(self):\n        \"\"\"Return the number of ancillas.\"\"\"\n        return 0\n\n    def control(self, num_ctrl_qubits=1, label=None, ctrl_state=None, annotated=False):\n        \"\"\"Return the controlled version of the MCMT circuit.\"\"\"\n        if not annotated and ctrl_state is None:\n            gate = MCMT(self.gate, self.num_ctrl_qubits + num_ctrl_qubits, self.num_target_qubits)\n        else:\n            gate = super().control(num_ctrl_qubits, label, ctrl_state, annotated=annotated)\n        return gate\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Return the inverse MCMT circuit, which is itself.\"\"\"\n        return MCMT(self.gate, self.num_ctrl_qubits, self.num_target_qubits)\n\n\nclass MCMTVChain(MCMT):\n    \"\"\"The MCMT implementation using the CCX V-chain.\n\n    This implementation requires ancillas but is decomposed into a much shallower circuit\n    than the default implementation in :class:`~qiskit.circuit.library.MCMT`.\n\n    **Expanded Circuit:**\n\n    .. plot::\n       :alt: Diagram illustrating the previously described circuit.\n\n       from qiskit.circuit.library import MCMTVChain, ZGate\n       from qiskit.visualization.library import _generate_circuit_library_visualization\n       circuit = MCMTVChain(ZGate(), 2, 2)\n       _generate_circuit_library_visualization(circuit.decompose())\n\n    **Examples:**\n\n        >>> from qiskit.circuit.library import HGate\n        >>> MCMTVChain(HGate(), 3, 2).draw()\n\n        q_0: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n               \u2502                        \u2502\n        q_1: \u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\n               \u2502                        \u2502\n        q_2: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n               \u2502    \u2502  \u250c\u2500\u2500\u2500\u2510       \u2502    \u2502\n        q_3: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 H \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n               \u2502    \u2502  \u2514\u2500\u252c\u2500\u2518\u250c\u2500\u2500\u2500\u2510  \u2502    \u2502\n        q_4: \u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 H \u251c\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\n             \u250c\u2500\u2534\u2500\u2510  \u2502    \u2502  \u2514\u2500\u252c\u2500\u2518  \u2502  \u250c\u2500\u2534\u2500\u2510\n        q_5: \u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\n             \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510  \u2502    \u2502  \u250c\u2500\u2534\u2500\u2510\u2514\u2500\u2500\u2500\u2518\n        q_6: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\u25a0\u2500\u2500\u2524 X \u251c\u2500\u2500\u2500\u2500\u2500\n                  \u2514\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2518\n    \"\"\"\n\n    @deprecate_func(\n        since=\"1.4\",\n        additional_msg=\"Use MCMTGate with the V-chain synthesis plugin instead.\",\n    )\n    def __init__(\n        self,\n        gate: Gate | Callable[[QuantumCircuit, circuit.Qubit, circuit.Qubit], circuit.Instruction],\n        num_ctrl_qubits: int,\n        num_target_qubits: int,\n    ) -> None:\n        super().__init__(gate, num_ctrl_qubits, num_target_qubits)\n\n    def _build(self):\n        # pylint: disable=cyclic-import\n        from qiskit.synthesis.multi_controlled import synth_mcmt_vchain\n\n        synthesized = synth_mcmt_vchain(self.gate, self.num_ctrl_qubits, self.num_target_qubits)\n        self.compose(synthesized, inplace=True, copy=False)\n\n    @property\n    def num_ancilla_qubits(self):\n        \"\"\"Return the number of ancilla qubits required.\"\"\"\n        return max(0, self.num_ctrl_qubits - 1)\n\n    def inverse(self, annotated: bool = False):\n        return MCMTVChain(self.gate, self.num_ctrl_qubits, self.num_target_qubits)\n\n\nclass MCMTGate(ControlledGate):\n    \"\"\"The multi-controlled multi-target gate, for an arbitrary singly controlled target gate.\n\n    For example, the H gate controlled on 3 qubits and acting on 2 target qubit is represented as:\n\n    .. parsed-literal::\n\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n           \u2502\n        \u2500\u2500\u2500\u25a0\u2500\u2500\u2500\u2500\n        \u250c\u2500\u2500\u2534\u2500\u2500\u2500\u2510\n        \u25240     \u251c\n        \u2502  2-H \u2502\n        \u25241     \u251c\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Depending on the number of available auxiliary qubits, this operation can be synthesized\n    using different methods. For example, if :math:`n - 1` clean auxiliary qubits are available\n    (where :math:`n` is the number of control qubits), a V-chain decomposition can be used whose\n    depth is linear in :math:`n`. See also :func:`.synth_mcmt_chain`.\n    \"\"\"\n\n    def __init__(\n        self,\n        gate: Gate,\n        num_ctrl_qubits: int,\n        num_target_qubits: int,\n        ctrl_state: int | str | None = None,\n        label: str | None = None,\n    ) -> None:\n        \"\"\"\n        Args:\n            gate: The base gate to apply on multiple target qubits, controlled by other qubits.\n                This must be a single-qubit gate or a controlled single-qubit gate.\n            num_ctrl_qubits: The number of control qubits.\n            num_target_qubits: The number of target qubits.\n            ctrl_state: The control state of the control qubits. Defaults to all closed controls.\n            label: The gate label.\n        \"\"\"\n        if num_target_qubits < 1:\n            raise ValueError(\"Need at least one target qubit.\")\n\n        if num_ctrl_qubits < 1:\n            raise ValueError(\"Need at least one control qubit.\")\n\n        self.num_target_qubits = num_target_qubits\n\n        base_gate = self._identify_base_gate(gate)\n        num_qubits = num_ctrl_qubits + num_target_qubits\n\n        if label is None:\n            label = f\"{num_target_qubits}-{gate.name.capitalize()}\"\n\n        super().__init__(\n            \"mcmt\",\n            base_gate=base_gate,\n            num_qubits=num_qubits,\n            params=gate.params,\n            num_ctrl_qubits=num_ctrl_qubits,\n            ctrl_state=ctrl_state,\n            label=label,\n        )\n\n    def _define(self):\n        \"\"\"Default definition relying on gate.control. Control state is handled by superclass.\"\"\"\n        # pylint: disable=cyclic-import\n        from qiskit.transpiler.passes.synthesis.hls_plugins import MCMTSynthesisDefault\n\n        self.definition = MCMTSynthesisDefault().run(self)\n\n    @staticmethod\n    def _identify_base_gate(gate):\n        \"\"\"Get the control base gate. Note this must be a single qubit gate.\"\"\"\n\n        # try getting the standard name from the string\n        if isinstance(gate, str):\n            standard_gates = get_standard_gate_name_mapping()\n            if gate in standard_gates:\n                gate = standard_gates[gate]\n            else:\n                raise AttributeError(\n                    f\"Unknown gate {gate}. Available: {list(get_standard_gate_name_mapping.keys())}\"\n                )\n\n        # extract the base gate\n        if isinstance(gate, ControlledGate):\n            warnings.warn(\n                \"Passing a controlled gate to MCMT is pending deprecation since Qiskit 1.3. Pass a \"\n                \"single-qubit gate instance or the gate name instead, e.g. pass 'h' instead of 'ch'.\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            base_gate = gate.base_gate\n        elif isinstance(gate, Gate):\n            base_gate = gate\n        else:\n            raise TypeError(f\"Invalid gate type {type(gate)}.\")\n\n        if base_gate.num_qubits != 1:\n            raise ValueError(\n                f\"MCMTGate requires a base gate with a single qubit, but got {base_gate.num_qubits}.\"\n            )\n\n        return base_gate\n\n    def control(self, num_ctrl_qubits=1, label=None, ctrl_state=None, annotated=False):\n        \"\"\"Return the controlled version of the MCMT circuit.\"\"\"\n        if not annotated:\n            ctrl_state = _ctrl_state_to_int(ctrl_state, num_ctrl_qubits)\n            new_ctrl_state = (self.ctrl_state << num_ctrl_qubits) | ctrl_state\n\n            gate = MCMTGate(\n                self.base_gate,\n                self.num_ctrl_qubits + num_ctrl_qubits,\n                self.num_target_qubits,\n                ctrl_state=new_ctrl_state,\n            )\n        else:\n            gate = super().control(num_ctrl_qubits, label, ctrl_state, annotated=annotated)\n\n        return gate\n\n    def inverse(self, annotated: bool = False):\n        \"\"\"Return the inverse MCMT circuit.\"\"\"\n        return MCMTGate(\n            self.base_gate.inverse(), self.num_ctrl_qubits, self.num_target_qubits, self.ctrl_state\n        )\n",
    "line_count": 317
  }
]